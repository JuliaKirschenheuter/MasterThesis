<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- Created from PDF via Acrobat SaveAsXML -->
<!-- Mapping table version: 28-February-2003 -->
<HTML>
<HEAD>
<META
 name="dc.creator"
 content="Julia" >
<META
 name="dc.date"
 content="2016-10-31T17:58:26+01:00" >
<META
 name="dc.date.modified"
 content="2016-10-31T17:58:26+01:00" >
<META
 name="generator"
 content="Adobe Acrobat Exchange-Pro 9.0.0" >
</HEAD>
<BODY bgcolor=white text=black link=blue vlink=purple alink=fushia >
<DIV class="Part" 

><P 

><FONT size="+1" color="#000000"></B> </P
><P 

>  </P
><P 

><FONT size="+2">Evaluation von Frontend &ndash; Optimierungstechniken f&uuml;r das HTTP/2 &ndash; Protokoll unter besonderer Beachtung von Server Push <FONT size="+1"> </P
><P 

><FONT size="+1"><B> <FONT size="+1"></B> </P
><P 

><FONT size="+1"><B>Masterthesis <FONT size="+1"></B> </P
><P 

>  </P
><P 

>  </P
><P 

><FONT size="+1">zur Erlangung des akademischen Grades Master of Arts im Studiengang Elektronische Medien<FONT size="+1"> </P
><P 

><FONT size="+1">im Schwerpunkt Audiovisuelle Medien an der Hochschule der Medien Stuttgart<FONT size="+1"> </P
><P 

><FONT size="+1"> <FONT size="+1"> </P
><P 

><FONT size="+1">vorgelegt von <FONT size="+1"> </P
><P 

><FONT size="+1"><B>Iuliia Poberezhnaia <FONT size="+1"></B> </P
><IMG width="192" height="45"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_0.jpg" ><P 

><FONT size="+1"><B> <FONT size="+1"></B> </P
><P 

><FONT size="+1"><B>Erstpr&uuml;fer: </B>Prof. Walter Kriha <FONT size="+1"> </P
><P 

><FONT size="+1"><B>Zweitpr&uuml;fer:</B> Prof. Dipl.-Ing. Uwe Schulz <FONT size="+1"> </P
><P 

><FONT size="+1"> <FONT size="+1"> </P
><P 

><FONT size="+1">Bearbeitungszeitraum: 10. Juli 2016 bis 09. November 2016 <FONT size="+1"> </P
><P 

><FONT size="+1">Stuttgart, November 2016<FONT size="+1"> </P
><P 

>  </P
><P 

>Hiermit versichere ich, Iuliia Poberezhnaia, ehrenw&ouml;rtlich, dass ich die vorliegende Masterarbeit mit dem Titel: &bdquo;Evaluation von Frontend &ndash; Optimierungstechniken f&uuml;r das HTTP2 &ndash; Protokoll unter besonderer Beachtung von Server Push&ldquo; selbstst&auml;ndig und ohne fremde Hilfe verfasst und keine anderen als die angegebenen Hilfsmittel benutzt habe. Die Stellen der Arbeit, die dem Wortlaut oder dem Sinn nach anderen Werken entnommen wurden, sind in jedem Fall unter Angabe der Quelle kenntlich gemacht. Die Arbeit ist noch nicht ver&ouml;ffentlicht oder in anderer Form als Pr&uuml;fungsleistung vorgelegt worden. </P
><P 

>Ich habe die Bedeutung der ehrenw&ouml;rtlichen Versicherung und die pr&uuml;fungsrechtlichen Folgen &sect; 19 Abs. 2 Master-SPO der HdM einer unrichtigen oder unvollst&auml;ndigen ehrenw&ouml;rtlichen Ver-sicherung zur Kenntnis genommen.   </P
><P 

><FONT size="+1">Danksagung </P
><P 

><FONT size="+1">Diese Arbeit w&auml;re nicht ohne die Hilfe verschiedener Personen m&ouml;glich gewesen. An dieser Stelle m&ouml;chte ich mich zuerst bei Herrn Walter Kriha bedanken, der mich bei der Ideenfindung unterst&uuml;tzte, sowie f&uuml;r neue Ans&auml;tze sorgte und die Arbeit so in die richtige Richtung lenkte. Au&szlig;erdem m&ouml;chte ich mich bei Herrn Prof. Dipl.-Ing. Uwe Schulz bedanken, der mir in der Vorlesung relevante praktische Kenntnisse beigebracht hat, ohne die diese Arbeit nicht ent-standen w&auml;re. Au&szlig;erdem bin ich f&uuml;r neue Anregungen und Denkanst&ouml;&szlig;e sehr dankbar. </P
><P 

>Daneben gilt mein besonderer Dank Herrn Robin Schulte, der mir sowohl in der Vorlesung als auch im pers&ouml;nlichen Gespr&auml;ch viel zum Thema Linux und Serverkonfiguration beigebracht hat. Herrn Jakob Schr&ouml;ter danke ich f&uuml;r die Unterst&uuml;tzung beim Thema Webperformance &ndash; Op-timierung, hilfreiche Tipps, m&ouml;gliche Ans&auml;tze und Ideen zum Aufbau der Arbeit. </P
><P 

>F&uuml;r die Korrektur der Arbeit und die pers&ouml;nliche Unterst&uuml;tzung geb&uuml;hrt mein herzlicher Dank Herrn David Kirschenheuter. </P
><P 

>Mein abschlie&szlig;ender Dank gilt der Fakult&auml;t Elektronische Medien und der Hochschule der Me-dien f&uuml;r die Erm&ouml;glichung eines au&szlig;ergew&ouml;hnlichen Masterstudiums! </P
><P 

> </P
><P 

> </P
><P 

>  </P
><DIV class="TOC" 

><DIV class="TOCI" 

><FONT size="+1">Inhaltsverzeichnis </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1048" href="#">
<FONT size="+1">1. Einleitung ................................................................................................................................................................ 1</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1050" href="#">
1.1. Motivation und Problemstellung ........................................................................................................... 1</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1077" href="#">
1.2. Zielsetzung ..................................................................................................................................................... 3</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1084" href="#">
1.3. Aufbau der Arbeit ........................................................................................................................................ 4</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1092" href="#">
2. Der kritische Rendering &ndash; Pfad und seine wichtigsten Komponenten ............................................ 5</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1109" href="#">
2.1. Aufbau des Document Object Model .................................................................................................. 6</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1118" href="#">
2.2. Aufbau des CSS Object Model................................................................................................................ 7</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1123" href="#">
2.3. Render &ndash; Baumstruktur .............................................................................................................................. 7</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1157" href="#">
2.4. &bdquo;Navigation Timing API&ldquo; .......................................................................................................................... 10</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1274" href="#">
2.5. &bdquo;Resource Timing API&ldquo; ............................................................................................................................. 13</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1310" href="#">
2.6. Zwischenfazit ............................................................................................................................................... 15</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1333" href="#">
3. Die Probleme des HTTP/1.1 &ndash; Protokolls, das HTTP/2 &ndash; Protokoll und deren Optimierungsm&ouml;glichkeiten. .............................................................................................................................. 16</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1335" href="#">
3.1. HTTP/1.1 &ndash; Optimierungstechniken, Stand bisher ........................................................................ 16</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1366" href="#">
3.1.1. Nutzung von mehreren TCP &ndash; Verbindungen......................................................................... 18</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1384" href="#">
3.1.2. Aufteilung von Ressourcen auf mehrere Domains (&bdquo;Domain Sharding&ldquo;) ..................... 20</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1388" href="#">
3.1.3. Zusammenfassung von Ressourcen und &bdquo;Spriting&ldquo; von Bildern ...................................... 21</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1405" href="#">
3.1.4. Erg&auml;nzung des Codes in der HTML Datei (&bdquo;Ressource Inlining&ldquo;)..................................... 22</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1422" href="#">
3.2. &bdquo;Evergreen&ldquo; Frontend &ndash; Optimierungsm&ouml;glichkeiten .................................................................. 23</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1473" href="#">
3.2.1. Browser Caching f&uuml;r statische Ressourcen ............................................................................... 24</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1483" href="#">
3.2.2. Datenkompression w&auml;hrend des Transports ........................................................................... 25</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1486" href="#">
3.2.3. Reduzierung der Datenmenge der Ressourcen ..................................................................... 25</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1494" href="#">
3.2.4. Bildoptimierung .................................................................................................................................. 26</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1535" href="#">
3.3. Vorstellung des HTTP/2 &ndash; Protokolls .................................................................................................. 28</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1583" href="#">
3.3.1. Wichtigste Bestandteile des HTTP/2 &ndash; Protokolls ................................................................. 30</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1723" href="#">
3.3.2. Request und Response Multiplexierung ................................................................................... 34</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1744" href="#">
3.3.3. Stream Priorisierung ......................................................................................................................... 35</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1817" href="#">
3.3.4. Header Kompression ........................................................................................................................ 37</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1831" href="#">
3.3.5. Eine TCP &ndash; Verbindung pro Domain ........................................................................................... 38</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1854" href="#">
3.3.6. Flow Control ......................................................................................................................................... 40</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1859" href="#">
3.3.7. Server Push ........................................................................................................................................... 40</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1885" href="#">
3.3.8. Verbindungsaufbau unter dem HTTP/2 &ndash; Protokoll ............................................................. 42</A>
<FONT color="#0462C1"> </DIV
><DIV class="TOCI" 

>  </DIV
></DIV
><DIV class="TOC" 

><DIV class="TOCI" 

><A href="#LinkTarget_1919" href="#">
<FONT color="#000000">3.4. M&ouml;gliche Optimierungstechniken f&uuml;r das HTTP/2 &ndash; Protokoll ................................................ 44</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1961" href="#">
4. Vorbereitung der Tests und zur Testevaluation ..................................................................................... 48</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_1963" href="#">
4.1. Vorbereitung der Tests ............................................................................................................................ 48</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2056" href="#">
4.2. Vorbereitung zur Testevaluation.......................................................................................................... 54</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2213" href="#">
5. Tests und Testevaluation ................................................................................................................................ 63</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2216" href="#">
5.1. Wie funktioniert &bdquo;Server Push&ldquo;? ........................................................................................................... 63</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2275" href="#">
5.2. Zwischenfazit ............................................................................................................................................... 67</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2294" href="#">
5.3. Serverseitige Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen  Ressourcen ................... 69</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2296" href="#">
5.3.1. Test 1: Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien  und Schriften ............................................................................................................................................................ 69</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2317" href="#">
5.3.2. Test 2: Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien und Bildern .............................................................................................................................................................................. 71</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2334" href="#">
5.4. Zwischenfazit ............................................................................................................................................... 72</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2340" href="#">
5.5. Untersuchungen zum &bdquo;Server Push&ldquo; ................................................................................................... 73</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2372" href="#">
5.5.1. Test 1: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r kritische CSS Ressourcen ............................................ 74</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2654" href="#">
5.5.2. Zwischenfazit ....................................................................................................................................... 80</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2657" href="#">
5.5.3. Test 2: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r nicht kritische JavaScript Ressourcen ..................... 80</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2662" href="#">
5.5.4. Test 3: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r kritische CSS Ressourcen und nicht kritische Ressourcen (Schriften) ................................................................................................................................. 81</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2949" href="#">
5.5.5. Zwischenfazit ....................................................................................................................................... 88</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_2953" href="#">
5.5.6. Test 4: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r kritische CSS Ressourcen und nicht  kritische Ressourcen (Bilder) ....................................................................................................................................... 89</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3147" href="#">
5.5.7. Zwischenfazit ....................................................................................................................................... 94</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3151" href="#">
5.6. Zwischenfazit ............................................................................................................................................... 94</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3162" href="#">
5.7. Vergleich des HTTP/1.1 mit dem HTTP/2 &ndash; Protokoll .................................................................. 95</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3301" href="#">
5.7.1. Test 1: Untersuchung der Startseite der Webapplikation unter dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll. ............................................................................................................................. 99</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3608" href="#">
5.7.2. Zwischenfazit .................................................................................................................................... 104</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3614" href="#">
5.7.3. Test 2: Untersuchung der Dozenten-Seite unter den Protokollen HTTP/1.1- und HTTP/2. ........................................................................................................................................................... 105</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3922" href="#">
5.7.4. Zwischenfazit .................................................................................................................................... 111</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_3931" href="#">
5.8. Spielt die Ressourcenaufteilung eine Rolle f&uuml;r das HTTP/2 &ndash; Protokoll? .......................... 111</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4039" href="#">
5.8.1. Zwischenfazit .................................................................................................................................... 114</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4060" href="#">
5.9. Wie funktioniert das HTTP/2 &ndash; Protokoll in anderen Browsern? .......................................... 117</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4063" href="#">
5.9.1. Test 1: Gibt es deutliche Unterschiede in der Bearbeitungsart des neuen Protokolls zwischen den drei popul&auml;rsten Desktop-Browsern? ..................................................................... 117</A>
 </DIV
></DIV
><DIV class="TOC" 

><DIV class="TOCI" 

><A href="#LinkTarget_4086" href="#">
5.9.2. Zwischenfazit .................................................................................................................................... 119</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4090" href="#">
5.9.3. Test2: Wie wird der Browser &bdquo;Google Chrome&ldquo; per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen interpretieren? ..................................................................................................................... 120</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4107" href="#">
5.9.4. Zwischenfazit .................................................................................................................................... 122</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4110" href="#">
5.10. Angetroffene Schwierigkeiten w&auml;hrend der Testdurchf&uuml;hrung und der Testevaluation ............................................................................................................................................................................... 122</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4133" href="#">
6. Fazit und Ausblick ........................................................................................................................................... 125</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4161" href="#">
7. Literaturverzeichnis ........................................................................................................................................ 128</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4973" href="#">
8. Kurzfassung / Abstract .................................................................................................................................. 138</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4979" href="#">
9. Anhang................................................................................................................................................................ 139</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_4981" href="#">
9.1. Upgrade HTTP/2...................................................................................................................................... 139</A>
 </DIV
><DIV class="TOCI" 

><A href="#LinkTarget_5062" href="#">
9.2. Browserstatistik ........................................................................................................................................ 141</A>
 </DIV
><DIV class="TOCI" 

> </DIV
></DIV
><P 

> </P
><P 

> </P
><P 

> </P
><P 

> </P
><P 

> </P
><P 

> </P
><P 

> </P
><P 

> </P
><H1 

><FONT size="+1">1. Einleitung </H1
><H2 

><FONT size="+1">1.1. Motivation und Problemstellung </H2
><P 

><FONT size="+1">In den letzten Jahren sind Internetverbindungen deutlich schneller geworden. Allerdings ist die Ladezeit einer Webseite im Vergleich zu fr&uuml;heren Jahren fast gleich geblieben. Der Grund daf&uuml;r ist, dass die verf&uuml;gbare Bandbreite im Vergleich zur Menge der Daten einer Webseite fast linear w&auml;chst. In den ersten Jahren des Internets lagen die Bandbreiten zwischen 9,6 und 56 kBit/s, deshalb wurde in diesen Zeiten sehr auf die Reduzierung der Datenmenge geachtet. Heutzu-tage hat sich die Bandbreite deutlich vergr&ouml;&szlig;ert und aufgrund dessen werden auch viele Res-sourcen innerhalb einer Webapplikation genutzt (Kuhn/Raith 2013, 5). Abb. 1 veranschaulicht, wie mit der zunehmenden Gr&ouml;&szlig;e aller Responses w&auml;hrend des Transports die Anzahl von Re-quests steigt. Die Messungen wurden pro einer Webseite gemacht. </P
><P 

> </P
><IMG width="607" height="303"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_1.jpg" ><DL 

><DD 

><I>Abb. 1:</I><I> </I><I>Vergleich der durchschnittlichen Gr&ouml;&szlig;e aller Responses w&auml;hrend des Transports mit der durchschnittlichen Anzahl von Requests pro einer Webseite. Die Daten wurden zwischen Januar 2012 und August 2016 gemessen (&lt;</I><A href="http://httparchive.org/">
<I>http://httparchive.org/</I></A>
<I>&gt;). </I></DD
></DL
><P 

>Mit der oben dargestellten Grafik kann man sagen, dass die Webapplikationen selbst immer komplexer werden und die Dateivolumen zunehmen werden. Deshalb kann gesagt werden, dass das Internet bis heute nicht schneller geworden ist, es k&ouml;nnen nur mehr Daten &uuml;bertragen werden (Kuhn/Raith 2013, 5). </P
><P 

> </P
><P 

>In diesem Zusammenhang ist die Webperformance &ndash; Optimierung sehr wichtig. Es werden ein paar Beispiele daf&uuml;r genannt. Die Geschwindigkeit einer Webapplikation beeinflusst z.B. den Onlinehandel sehr. &bdquo;Amazon&ldquo; hat herausgefunden, dass jede 100 ms Verz&ouml;gerung beim Laden der Webseite die Verk&auml;ufe um 1% verringert. &bdquo;Google&ldquo; und &bdquo;Microsoft Bing&ldquo; haben herausge-funden, dass 2 Sekunden Verz&ouml;gerung beim Laden der Webseite das Einkommen um 4.3% </P
><P 

>verringert. Die Untersuchungen der &bdquo;Aberdeen Group&ldquo; zeigen, dass ein Viertel aller Nutzer nur drei Sekunden wartet, bis eine Webapplikation geladen hat. &bdquo;Akamai&ldquo; hat &auml;hnliche Untersu-chungen gemacht und es hat sich herausgestellt, dass 57% aller Nutzer einer Webseite nach einer 4 Sekunden dauernden Wartezeit die Interaktion mit der Webseite beenden werden (Ri-gor, Inc. 2016). Au&szlig;erdem kommt dazu, dass unabh&auml;ngig von den Datenraten in mobilen End-ger&auml;ten, 71% der mobilen Nutzer erwarten, dass die Webapplikation nicht langsamer als am Desktop PC geladen wird (Equation Research 2011). </P
><P 

> </P
><P 

>Etwa 80-90% der gesamten Geschwindigkeit der Webapplikation macht das Frontend aus. Diese Zahlen hat Steve Sounders, leitender Chefingenieur f&uuml;r Webperformance bei &bdquo;Google&ldquo; herausgefunden. In seinen Forschungen konnte er zeigen, dass die gro&szlig;e Mehrheit der Perfor-mance &ndash; Problemstellen, welche von den Websitenutzern gesehen werden, das Laden und Rendern von CSS, JavaScript Dateien und Bildern betrifft (Rigor, Inc. 2016). Deshalb sind die clientseitigen Techniken zur Performance &ndash; Optimierung sehr wichtig. In der aktuellen Master-arbeit wird der Fokus auf diese Techniken gelegt. </P
><P 

> </P
><P 

>Man darf auch nicht vergessen, dass seit Juni 1999 f&uuml;r das Hypertext &ndash; &Uuml;bertragungsprotokoll die Version HTTP/1.1 (Fielding et al. 1999) verwendet wurde. Wie zuvor gesagt wurde, sind die Webapplikationen mit deren vielf&auml;ltigen Medieninhalten immer gr&ouml;&szlig;er und komplexer gewor-den (Grigorik 2013, 161). Mit t&auml;glich zunehmenden Interaktionen im Web und der geforderten Ansprechbarkeit der Webapplikationen in Echtzeit, konnte die Leistung des zuvor verwendeten HTTP/1.1 &ndash; Protokolls kaum der ben&ouml;tigten Leistung entsprechen. Deshalb bestand ein Bedarf an zus&auml;tzlichen Modifikationen (Grigorik 2013, 162). </P
><P 

>Im Januar 2012 wurde von der &bdquo;HTTPbis Working Group&ldquo; eine Nachricht publiziert, dass sie eine neue Spezifikation des HTTP &ndash; Protokolls entwickeln werden. Die neue Version soll die &Uuml;bertragungsleistung beschleunigen und gleichzeitig sollen weniger Latenz und eine gr&ouml;&szlig;ere Durchflussleistung entstehen. Gleichzeitig werden die Semantiken der h&ouml;heren Ebene wie Me-thoden, Statuscodes, URIs und Headerfelder unver&auml;ndert bleiben. Dies bedeutet, dass man die neue Version des Protokolls ohne zus&auml;tzliche &Auml;nderungen in der Webapplikation verwenden kann. (Grigorik 2013, 162) </P
><P 

>Im Februar 2015 wurde die neue Version des HTTP &ndash; Protokolls: HTTP/2 von der IESG (&bdquo;The Internet Engineering Steering Group&ldquo;) genehmigt (Grigorik 2015, 4). Im Mai des gleichen Jahres ist die offizielle Dokumentation des Protokolls erschienen: RFC &ndash; 7540 (Belshe et al. 2015) und RFC &ndash; 7541 (Peon/Ruellan 2015). Um den Ressourcenaustausch zwischen Client und Server un-ter dem bisher verwendeten HTTP/1 &ndash; Protokoll etwas zu beschleunigen, werden bestimmte Frontend &ndash; Optimierungsma&szlig;nahmen f&uuml;r die Webapplikation angewendet. Diese werden oft als &bdquo;Workarounds&ldquo; bezeichnet, weil diese viele Nachteile haben (Grigorik 2013, 162). Bei der Verwendung des neuen Protokolls sind die im HTTP/1-Protokoll beliebten &bdquo;Workarounds&ldquo; </P
><P 

>nicht mehr n&ouml;tig (Grigorik 2013, 242). Dies bedeutet, dass der Entwicklungsprozess einer Webapplikation unter dem HTTP/2 &ndash; Protokoll unkomplizierter sein sollte. </P
><P 

> </P
><P 

>Mithilfe des HTTP/2 &ndash; Protokolls k&ouml;nnen existierende Problemstellen des HTTP/1 &ndash; Protokolls limitiert werden. Hinsichtlich der technologischen M&ouml;glichkeiten des HTTP/2 &ndash; Protokolls kann der Austausch zwischen dem Client und dem Server deutlich beschleunigt werden (Buch, Excerpt HTTP/2 IG, 5). Aus diesem Grund entstand die Hauptmotivation f&uuml;r die Untersuchung des neuen Protokolls, die in der aktuellen Masterarbeit schrittweise ausgearbeitet wird. </P
><H2 

><FONT size="+1">1.2. Zielsetzung </H2
><P 

><FONT size="+1">Das HTTP/2 &ndash; Protokoll verf&uuml;gt &uuml;ber viele neue Funktionen, die die Ladezeit der Webapplika-tion rasant beschleunigen k&ouml;nnen (Buch, Excerpt HTTP/2 IG, 5).<FONT color="#FF0000"> <FONT color="#000000">Einige Funktionen werden in-nerhalb der Benutzung dieses Protokolls automatisch angewendet. Bei anderen Funktionen besteht die M&ouml;glichkeit, diese f&uuml;r jede einzelne Webapplikation individuell anzupassen. Dazu geh&ouml;rt die Funktion &bdquo;Server Push&ldquo;, die in zahlreichen Quellen (Grigorik 2015, 17), (Jayaprakash 2016), (Krasnov 2016), (Ross, 2016) als sehr leistungsf&auml;hig f&uuml;r die Beschleunigung der Ladezeit der Webapplikation erachtet wird. Wie zuvor erw&auml;hnt wurde, liegt der Fokus der aktuellen Masterarbeit auf den Untersuchungen der Frontend Performance &ndash; Optimierungstechniken. In diesem Zusammenhang ist es interessant, zu beobachten, wie gro&szlig; die Einfl&uuml;sse des &bdquo;Server Pushs&ldquo; auf die Ladezeit der Webapplikation sind. Welche Techniken m&uuml;ssen angewendet wer-den, um diese Funktion m&ouml;glichst vorteilhaft nutzen zu k&ouml;nnen? Aufgrund dessen, liegt das erste Ziel dieser Masterarbeit auf der Untersuchung der Ladezeit der Webapplikation mithilfe des HTTP/2 &ndash; Protokolls und dessen Funktion &bdquo;Server Push&ldquo; in unterschiedlichen Eins&auml;tzen. Besonders wird dabei auf die clientseitigen Frontend Performance &ndash; Optimierungstechniken geachtet. </P
><P 

>Das zweite Ziel ist der Vergleich der Unterschiede der Ladezeit der Webapplikation zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll, wenn die Webapplikation gesondert f&uuml;r jede Ver-sion des HTTP &ndash; Protokolls optimal angepasst wird. Es ist interessant zu untersuchen, wie gro&szlig; die Vorteile des neuen Protokolls sind. </P
><P 

>Das dritte Ziel, das in der aktuellen Arbeit verfolgt wird, ist die Auseinandersetzung mit der Konfiguration des Webservers f&uuml;r das HTTP/2 &ndash; Protokoll im Hinblick auf den &bdquo;Server Push&ldquo;. Zum anderen sollen die wichtigsten Schritte und Metriken des kompletten Ladezeitprozesses einer Webapplikation ausgew&auml;hlt werden, die sowohl f&uuml;r die Erstdarstellung, als auch f&uuml;r die Gesamtladezeit im Webbrowser wichtig sind. </P
><P 

>Die Ergebnisse der aktuellen Arbeit sollen den Stand der aktuellen Implementierung des HTTP/2 &ndash; Protokolls zeigen. Dadurch sollen Frontend &ndash; Webentwicklern Hinweise gegeben werden, welche Ma&szlig;nahmen unternommen werden m&uuml;ssen, um perfomante Webanwendun-</P
><P 

>gen unter dem neuen Protokoll zu erstellen. Zum anderen werden angetroffene Schwierigkei-ten und Schwachstellen aufgezeigt, die w&auml;hrend des Testverlaufs oder der Testauswertung er-kannt wurden. </P
><H2 

><FONT size="+1">1.3. Aufbau der Arbeit </H2
><P 

><FONT size="+1">Um die gesetzten Ziele zu erreichen, wurde die vorliegende Arbeit in mehrere Kapitel aufgeteilt: Theoretische Grundlagen, Vorbereitung der Tests und Testevaluation, Testdurchf&uuml;hrung, sowie Evaluation und abschlie&szlig;ende Betrachtung. </P
><P 

>In ersten theoretischen Kapitel wird der kritische Rendering &ndash; Pfad und dessen Rolle in der Webperformance &ndash; Optimierung dargestellt. Es werden die Modelle der &bdquo;Navigation Timing API&ldquo; und der &bdquo;Ressource Timing API&ldquo; vorgestellt. </P
><P 

>In einem weiteren theoretischen Kapitel wird zun&auml;chst analysiert, welche Problemstellen unter dem HTTP/1 &ndash; Protokoll existieren und  mit welchen clientseitigen Techniken zur Perfor-mance &ndash; Optimierung diese gel&ouml;st werden k&ouml;nnen. Anschlie&szlig;end werden die wichtigsten Frontend &ndash; Optimierungstechniken beschrieben, die unabh&auml;ngig von der Version des verwen-deten HTTP &ndash; Protokolls f&uuml;r die Erstellung performanter Webapplikationen geeignet sind (sog. &bdquo;Evergreen&ldquo;-Techniken). Zuletzt wird als theoretische Grundlage das HTTP/2 &ndash; Protokoll und dessen Funktionen dargestellt. Ebenso werden die Frontend &ndash; Optimierungstechniken be-schrieben, die f&uuml;r das neue Protokoll geeignet sein k&ouml;nnen. </P
><P 

>Im Rahmen der Testvorbereitungen wird eine Webapplikation entwickelt, die f&uuml;r die Fragestel-lung dieser Masterarbeit interessant zum Untersuchen ist. Es werden jeweils f&uuml;r das HTTP/1.1- und HTTP/2 &ndash; Protokoll spezifische Frontend &ndash; Optimierungsma&szlig;nahmen ausgew&auml;hlt und auf die Webapplikation angewendet. Dadurch sollen optimale Bedingungen f&uuml;r die Webapplika-tion unter beiden Protokollen erreicht werden. Als n&auml;chstes wird er&ouml;rtert, wie der passende Webserver ausgew&auml;hlt und konfiguriert werden soll, damit er die Implementierung des HTTP/2 &ndash; Protokolls mit der Funktion &bdquo;Server Push&ldquo; unterst&uuml;tzt. Als letzten Schritt zur Testvor-bereitung werden hilfreiche Tools f&uuml;r die Durchf&uuml;hrung der Tests vorgestellt. Au&szlig;erdem wird eine geeignete Auswertungsmethode vorgestellt. </P
><P 

>Im n&auml;chsten Kapitel wird die entwickelte Webapplikation unter unterschiedlichen Bedingungen getestet und die Ergebnisse evaluiert. Da der Fokus dieser Arbeit auf der Untersuchung der Funktion &bdquo;Server Push&ldquo; liegt, werden daf&uuml;r unterschiedliche Eins&auml;tze simuliert, um herauszufin-den, welche dieser Eins&auml;tze f&uuml;r die Performanz vorteilhaft sein k&ouml;nnen. </P
><P 

>Im zweiten Test-Teil wird untersucht, wie gro&szlig; die Unterschiede der Ladezeit zwischen dem HTTP/1- und dem HTTP/2 &ndash; Protokoll sind. W&auml;hrend der Testevaluation  werden die theoreti-schen Ergebnisse mit den erzielten Testergebnissen verglichen, um zu sehen, ob die theoreti-schen Annahmen zu den erzielten Ergebnissen passen. </P
><P 

>Abschlie&szlig;end werden s&auml;mtliche Ergebnisse zusammengefasst und ein Ausblick gegeben.  </P
><H1 

><FONT size="+1">2. Der kritische Rendering &ndash; Pfad und seine wichtigsten Komponenten </H1
><P 

><FONT size="+1">In der Einleitung wurde kurz erl&auml;utert, was die Web Performance f&uuml;r kommerzielle Webauftritte ausmacht und warum clientseitige Techniken zur Performance &ndash; Optimierung so wichtig sind. Performance &ndash; Optimierung ist ein Prozess, der zur Verbesserung der Ausliefergeschwindigkeit von Webdiensten f&uuml;hrt, um so die Nutzererwartung (geringe Ladezeit) zu erf&uuml;llen (Mishunov 2015). Wie lange darf eine Webseite geladen werden? Nach dem &bdquo;Platform Success Model&ldquo;, das von Google erstellt wurde (Duca/Glazkov 2016), ist das Limit der Ladezeit einer Webseite auf eine Sekunde begrenzt. Diese Reaktionszeit h&auml;ngt mit psychologischen Aspekten der menschlichen Kommunikation zusammen. Normalerweise gibt es in einem pers&ouml;nlichen Dialog zwischen zwei Menschen eine kurze Reaktionszeit auf eine Frage. Nutzer wollen von einer Web-seite die gleiche Reaktionszeit haben, wie bei zwischenmenschlicher Kommunikation. Aus die-sem Grund muss man bei der Performance &ndash; Optimierung wichtige Zeitstufen aus der Psycho-logie im Kopf behalten (Mishunov 2015). Diese Stufen sind: </P
><DL 

><DD 

>&#61630; &bdquo;Augenblicklich&ldquo;: 0,1-0,2 Sekunden. </DD
><DD 

>&#61630; &bdquo;Unmittelbar&ldquo;: 0,5-1 Sekunde. </DD
><DD 

>&#61630; &bdquo;Phase der Absorption&ldquo;: 2 bis 5 Sekunden. </DD
><DD 

>&#61630; &bdquo;Endzeit der Aufmerksamkeit &ldquo;: 5 bis 10 Sekunden. </DD
></DL
><P 

>(Mishunov 2015). </P
><P 

>Wenn man diese Stufen auf das &bdquo;Platform Success Model&ldquo; anwendet, bekommt man Ladezei-ten einer Webseite, die der Reaktionszeit zwischenmenschlicher Kommunikation &auml;hnlich sind: der Ladevorgang der Webseite soll unmittelbar beginnen und die Nutzer sollen augenblickli-che R&uuml;ckmeldungen von der Webapplikation bekommen. Deshalb liegt das Ziel der Perfor-mance &ndash; Optimierung im Erreichen von Ladezeiten, die im Rahmen der Reaktionszeiten zwi-schenmenschlicher Kommunikation liegen (Mishunov 2015). </P
><P 

>Allerdings z&auml;hlen nicht nur die Zahlen, die beim Laden einer Webseite gemessen werden k&ouml;n-nen. Wichtig ist auch die von Nutzern wahrgenommene Ladezeit. Diese besagt, was der Nutzer denkt, wie lange die Webseite geladen wurde. Um diese wahrgenommene Ladezeit optimieren zu k&ouml;nnen, m&uuml;ssen zuerst alle wichtigen (als erste sichtbare) Komponenten geladen werden. Wenn die Webseite z.B. einen Footer beinhaltet, deren Komponenten sich nicht im Viewport befinden, sind diese Informationen nur nebens&auml;chlich und k&ouml;nnen sp&auml;ter geladen werden. Des Weiteren ist es auch wichtig, die Inhalte zu &uuml;bergeben, mit denen der Nutzer interagieren kann. Man muss darauf achten, dass diese Inhalte auch eine Interaktionskomponente haben (z.B. klickbare Buttons). Der Schwerpunkt der Performance &ndash; Optimierung muss auf der wahrge-nommenen Ladezeit liegen (Mishunov 2015). </P
><P 

>In diesem Kapitel wird beschrieben, welche Schritte im Browser passieren, um eine Webappli-kation darstellen zu k&ouml;nnen. Dazu wird erkl&auml;rt, was der kritische Rendering &ndash; Pfad ist und wa-rum es wichtig ist, diesen zu optimieren. Au&szlig;erdem wird erl&auml;utert, wie eigentlich die Perfor-mance gemessen werden kann und welche Parameter dazu ben&ouml;tigt werden. </P
><H2 

><FONT size="+1">2.1. Aufbau des Document Object Model </H2
><P 

><FONT size="+1">Bevor der Browser erste Pixel der Webapplikation im Viewport darstellt, m&uuml;ssen einige Schritte stattgefunden haben. Das Document Object Model (DOM) der HTML Datei und das CSS Object Model (CSSOM) von allen CSS Dateien m&uuml;ssen aufgebaut und in einem Render &ndash; Baum zu-sammengef&uuml;gt werden (Abb. 2) (Grigorik 2013, 168). Nachdem die ersten Bytes des HTML Do-kuments den Browser erreichen, f&auml;ngt er an, das HTML Dokument zu parsen (Grigorik 2016a). </P
><P 

>Die DOM-Erstellung besteht aus mehreren Phasen: zuerst wird der Browser die Rohbytes mit-hilfe der Dateicodierung (z.B. UTF-8) in einzelne Zeichen &uuml;bersetzen. Im n&auml;chsten Schritt wer-den die Zeichenfolgen, die sich in spitzen Klammern befinden, in eindeutige Token konvertiert, wie z.B. &lt;html&gt;, &lt;head&gt; u.s.w. Jedes Token hat gem&auml;&szlig; dem &bdquo;W3C&ldquo; HTML5-Standard (W3C 2014a) eine spezielle Bedeutung und Satzregeln. Im dritten Schritt werden die Token in Objekte umgebaut, die eigene Merkmale und Eigenschaften haben. Im letzten Schritt werden die zuvor hergestellten Objekte f&uuml;r die Erstellung einer hierarchischen Baumstruktur verwendet (Grigorik 2016c). </P
><P 

> </P
><IMG width="610" height="285"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_2.jpg" ><DL 

><DD 

><I>Abb. 2:</I><I> </I><I>Aufbau des Render - Baumes, (Grigorik 2016d). </I></DD
></DL
><P 

>  </P
><H2 

><FONT size="+1">2.2. Aufbau des CSS Object Model </H2
><P 

><FONT size="+1">Falls w&auml;hrend dem HTML-Parsing ein Link-Tag auf eine externe CSS Datei gefunden wird, wird sie sofort am Server angefordert (Grigorik 2016c). Parallel zur DOM Erstellung wird das CSS Object Model (CSSOM) aufgebaut (Grigorik 2013, 168). </P
><P 

>CSS Dateien sind auch f&uuml;r die Erstdarstellung der Webapplikation wichtig. Sie beschreiben die Formatierungsregeln, die f&uuml;r eine HTML Datei angewendet werden (Grigorik 2016d). Deshalb wird der Browser, wenn die CSS Datei vom Parser heruntergeladen wird, sofort anfangen, die CSS Datei zu bearbeiten. Die visuelle Darstellung wird dadurch blockiert werden (Grigorik 2016e).<FONT color="#FF0000"> </P
><P 

><FONT color="#000000">Die CSSOM Erstellung besteht auch aus mehreren Phasen, die der DOM Erstellung sehr &auml;hnlich sind (Abb. 2). Zuerst wird der Browser die Rohbytes in einzelne Zeichen mithilfe der Dateico-dierung (z.B. UTF-8) &uuml;bersetzen. Im n&auml;chsten Schritt werden die Zeichenfolgen in eindeutige Token konvertiert. Danach werden die Token in Objekte umgebaut, die eigene Merkmale und Eigenschaften von CSS Spezifikationen haben. Im letzten Schritt werden diese Objekte in einer Baumstruktur verbunden. CSSOM hat eine Baumstruktur, weil die CSS-Regeln zuerst auf ein Eltern-Element eines Objektes angewendet werden. Erst danach werden die CSS-Regeln auf das Objekt selbst angewendet (Grigorik 2016c). </P
><H2 

><FONT size="+1">2.3. Render &ndash; Baumstruktur  </H2
><P 

><FONT size="+1">Auf der Basis der DOM- und CSSOM-Baumstrukturen wird eine Render &ndash; Baumstruktur erstellt (Abb. 2). Mithilfe der Render &ndash; Baumstruktur wird der Browser aus allen auf der Seite sichtbaren Elementen ein Layout erstellen. Nach diesem Schritt werden die ersten Pixel im Viewport er-scheinen (Abb. 3) (Grigorik 2016c). </P
><P 

>Der Prozess der Erstellung der Render &ndash; Baumstruktur besteht aus mehreren Etappen, die in Abb. 3 dargestellt werden:  </P
><DL 

><DD 

>1. Jeder sichtbare Knoten in der DOM &ndash; Baumstruktur wird gefunden. Dieser Schritt be-trifft nicht alle Elemente, z.B. Script-Tags oder Metatags werden auf der Seite unsichtbar sein und werden weggelassen. Au&szlig;erdem werden manche Elemente mithilfe der CSS-Regeln versteckt. Diese Elemente werden auch nicht in der Render &ndash; Baumstruktur er-scheinen. </DD
><DD 

>2. F&uuml;r jeden Knoten, der sichtbar ist, werden entsprechende CSS-Regeln gesucht und an-gewendet. </DD
><DD 

>3. Im letzten Schritt werden die sichtbaren Knoten mit den entsprechenden CSS-Regeln ausgegeben und die Render &ndash; Baumstruktur wird fertiggestellt.  </DD
></DL
><P 

>(Grigorik 2016d). </P
><P 

><I>  </I></P
><P 

><I>Einfluss von JavaScript </I></P
><P 

>JavaScript spielt auch eine gro&szlig;e Rolle bei der Erstellung des DOMs und CSSOMs. JavaScript kann sowohl die Inhalte der HTML Seite als auch CSS-Regeln &auml;ndern und manipulieren (Abb. 3). Die DOM-Erstellung wird angehalten, bevor JavaScript nicht komplett heruntergeladen und ausgef&uuml;hrt wurde. Falls eine JavaScript Datei oder ein JavaScript-Code in der HTML Seite ent-deckt wird, bevor der Aufbau des CSSOM fertig ist, wird der Browser warten, bis  CSSOM kom-plett aufgebaut wird. Erst danach wird die JavaScript Datei ausgef&uuml;hrt. Dann kann das DOM fertig gestellt werden und der Browser kann mit dem Aufbau der Render &ndash; Baumstruktur an-fangen (Grigorik 2016f), (Grigorik 2016h). </P
><P 

> </P
><IMG width="463" height="144"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_3.jpg" ><DL 

><DD 

><I>Abb. 3:</I><I> </I><I>Bearbeitungskette der HTML-, CSS- und JavaScript Dateien im Browser (Grigorik 2013, 168).  </I></DD
></DL
><P 

>F&uuml;r die Erstdarstellung auf dem Viewport sind nur HTML, CSS und JavaScript Dateien wichtig (Grigorik 2016h). Alle andere Dateien (z.B. Bilder oder Schriften) spielen hier keine Rolle. Die Ladereihenfolge von diesen Dateien ist wichtig: JavaScript muss so wenig wie m&ouml;glich die Ren-der &ndash; Baumstruktur verz&ouml;gern. Falls die JavaScript Dateien synchron geladen werden, wird die DOM-Erstellung w&auml;hrend des Ladens und der Ausf&uuml;hrung der JavaScript Dateien angehalten (Grigorik, 2012). Gleichzeitig m&uuml;ssen CSS Dateien so schnell wie m&ouml;glich dem Client &uuml;bergeben werden, damit das CSSOM m&ouml;glichst fr&uuml;h aufgebaut wird (Grigorik 2016h). Um dies zu errei-chen, ist es empfehlenswert, CSS Dateien am Anfang der HTML Seite zu platzieren, damit der Browser gleich anfangen wird, diese herunterzuladen. Au&szlig;erdem ist es hilfreich, Medienabfra-gen zu benutzen, in der bestimmte Merkmale zur CSS Datei stehen (z.B. media=&quot;print&quot; f&uuml;r die Druckansicht). Mithilfe von diesen Merkmalen werden alle eingebundenen CSS Dateien herun-tergeladen, aber die Ausf&uuml;hrungszeit wird verk&uuml;rzt (Grigorik 2016e). </P
><P 

>JavaScript kann auf die DOM-Elemente zugreifen, deshalb m&uuml;ssen die DOM-Knoten zuerst er-stellt werden. Au&szlig;erdem m&uuml;ssen die DOM-Elemente im Baum gefunden werden, bevor Ja-vaScript ausgef&uuml;hrt wird. Da JavaScript den weiteren DOM-Aufbau blockiert und gleichzeitig auf CSSOM wartet, ist es empfehlenswert, die JavaScript Dateien am Ende des HTML Doku-ments einzubinden (Grigorik, 2012). </P
><P 

>Wenn die JavaScript Datei f&uuml;r die DOM-Struktur und die Erstdarstellung nicht wichtig ist, ist es empfehlenswert, die Skripte asynchron zu laden oder dann zu laden, wenn das DOM fertig </P
><P 

>gebaut ist. &bdquo;Async&ldquo; und &bdquo;defer&ldquo; Attribute sind boolean Attribute, die zeigen, wie die JavaScript Dateien ausgef&uuml;hrt werden sollen (W3C 2014b). </P
><P 

>Wenn asynchrone JavaScript Dateien gefunden werden, werden sie sofort w&auml;hrend dem HTML-Parsing heruntergeladen, und asynchron ausgef&uuml;hrt, sobald sie zur Verf&uuml;gung stehen. Dies passiert  unabh&auml;ngig davon, in welcher Reihenfolge sie in der HTML Datei aufgelistet sind. Daf&uuml;r ist ein &bdquo;async&ldquo; Attribut verantwortlich (W3C 2014b), (Souders 2010). </P
><P 

>Eine andere M&ouml;glichkeit ist es, das Attribut &bdquo;defer&ldquo; zu verwenden. Dieses signalisiert dem Brow-ser, dass er die JavaScript Datei erst ausf&uuml;hren muss, wenn das HTML Dokument fertig gepar-sed ist (W3C 2014b). JavaScript Dateien mit dem Attribut &bdquo;defer&ldquo; werden parallel herunterge-laden, aber werden genau in der Reihenfolge ausgef&uuml;hrt, in welcher sie im HTML-Dokument aufgelistet sind. Dies passiert unabh&auml;ngig davon, in welcher Reihenfolge sie angekommen sind (Souders 2010). </P
><P 

>Bei der Verwendung von sowohl &bdquo;defer&ldquo; als auch &bdquo;async&ldquo; Attributen, wird die DOM-Erstellung nicht mehr blockiert (Grigorik, 2012).<FONT color="#FF0000"> </P
><P 

><FONT color="#000000">Diese beiden Attribute werden von popul&auml;ren modernen Browsern unterst&uuml;tzt (Mozilla Deve-loper Network and individual contributors 2016a).  </P
><P 

>Die Anwendung sowohl von &bdquo;defer&ldquo; als auch von &bdquo;async&ldquo; Attributen f&uuml;r Skripte, die im HTML-Code eingef&uuml;gt sind, hat keinen Effekt (Mozilla Developer Network and individual contributors 2016a). </P
><P 

>Nachdem die Render &ndash; Baumstruktur fertiggestellt ist, wird das Layout berechnet (Abb. 3). Je nachdem, wie komplex die HTML und CSS Dateien sind, ob JavaScript DOM-Elemente anders platzieren wird oder CSSOM-Elemente &auml;ndern wird, wird die Berechnung des Seitenlayouts  einige Zeit brauchen. Nachdem das Layout fertig gestellt wurde, wird der Browser auf den je-weiligen Ebenen Teile der visuellen Elemente zeichnen. Dazu geh&ouml;ren z.B. Farben, Schriften, Bilder u.s.w. Im letzten Schritt werden alle Ebenen mit dem darauf gezeichneten Content zu-sammengesetzt. Dieser Schritt ist wichtig, damit die Elemente, die im Viewport angezeigt wer-den, ihre Richtige Stelle haben werden und nicht &uuml;berlappen werden (Lewis 2016). </P
><P 

>Die Produktivit&auml;t dieser letzten Schritte h&auml;ngt oftmals von der Entwicklungsqualit&auml;t der einzel-nen Bestandteile  ab: HTML, CSS und JavaScript. Es gibt viele Optimierungsm&ouml;glichkeiten, die die Ausf&uuml;hrung dieser Schritte beschleunigen k&ouml;nnen. Allerdings werden Optimierungsm&ouml;g-lichkeiten ab der Erstellung des Render &ndash; Baumes im Rahmen dieser Masterarbeit nicht be-trachtet, weil diese Art von Optimierungen zur Optimierung einzelner Dateien der Webanwen-dung geh&ouml;ren und nicht direkt mit der Optimierung der Dateiauslieferung zusammenh&auml;ngen. </P
><P 

>Alle diese Schritte, die zwischen dem Empfang der HTML, CSS und JavaScript Dateien passie-ren, wie schnell diese verarbeitet werden, und bis diese als gerenderte Pixel im Viewport er-scheinen, ist der kritische Rendering &ndash; Pfad (Grigorik 2016g). </P
><H2 

><FONT size="+1">2.4. &bdquo;Navigation Timing API&ldquo; </H2
><P 

><FONT size="+1">F&uuml;r die detaillierte Analyse des kritischen Rendering &ndash; Pfades einer Webapplikation im Webbrowser steht das &bdquo;Navigation Timing API&ldquo; Tool zur Verf&uuml;gung (Grigorik 2016a). Die &bdquo;Na-vigation Timing API&ldquo; wurde vom &bdquo;W3C&ldquo; (World Wide Web Consortium) (W3C 2016a) spezifi-ziert und dokumentiert.<FONT color="#FF0000"> </P
><P 

><FONT color="#000000">&bdquo;Navigation Timing API&ldquo; definiert ein Interface f&uuml;r Webapplikationen, das Messdaten zum kom-pletten Zeitraum, der f&uuml;r die Navigation &uuml;ber das komplette Dokument (HTML Datei) ben&ouml;tigt wird, sammelt und diese Daten zur Verf&uuml;gung stellt (W3C 2016b). Die &bdquo;Navigation Timing API&ldquo; wurde in allen popul&auml;ren mobilen und Desktopbrowsern implementiert (Mozilla Developer Network and individual contributors 2016b). Mithilfe dieser API kann der Browser die gesam-melten Messdaten der verschiedenen Phasen des kritischen Rendering &ndash; Pfades zur Verf&uuml;gung stellen (W3C 2016b), (Grigorik 2016a). </P
><P 

>&bdquo;Navigation Timing API&ldquo; wird vom &bdquo;W3C&ldquo; als &bdquo;Performance Navigation Timing&ldquo; Interface be-zeichnet. Abb. 4 illustriert die Attribute des &bdquo;Performance Navigation Timing&ldquo; Interfaces (W3C 2016b). Diese Attribute werden in Millisekunden ausgeliefert. </P
><P 

> </P
><IMG width="612" height="313"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_4.jpg" ><DL 

><DD 

><I>Abb. 4:</I><I> </I><I>&bdquo;Performance</I><I> </I><I>Navigation Timing&ldquo; Interface (</I><I>&lt;</I><A href="https://www.w3.org/TR/navigation-timing-2/">
<I>https://www.w3.org/TR/navigation-tim-ing-2/</I></A>
<I>&gt;). </I></DD
></DL
><P 

>  </P
><P 

>Das &bdquo;Performance Timing Interface&ldquo; stellt eine komplette Kette der Navigation dar, die in jedem Browser passiert. Jedes Performance Timing Attribut hat einen Start- und Endpunkt. Dies er-&ouml;ffnet die M&ouml;glichkeit, zu untersuchen, wie lange ein bestimmtes Event gedauert hat. Nach dem Aufruf einer Webapplikation wird zuerst die zuvor angezeigte Webapplikation vom Viewport gel&ouml;scht. Die Zeit daf&uuml;r kann als Differenz zwischen &bdquo;unloadEventEnd&ldquo; und &bdquo;unloadE-ventStart&ldquo; berechnet werden. Falls es keine zuvor geladene Seite gibt, oder die fr&uuml;here Seite oder einer der erforderlichen Redirects nicht die gleiche Domain haben, wird dieser Wert auf 0 gesetzt. Danach wird die Internetadresse vom Netzwerk aufgerufen (Mozilla Developer Net-work and individual contributors 2016c). </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Attribute des &bdquo;Performance Navigation Timing&ldquo; Inter-faces </P
></TD
><TD  
 valign="top"
><P 

>Bedeutung </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;redirect&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Wird ausgegeben, wenn ein Redirect stattfindet. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;fetchStart&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Registriert den Zeitpunkt, an dem der Client anf&auml;ngt, nach der Ressource mithilfe des HTTP-Requests zu fragen. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;domainLookupEnd&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Registriert den Zeitpunkt, an dem die IP-Adresse des Domain-namens bestimmt wird. Falls die IP-Adresse des Domainna-mens aus dem Cache der Anwendung aufgerufen wird, wird dieser Parameter den gleichen Zeitpunkt wie der des &bdquo;fetchStart&ldquo; Attributs haben. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;connectEnd&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Wird ausgegeben, wenn die Verbindung zum Server herge-stellt wurde. Falls es eine verschl&uuml;sselte Verbindung ist, wird ein TSL-Handshake zwischen den &bdquo;connectStart&ldquo;- und &bdquo;connectEnd&ldquo; Attributen angezeigt. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;requestStart&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Das HTML Dokument wird vom Server, dem Anwen-dungscache oder einer lokalen Ressource angefragt. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;responseStart&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Wird dann ausgegeben, wenn das erste Byte der Anfrage den Client erreicht. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;responseEnd&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Registriert den Zeitpunkt, an dem der Client alle Bytes der An-frage bekommen hat. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;domLoading&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Zeigt den Zeitstempel, ab wann der Browser mit dem Parsen der empfangenen Bytes anf&auml;ngt. Dieser Wert wurde in Abb. 4 nicht angezeigt, da alle existierenden Webbrowser auf unter-schiedliche Weise das DOM erstellen und die Zeitpunkte f&uuml;r das &bdquo;domLoading&ldquo; Attribut sich je nach Implementierung un-terscheiden. Deshalb ist es nicht empfehlenswert, dieses Attri-but f&uuml;r die Messungen zu benutzen (Grigorik 2016a), (W3C 2016b). </P
></TD
></TR
></TABLE
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>&bdquo;domInteractive&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Das Attribut zeigt den Zeitstempel an, an dem das HTML-Do-kument fertig geparsed wurde und das DOM erstellt wurde (Mozilla Developer Network and individual contributors 2016c) (Grigorik, 2012). In diesem Moment &auml;ndert sich der Document.readyState auf &bdquo;interactive&ldquo;. Dies bedeutet, dass das Dokument mit dem Laden fertig ist und dass es fertig geparsed wurde. Alle anderen Ressourcen, wie z.B. Styles, Bilder u.s.w. sind noch am Laden (Mozilla Developer Network and indivi-dual contributors 2016d). </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;domContentLoadedE-ventStart&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Das Attribut markiert den Zeitpunkt kurz bevor der Parser das &bdquo;domContentLoaded&ldquo;-Event setzen wird. Dies passiert unmit-telbar nachdem alle Skripte die f&uuml;r das Parsing ausgef&uuml;hrt wer-den m&uuml;ssen, ausgef&uuml;hrt wurden (Mozilla Developer Network and individual contributors 2016c). &bdquo;DomContentLoaded&ldquo; ist ein Event das dann erscheinen wird, wenn das HTML Doku-ment komplett heruntergeladen und geparsed wurde, ohne auf Styles, Bilder u.s.w. zu warten (Mozilla Developer Network and individual contri-butors 2016e). Dieses Attribut wird in der jQuery JavaScript-Bibliothek f&uuml;r den Startpunkt der Ausf&uuml;h-rung von JavaScript Dateien benutzt, die innerhalb der &bdquo;$( document ).ready().&ldquo; geschrieben sind. In diesem Fall werden die Skripte ausgef&uuml;hrt, wenn das DOM komplett geladen wurde (The jQuery Foundation 2016a), (The jQuery Foundation 2016b). </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;domContentLoadedEven-tEnd&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Das Attribut wird den Zeitpunkt markieren, an dem alle Skripte, die ausgef&uuml;hrt werden m&uuml;ssen, ausgef&uuml;hrt sind. Deshalb ist die Zeit, die zwischen domContentLoadedEventStart und dom-ContentLoadedEventEnd ben&ouml;tigt wird &ndash; die Zeit f&uuml;r die Aus-f&uuml;hrung von JavaScript Dateien, die nach dem domContent-LoadedEventStart Attribut ausgef&uuml;hrt werden m&uuml;ssen. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;domComplete&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Das Attribut wird gesetzt, wenn der Parser das Dokument fertig bearbeitet hat. In diesem Moment wird sich der Document.readyState auf den Status &bdquo;complete&ldquo; &auml;ndern. Dies bedeutet, dass das Hauptdokument und alle anderen Ressour-cen fertig geladen sind (Mozilla Developer Network and indi-vidual contributors 2016d). </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>&bdquo;loadingEventStart&ldquo; und &bdquo;loadingEventEnd&ldquo; </P
></TD
><TD  
 valign="top"
><P 

>Registriert den Zeitpunkt, an dem das &bdquo;load&ldquo;-Event f&uuml;r das Do-kument gesetzt wurde. Das &bdquo;load&ldquo;-Event wird erscheinen, wenn das Dokument und alle davon abh&auml;ngigen Ressourcen fertig </P
></TD
></TR
></TABLE
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
></TD><TD  
 valign="top"
><P 

>geladen wurden (Mozilla Developer Network and individual contributors 2016f). Das &bdquo;loadingEventEnd&ldquo; Attribut wird den Zeitstempel anzeigen, an dem das &bdquo;load&ldquo;-Event abgeschlossen wird (Mozilla Developer Network and individual contributors 2016c). Dies ist der letzte Schritt beim Laden der Webapplika-tion: der Webbrowser wird das &bdquo;onLoad&ldquo; Ereignis ausgeben. Dies bedeutet, dass die weitere Anwendungslogik gestartet werden kann (Grigorik 2016a).<FONT color="#0462C1"> </P
></TD
></TR
></TABLE
><DL 

><DD 

><FONT color="#000000"><I>Tab. 1:</I><I> </I><I>Attribute des &bdquo;Performance Navigation Timing&ldquo;</I><I> Interfaces (Mozilla Developer Network and individual contributors 2016c). </I></DD
></DL
><P 

>JavaScript Dateien, die das &bdquo;defer&ldquo; Attribut haben, werden gleich nach dem &bdquo;Interactive&ldquo;-Status ausgef&uuml;hrt und folglich das domContentLoaded Event verz&ouml;gern. Weil die Skripte gleich nach diesem Status ausgef&uuml;hrt werden, besteht noch die Gefahr, dass das CSSOM nicht fertig gebaut ist. Dies bedeutet, dass alle JavaScript Dateien, die ausgef&uuml;hrt werden m&uuml;ssen, auf die Fertig-stellung des CSSOMs warten m&uuml;ssen. JavaScript Dateien, die das &bdquo;async&ldquo; Attribut haben, wer-den nicht das domContentLoaded-Event verz&ouml;gern (Grigorik, 2012). </P
><H2 

><FONT size="+1">2.5. &bdquo;Resource Timing API&ldquo; </H2
><P 

><FONT size="+1">Die &bdquo;Navigation Timing API&ldquo; liefert die Messdaten f&uuml;r das ganze Dokument. Allerdings ist es oftmals f&uuml;r die komplette Analyse nicht ausreichend und es ist notwendig, um Messdaten f&uuml;r einzelne Ressourcen zu bekommen. Daf&uuml;r wurde die &bdquo;Resource Timing API&ldquo; entwickelt. Die &bdquo;Resource Timing API&ldquo; ist eine JavaScript API, die detaillierte Informationen &uuml;ber Webapplika-tionsressourcen, w&auml;hrend diese geladen werden, in Form von Zeitstempeln aus dem Netzwerk ausliest  (Abb. 5) (Mozilla Developer Network and individual contributors 2016h). </P
><P 

>Die Attribute der &bdquo;Resource Timing API&ldquo; liefern detaillierte Informationen zu Netzwerkevents wie Start- und Endzeiten von &bdquo;redirect&ldquo;, &bdquo;fetchStart&ldquo;, Start- und Endzeiten von DNS-Lookup oder Start- und Endzeiten von Request und Response. Au&szlig;erdem wurden zus&auml;tzliche Parame-ter unterst&uuml;tzt, die Informationen der einzelnen Dateien &uuml;ber den Typ, die Dateigr&ouml;&szlig;e, die &uuml;bertragene Dateigr&ouml;&szlig;e u.s.w. zur Verf&uuml;gung stellen (Mozilla Developer Network and indivi-dual contributors 2016h), (W3C 2016c). </P
><P 

> </P
><IMG width="367" height="265"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_5.jpg" ><DL 

><DD 

><I>Abb. 5:</I><I> </I><I>&bdquo;Resource Timing API&ldquo; (</I><I>&lt;</I><A href="https://www.w3.org/TR/resource-timing/">
<I>https://www.w3.org/TR/resource-timing/</I></A>
<I>&gt;). </I></DD
></DL
><P 

>Viele Entwicklertools von Browsern unterst&uuml;tzen sowohl die &bdquo;Navigation Timing API&ldquo;, als auch die &bdquo;Resource Timing API&ldquo; (Mozilla Developer Network and individual contributors 2016g). Da die Attribute, die die &bdquo;Resource Timing API&ldquo; beinhaltet, &auml;hnlich zu den Attributen der &bdquo;Naviga-tion Timing API&ldquo; sind (mit einem einzelnen Unterschied, n&auml;mlich dass die Zeitstempel im Fall der &bdquo;Resource Timing API&ldquo; zu einzelnen Ressourcen geh&ouml;ren), werden sie nicht noch Mal be-schrieben. Im Network Panel, das sich im Browser-Entwicklungstool befindet, befinden sich mehrere Parameter, die die &bdquo;Resource Timing API&ldquo; interpretiert. Das Zeitintervall von diesen Parametern liegt meistens im Millisekundenbereich. Die Anzahl dieser Parameter unterschei-den sich ein wenig je nach Webbrowser. F&uuml;r alle gilt: </P
><DL 

><DD 

>&#61630; DNS-Aufl&ouml;sung. </DD
></DL
><P 

>Stellt die ben&ouml;tigte Zeit f&uuml;r die DNS-Aufl&ouml;sung dar (Garbee 2016). </P
><DL 

><DD 

>&#61630; Verbindungsaufbau </DD
></DL
><P 

>Zeigt, wie lange der Verbindungsaufbau von TCP- und SSL-Roundtrips gebraucht hat (Garbee 2016). </P
><DL 

><DD 

>&#61630; Request Senden. </DD
></DL
><P 

>Zeigt, wie lange der Request zum Server gedauert hat. (Garbee 2016). </P
><DL 

><DD 

>&#61630; Warten. </DD
></DL
><P 

>Warten ist auch als &bdquo;Time To First Byte&ldquo; bekannt. Diese beinhaltet die Zeit f&uuml;r den Roundtrip zum Server und die serverseitige Wartezeit f&uuml;r die Requestsbearbeitung (Garbee 2016). </P
><DL 

><DD 

>&#61630; Herunterladen. </DD
></DL
><P 

>Beinhaltet die Zeit f&uuml;r den Empfang des Responses (Garbee 2016). </P
><P 

>(Microsoft 2016), (Apple 2016), (Mozilla Developer Network and individual contributors 2016i), (OPERA SOFTWARE ASA 2016), (Garbee 2016). </P
><H2 

><FONT size="+1">2.6. Zwischenfazit: Welche Parameter sind f&uuml;r die Untersuchung des kriti-schen Rendering &ndash; Pfades wichtig? </H2
><P 

><FONT size="+1">In dieser Masterarbeit wird der Fokus der Untersuchung auf der Dateiauslieferung und deren Art liegen. Dies bedeutet, dass in der Kette des kritischen Rendering &ndash; Pfades vor allem der Teil untersucht wird, der vor der Erstellung des Render &ndash; Baums liegt (Abb. 3). </P
><P 

>Um die Dateiauslieferung genauer zu pr&uuml;fen, sind viele Faktoren wichtig: wie schnell baut sich die Verbindung zum Server auf, wie schnell werden die wichtigsten Dateien f&uuml;r die Erstdarstel-lung zum Client geliefert und wie schnell werden sich CSSOM und DOM aufbauen. Diese Fak-toren beeinflussen die Zeit, die vergeht, bis die ersten Pixel im Viewport erscheinen werden und wie lange die Webapplikation ben&ouml;tigt, um alle dazugeh&ouml;rigen Ressourcen vom Server anzufragen und herunterzuladen. </P
><P 

>Um diese Faktoren pr&uuml;fen zu k&ouml;nnen, werden mehrere Parameter der aufgerufenen Webappli-kation gepr&uuml;ft. Daf&uuml;r werden sowohl die Parameter aus der &bdquo;Navigation Timing API&ldquo; f&uuml;r die komplette Seite der Webapplikation als auch die Parameter aus der &bdquo;Resource Timing API&ldquo; f&uuml;r einzelne Ressourcen verglichen. </P
><P 

>Interessante Parameter f&uuml;r diese Untersuchung sind:  </P
><DL 

><DD 

>&#61630; Zeit bis zum Aufbau der Verbindung zum Server (DNS-Lookup, TCP-Verbindung, SSL-Verbindung). </DD
><DD 

>&#61630; Wie viele Bytes der Browser f&uuml;r jede Anfrage zum Server ben&ouml;tigt hat. </DD
><DD 

>&#61630; &bdquo;RequestStart&ldquo;, um zu schauen, wann die Anfrage gestartet wurde. </DD
><DD 

>&#61630; &bdquo;Time To First Byte&ldquo;, um zu schauen, wieviel Zeit zwischen dem Aufruf der Datei bis zur Ausgabe der ersten Bytes dieser Datei an den Client vergeht. </DD
><DD 

>&#61630; &bdquo;domInteractive&ldquo;, um zu schauen, wieviel Zeit zwischen dem Aufruf der HTML Datei und der Fertigstellung des DOMs vergangen ist. </DD
><DD 

>&#61630; Zeitpunkt, an dem der Webbrowser anf&auml;ngt, etwas im Viewport zu zeichnen. </DD
><DD 

>&#61630; &bdquo;domComplete&ldquo;, um zu schauen, wie lange es gebraucht hat, bis alle zur Webapplika-tion geh&ouml;rigen Ressourcen heruntergeladen sind. </DD
></DL
><P 

>In der &bdquo;Navigation Timing API&ldquo; gibt es leider keine M&ouml;glichkeit, um zu beobachten, wann das CSSOM fertig ist. Man kann nur schauen, ab welchem Zeitpunkt im Viewport etwas gezeichnet wird und davon ausgehen, dass kurz zuvor das CSSOM fertig gestellt wurde. </P
><P 

>  </P
><H1 

><FONT size="+1">3. Die Probleme des HTTP/1.1 &ndash; Protokolls, das HTTP/2 &ndash; Protokoll und deren Optimierungsm&ouml;glichkeiten.  </H1
><H2 

><FONT size="+1">3.1. HTTP/1.1 &ndash; Optimierungstechniken, Stand bisher </H2
><P 

><FONT size="+1">Unter dem HTTP/1.1 &ndash; Protokoll wurden mehrere Frontend Performance &ndash; Optimierungstech-niken verwendet, die die Einschr&auml;nkungen dieses Protokolls versuchen aufzuheben (Grigorik 2013, 188). Diese sind meistens sogenannte &bdquo;Workarounds&ldquo;, weil manche von diesen Ma&szlig;nah-men f&uuml;r die Entwicklung einer Webapplikation unn&ouml;tig sind (Grigorik 2013, 188) und teilweise nicht erw&uuml;nschte Nebeneffekte mit sich bringen. Die meist verbreiteten davon sind: </P
><DL 

><DD 

>&#61630; Nutzung von mehreren TCP &ndash; Verbindungen. </DD
><DD 

>&#61630; Aufteilung von Ressourcen auf mehrere Domains (&bdquo;Domain Sharding&ldquo;). </DD
><DD 

>&#61630; Zusammenfassung von Ressourcen und &bdquo;Spriting&ldquo; von Bildern. </DD
><DD 

>&#61630; Erg&auml;nzung von Code in der HTML Datei (&bdquo;Ressource Inlining&ldquo;). </DD
></DL
><P 

>(Grigorik 2013, 188). </P
><P 

>Im Vergleich zum HTTP/1.0 &ndash; Protokoll sind im HTTP/1.1 &ndash; Protokoll mehrere n&uuml;tzliche Funkti-onen erschienen, die f&uuml;r die Performance einer Webapplikation sehr wichtig sind. Eine davon ist die Funktion &bdquo;Keepalive Connections&ldquo;, um mehrere Requests innerhalb einer TCP &ndash; Verbin-dung bearbeiten zu k&ouml;nnen (Grigorik 2013, 159-160). Der Aufbau jeder TCP &ndash; Verbindung be-ginnt wie immer mit dem &bdquo;Drei-Wege-Handschlag&ldquo;, aber dieser muss dank der Funktion &bdquo;Keepalive Connections&ldquo; nur einmal aufgebaut werden (Abb. 6) (Grigorik 2013, 189). </P
><P 

>Das HTTP/1.1 &ndash; Protokoll ist so aufgebaut, dass innerhalb einer TCP &ndash; Verbindung nur ein Re-quest oder Response innerhalb eines Zeitraums bearbeitet werden kann: zuerst wird der Re-quest an den Server verschickt, dann wird dieser bearbeitet und der Response wird zur&uuml;ckge-schickt. Danach wird der n&auml;chste Request von der clientseitigen Warteschlange abgeschickt. Aus diesem Grund ist die Bearbeitung von Requests und Responses nicht wirklich parallel. Al-lerdings wurde im HTTP/1.1 &ndash; Protokoll die Funktion &bdquo;HTTP Pipelining&ldquo; hinzugef&uuml;gt, die die eben genannte Warteschlange vom Client zum Server verschiebt. Damit werden nicht die Re-quests am Client warten, sondern die Responses werden am Server in die Warteschlange ge-stellt. Wenn man die &uuml;bliche Bearbeitungsweise ohne die Funktion &bdquo;HTTP Pipelining&ldquo; betrach-tet, sieht man, dass auf der Serverseite zwischen dem Versand eines Responses vom Server und der Ankunft des n&auml;chsten Requests vom Client nichts gemacht wird (Abb. 6). </P
><P 

> </P
><IMG width="389" height="330"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_6.jpg" ><DL 

><DD 

><I>Abb. 6:</I><I> </I><I>&Uuml;bliche Verarbeitungsweise der Requests und Responses innerhalb einer TCP </I><I>&ndash;</I><I> Verbin-dung mit der F</I><I>unktion &bdquo;Keepalive Connections&ldquo;</I><I> (Grigorik 2013, 191). </I></DD
></DL
><P 

>Mithilfe der Funktion &bdquo;HTTP Pipelining&ldquo; wird diese Zeit effizienter genutzt, wenn mehrere An-fragen an den Server gleichzeitig geschickt werden und der Server entsprechende Responses nacheinander liefern wird (Abb. 7). Dadurch wird zus&auml;tzlicher &bdquo;Roundtrip&ldquo; zwischen den Re-quests gespart (Grigorik 2013, 193). </P
><P 

> </P
><IMG width="418" height="284"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_7.jpg" ><DL 

><DD 

><I>Abb. 7:</I><I> </I><I>Verarbeitungsweise der Requests und Responses innerhalb einer TCP </I><I>&ndash;</I><I> Verbindung mit </I><I>den Funktionen &bdquo;Keepalive Connections&ldquo; und &bdquo;HTTP Pipelining&ldquo; </I><I>(Grigorik 2013, 193). </I></DD
></DL
><P 

>  </P
><P 

>Die Funktion &bdquo;HTTP Pipelining&ldquo; hebt die Einschr&auml;nkungen des HTTP/1.1 &ndash; Protokolls leider nicht v&ouml;llig auf: die Responses werden innerhalb einer TCP &ndash; Verbindung nacheinander gelie-fert. Bevor nicht alle Bytes des zuvor gesendeten Responses den Client erreichen werden, wird kein neuer Response vom Server gesendet. Es gibt keine M&ouml;glichkeit, um die Responses w&auml;h-rend der Lieferung miteinander zu multiplexieren (Grigorik 2013, 194). Au&szlig;erdem hat diese Funktion nicht nur Vorteile: wenn HTML und CSS Dateien gleichzeitig am Server bearbeitet werden und die CSS Datei schneller zur Verf&uuml;gung stehen wird, muss diese trotzdem warten, bis die HTML Datei am Client zugestellt wird. Dies ist als &bdquo;Head-Of-Line Blocking&ldquo; &ndash; Problem bekannt und verursacht ein schlechtes Szenario: die Lieferung der Dateien wird deutlich verz&ouml;-gert, wenn die Bearbeitung fr&uuml;her gesendeter Requests zu lange braucht und der Server ver-braucht seinen Puffer, wodurch er &uuml;berlastet werden kann. Au&szlig;erdem werden TCP &ndash; Pakete eines Responses, wenn sie verloren gehen, erneut versendet. Dadurch kann die Verarbeitungs-zeit der Gesamtlieferung verdoppelt werden (Grigorik 2013, 195). </P
><P 

>Noch ein Problem der Funktion &bdquo;HTTP Pipelining&ldquo; besteht darin, dass die meisten Browser diese nicht unterst&uuml;tzen (Grigorik 2013, 195), (Wikipedia 2015). </P
><P 

>Aus oben genannten Gr&uuml;nden wird die Funktion &bdquo;HTTP Pipelining&ldquo; als Performance &ndash; Optimie-rungstechnik f&uuml;r das HTTP/1.1 &ndash; Protokoll nicht mitgez&auml;hlt (Grigorik 2013, 195). </P
><H3 

><FONT size="+1">3.1.1. Nutzung von mehreren TCP &ndash; Verbindungen </H3
><P 

><FONT size="+1">Innerhalb des HTTP/1.1 &ndash; Protokolls wurde die Funktion &bdquo;Keepalive Connections&ldquo; hinzugef&uuml;gt. Dies macht die Webapplikationen viel perfomanter, als noch unter dem HTTP/1.0 &ndash; Protokoll (Grigorik 2013, 187). Allerdings ist die Verwendung von nur einer TCP &ndash; Verbindung oftmals nicht gen&uuml;gend, weil dies zu langsam ist. Aus diesem Grund wurde sowohl client- als auch serverseitig erlaubt, mehrere TCP &ndash; Verbindungen per Hostname innerhalb einer Sitzung pa-rallel zu unterst&uuml;tzen (Grigorik 2013, 196). Die genaue Anzahl unterscheidet sich je nach Brow-ser- und Serverimplementierung. In der Standardkonfiguration sind bis zu sechs parallele TCP &ndash; Verbindungen erlaubt (Grigorik 2013, 196). Durch mehrere gleichzeitig ge&ouml;ffnete TCP &ndash; Verbindungen wird die Ladezeit der Webapplikation deutlich verringert. Dabei spielt auch die Funktion des TCP &ndash; Protokolls &bdquo;Slow Start&ldquo; eine nicht so gro&szlig;e Rolle (siehe unten die genauere Beschreibung des TCP &ndash; Protokolls) (Grigorik 2013, 196).  </P
><P 

>Andererseits zieht die Parallelisierung von Responses einige Schwierigkeiten mit sich. Obwohl die Ressourcen parallel heruntergeladen werden k&ouml;nnen, teilen alle ge&ouml;ffneten TCP &ndash; Verbin-dungen eine Bandbreite. Au&szlig;erdem werden mehr Puffer- als auch CPU- Kapazit&auml;ten auf beiden Seiten der Kommunikation verbraucht, je mehr Verbindungen ge&ouml;ffnet werden. Die Nutzung von mehreren TCP &ndash; Verbindungen ist eine Art, um die Requests und Responses zu paralleli-sieren, aber diese bleibt letztlich nur ein &bdquo;Workaround&ldquo; auf Grund der Einschr&auml;nkungen des HTTP/1.1 &ndash; Protokolls (Grigorik 2013, 197). </P
><P 

><I>  </I></P
><P 

><I>Funktionsweise des TCP </I><I>&ndash;</I><I> Protokolls </I></P
><P 

>Innerhalb des TCP &ndash; Protokolls werden Dateneinheiten zwischen Sender und Empf&auml;nger aus-getauscht, die als &bdquo;TCP &ndash; Segmente&ldquo; bezeichnet werden. Jedes &bdquo;TCP &ndash; Segment&ldquo; beinhaltet ei-nen mind. 20 Byte gro&szlig;en Protokollkopf (&bdquo;TCP &ndash; Header&ldquo;) und die zu &uuml;bertragenden Daten. Der &bdquo;TCP &ndash; Header&ldquo; besteht aus mehreren Feldern (Holtkamp 2001). </P
><P 

>Eines der wichtigsten davon ist das &bdquo;Window &ndash; Feld&ldquo;, das f&uuml;r die Flusssteuerung (&bdquo;Flow Con-trol&ldquo;) verantwortlich ist. Dieses Feld ist wichtig, weil dieses die Anzahl von Bytes beinhaltet, die beim Empf&auml;nger ab dem ersten best&auml;tigten Byte aufgenommen werden k&ouml;nnen. Mit dieser Mitteilung der Fenstergr&ouml;&szlig;e kann das TCP &ndash; Protokoll die Flusssteuerung (&bdquo;Flow Control&ldquo;) fort-setzen. Das TCP &ndash; Protokoll funktioniert nach der Methode &bdquo;Sliding Window&ldquo; mit variabler Gr&ouml;&szlig;e. Damit kann jede Seite der Kommunikation so viele Bytes senden, wie bei der Fenster-gr&ouml;&szlig;e angegeben sind. Dadurch entsteht beim Empf&auml;nger keine Warteschlange an Daten (Holtkamp 2001). </P
><P 

>Innerhalb jeder TCP &ndash; Verbindung verf&uuml;gt das TCP &ndash; Protokoll &uuml;ber den &bdquo;cwnd&ldquo; Algorithmus (&bdquo;Congestion window size&ldquo;), der die Anzahl von TCP &ndash; Segmenten kontrolliert, die zwischen dem Sender und dem Empf&auml;nger ausgetauscht werden k&ouml;nnen. &bdquo;Cwnd&ldquo; wird serverseitig die Daten zum Senden begrenzen, bevor ihn nicht die Antwort vom Empf&auml;nger erreichen wird, dass die Daten erfolgreich zugestellt wurden (Grigorik 2013, 19). &bdquo;Cwnd&ldquo; funktioniert &auml;hnlich wie der Mechanismus der Flusssteuerung (&bdquo;Flow Control&ldquo;) und ist daf&uuml;r da, um den Traffic unter Kontrolle zu halten (Wikipedia 2016d). </P
><P 

>Weder Client noch Server kennen die Bandbreite der gerade ge&ouml;ffneten TCP &ndash; Verbindung. Aus diesem Grund wird ein Mechanismus gebraucht, um die Flusssteuerung w&auml;hrend einer bestehenden TCP &ndash;Verbindung zu kontrollieren (Grigorik 2013, 19). Mithilfe der TCP &ndash; Funktion &bdquo;Slow &ndash; Start&ldquo; kann w&auml;hrend der bestehenden TCP &ndash; Verbindung der &bdquo;cwnd&ldquo; Algorithmus ge-steuert werden. Sobald die Verbindung aufgebaut wird, wird &bdquo;cwnd&ldquo; auf &bdquo;Maximum Segment Size&ldquo; gesetzt. Wenn mit dieser gesetzten Gr&ouml;&szlig;e alle TCP &ndash; Pakete den Empf&auml;nger erfolgreich erreichen werden, wird &bdquo;cwnd&ldquo; f&uuml;r die n&auml;chste &bdquo;Round-Trip Time&ldquo; verdoppelt werden. Wenn die TCP &ndash; Pakete innerhalb der Verbindung dagegen verloren gehen, wird &bdquo;cwnd&ldquo; verringert (Abb. 8) (Wikipedia 2016d), (Grigorik 2013, 20). Je kleiner also die Transaktionen zwischen Cli-ent und Server sind, desto sicherer wird es, dass die Daten schneller vollst&auml;ndig den Client erreichen werden (Grigorik 2013, 34). Aus diesem Grund kann man sagen, dass, je kleiner Res-sourcen gehalten werden, desto schneller werden diese am Client ankommen. </P
><P 

>F&uuml;r TCP &bdquo;Slow Start&ldquo; wurde im April 2013 die &bdquo;cwnd&ldquo; &ndash; Startgr&ouml;&szlig;e von 10 &bdquo;TCP &ndash; Segmenten&ldquo; vom &bdquo;RFC 6928&ldquo; festgelegt (Grigorik 2013, 20). </P
><P 

> </P
><IMG width="491" height="214"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_8.jpg" ><DL 

><DD 

><I>Abb. 8:</I><I> </I><I>Datenaustauschkontrolle der TCP </I><I>&ndash;</I><I> </I><I>Verbindung, Funktionsweise des &bdquo;Slow</I><I> </I><I>&ndash;</I><I> </I><I>Start&ldquo;</I><I> (Gri-gorik 2013, 20). </I></DD
></DL
><P 

>Aus der oben beschriebenen Funktionsweise des TCP &ndash; Protokolls kann man sagen, dass die Funktion &bdquo;Slow &ndash; Start&ldquo; eine wichtige Rolle bei der Performance der Webapplikation spielt. Das HTTP &ndash; Protokoll l&auml;uft &uuml;ber das TCP &ndash; Protokoll und unabh&auml;ngig von der Gr&ouml;&szlig;e der Bandbreite, startet jede TCP &ndash; Verbindung mit &bdquo;Slow &ndash; Start&ldquo;. Aus diesem Grund ist es wichtig, um am An-fang die &bdquo;cwnd&ldquo; &ndash; Startgr&ouml;&szlig;e auf 10 &bdquo;TCP &ndash; Segmenten&ldquo; zu halten (Grigorik 2013, 20, 22). </P
><H3 

><FONT size="+1">3.1.2. Aufteilung von Ressourcen auf mehrere Domains (&bdquo;Domain Sharding&ldquo;) </H3
><P 

><FONT size="+1">Die Anzahl von parallel laufenden TCP &ndash; Verbindungen per Hostname innerhalb des HTTP/1.1 &ndash; Protokolls wird vom Client bestimmt (unter der Bedingung, dass die Serverimple-mentierung diese auch unterst&uuml;tzt). Normalerweise werden bis zu sechs parallele TCP &ndash; Ver-bindungen ge&ouml;ffnet. In manchen Situationen (wenn die Webapplikation &uuml;ber viele Ressourcen verf&uuml;gt) kann aber diese begrenzte Anzahl von Verbindungen zu wenig sein (Grigorik 2013, 198-199). </P
><P 

>Aus diesem Grund entstand noch ein &bdquo;Workaround&ldquo;:  Aufteilung von Ressourcen auf mehrere Domains, um eine noch gr&ouml;&szlig;ere Parallelisierung zu bekommen. Die Ressourcen k&ouml;nnen auf unterschiedliche Subdomains aufgeteilt werden, wie z.B.: {shard1, shard2}.example.com (Gri-gorik 2013, 198). Mithilfe dieser Technik erscheint es m&ouml;glich, dass die Ressourcen schneller geladen werden. </P
><P 

>Allerdings ist zu beachten, dass der Verbindungsaufbau zu jeder neuen Domain gleichfalls den  Aufbau von DNS &ndash; Lookup erfordert. Dies kann je nach Situation viel Zeit kosten. Diese Opti-mierungstechnik im Zusammenhang mit der Funktion des TCP &ndash; Protokolls &bdquo;Slow Start&ldquo; kann negative Auswirkungen bei Nutzung von mobilen Netzwerken (3G und 4G) haben. Au&szlig;erdem muss w&auml;hrend der Entwicklung der Webapplikation genau beachtet werden, wie die Ressour-cen aufgeteilt werden (Grigorik 2013, 199-200). </P
><H3 

><FONT size="+1">3.1.3. Zusammenfassung von Ressourcen und &bdquo;Spriting&ldquo; von Bildern </H3
><P 

><FONT size="+1">Der schnellste Request ist derjenige Request, der nicht gemacht wird. Die Reduzierung der Anzahl der gemachten Requests ist die beste Performance &ndash; Optimierungstechnik. Diese Regel gilt f&uuml;r alle HTTP &ndash; Protokolle, unabh&auml;ngig von deren Version. Besonders wenn die Ressourcen innerhalb einer TCP &ndash; Verbindung unter dem HTTP/1.1 &ndash; Protokoll nacheinander geliefert wer-den, und sechs TCP &ndash; Verbindungen ge&ouml;ffnet werden k&ouml;nnen, ist die Reduzierung von Anfra-gen eine gute Optimierungstechnik. Aus diesem Grund wird noch eine Performance &ndash; Opti-mierungstechnik f&uuml;r das HTTP/1.1  Protokoll angewendet: mehrere Ressourcen eines Typs wer-den zusammengefasst (Grigorik 2013, 196, 201). </P
><P 

>Diese Technik betrifft vor allem CSS und JavaScript Dateien, sowie Bilder. Sowohl JavaScript Code als auch CSS &ndash; Regeln kann man problemlos zusammenfassen. Auch mehrere Bilder las-sen sich als ein gr&ouml;&szlig;eres Bild zusammenbinden.  </P
><P 

>Es gibt ein paar Vorteile dieser Technik: </P
><DL 

><DD 

>&#61630; Bestehende Netzwerklatenz wird reduziert, weil weniger Requests und Responses zwi-schen Client und Server ausgetauscht werden. </DD
><DD 

>&#61630; Je weniger nicht komprimierte HTTP &ndash; Kopfzeilen (Headers) ausgetauscht werden, desto mehr ausgetauschte Bytes werden gespart. HTTP &ndash; Kopfzeilen werden w&auml;hrend dem Transport unter dem HTTP/1.1 &ndash; Protokoll nicht komprimiert. </DD
></DL
><P 

>(Grigorik 2013, 202). </P
><P 

>Allerdings, wie alle bestehenden &bdquo;Workarounds&ldquo; f&uuml;r die Performance &ndash; Optimierung f&uuml;r das HTTP/1.1 &ndash; Protokoll Nachteile haben, hat auch diese oben beschriebene Technik Nachteile. Zuerst m&uuml;ssen die Entwickler eine zus&auml;tzliche Ma&szlig;nahme unternehmen, um entwickelte Appli-kationsmodule zusammenzufassen. Im Fall von &bdquo;Sprites&ldquo; (Zusammenfassung von mehreren Bil-dern) muss man oft zus&auml;tzliche CSS &ndash; Regeln schreiben. Diese Technik wird dann gebraucht, wenn z.B. beim &bdquo;Hover&ldquo; auf ein bestimmtes Bild ein Ereignis passieren soll. Da alle Bilder in ein gro&szlig;es Bild zusammengefasst sind, muss man diese k&uuml;nstlich wieder aufteilen. Dies braucht zus&auml;tzliche Zeit f&uuml;r die Entwicklung der Webapplikation (Grigorik 2013, 202). </P
><P 

>Es gibt noch weitere wichtige Nachteile bei der Zusammenfassung von Ressourcen. Alle ge-bundenen Ressourcen werden eine gemeinsame URL haben. Dadurch wird es unm&ouml;glich, um einzelne Dateien zu cachen. Deshalb wird die Ressource nicht mehr vom Cache aufgerufen und muss neu geladen werden, wenn nur eine Kleinigkeit innerhalb der Datei der zusammenge-fassten Ressourcen durchgef&uuml;hrt wird (Grigorik 2013, 202). </P
><P 

>Au&szlig;erdem m&uuml;ssen alle dazugeh&ouml;rigen Ressourcen geladen werden, wenn nur eine der zusam-mengefassten Ressourcen auf einer konkreten Internetseite gebraucht wird.  </P
><P 

>Hinzu kommt auch, dass gr&ouml;&szlig;ere Dateien unter dem HTTP/1.1 &ndash; Protokoll deutlich sp&auml;ter ge-laden werden. Dadurch werden alle anderen Ressourcen blockiert (Grigorik 2013, 202). </P
><P 

>Der letzte wichtige Nachteil dieser Performance &ndash; Optimierungstechnik betrifft die zusammen-gefassten Bilder (&bdquo;Sprites&ldquo;). Wenn von dem gro&szlig;en Bild, das durch Zusammenfassung entstan-den ist, nur ein kleiner Bereich auf der Seite angezeigt wird, muss das komplette Bild trotzdem im RAM des Browsers gehalten werden. Besonders stark sind mobile Endger&auml;te davon betrof-fen (Grigorik 2013, 203). </P
><H3 

><FONT size="+1">3.1.4. Erg&auml;nzung des Codes in der HTML Datei (&bdquo;Ressource Inlining&ldquo;) </H3
><P 

><FONT size="+1">Requests unter dem HTTP/1.1 &ndash; Protokoll k&ouml;nnen viel Zeit in Anspruch nehmen (Grigorik 2013, 202). Aus diesem Grund k&ouml;nnen Ressourcen direkt in der HTML Datei hinzugef&uuml;gt werden. Dies betrifft fast alle Ressourcentypen: CSS, JavaScript, Bilder, Audio und PDF. Die drei letzten Res-sourcentypen k&ouml;nnen durch &bdquo;Data &ndash; URI&ldquo; hinzugef&uuml;gt werden (Grigorik 2013, 204).  </P
><P 

>&bdquo;Data &ndash; URI&ldquo; ist ein &bdquo;URI &ndash; Schema&ldquo;, mithilfe dessen die Daten dem Quelltext hinzugef&uuml;gt wer-den k&ouml;nnen (Wikipedia 2016e). &bdquo;Data &ndash; URI&ldquo; benutzt das &bdquo;base64&ldquo; &ndash; Kodierungsschema, das f&uuml;r die Einbettung von bin&auml;ren Dateien gedacht war (McLachlan 2013). Deshalb ist es m&ouml;glich, um bin&auml;re Dateien direkt in den HTML, CSS und JavaScript Dateien einzubetten. Das Bild wird dazu in einen &bdquo;Base64 &ndash; String&ldquo; konvertiert (Kuhn/Raith 2013, 205).  </P
><P 

>Der Vorteil von &bdquo;Data &ndash; URI&ldquo; besteht darin, dass kein zus&auml;tzlicher Request ben&ouml;tigt wird. Nach McLachlan 2013 z&auml;hlen zu den Nachteilen: </P
><DL 

><DD 

>&#61630; &bdquo;Data &ndash; URIs&ldquo; k&ouml;nnen nicht separat von dem Dokument (HTML, JavaScript oder CSS) gecacht werden, sie werden immer neu geladen. </DD
><DD 

>&#61630; Der Browser ben&ouml;tigt mehr Zeit, um den &bdquo;base64&ldquo; &ndash; Code zu dekodieren. </DD
><DD 

>&#61630; In den mobilen Endger&auml;ten ist die Bearbeitung von &bdquo;Data &ndash; URIs&ldquo; bis zu 6 Mal langsa-mer. </DD
></DL
><P 

>Au&szlig;erdem sind &bdquo;base64&ldquo; &ndash; kodierte Daten 1/3 gr&ouml;&szlig;er als ihre bin&auml;ren &Auml;quivalente (Grigorik 2013, 205). </P
><P 

>Aus oben genannten Gr&uuml;nden kann man sagen, dass &bdquo;Data &ndash; URIs&ldquo; nicht immer vorteilhaft sind. Data &ndash; URI&ldquo; kann aber f&uuml;r die Erg&auml;nzung kleinerer bin&auml;ren Ressourcen n&uuml;tzlich werden (Grigo-rik 2013, 204). </P
><P 

>Alle Textbasierten Ressourcen wie CSS und JavaScript k&ouml;nnen in der HTML &ndash; Datei hinzugef&uuml;gt werden. Dadurch wird die Netzwerklatenz durch Reduzierung von Requests verbessert (Grigo-rik 2013, 205). Dies kann auch dann praktisch sein, wenn Ressourcen f&uuml;r die Erstdarstellung wichtig sind. </P
><P 

>Aber es existieren auch f&uuml;r diese Webperformance &ndash; Technik mehrere Nachteile. Wenn die Res-sourcen hinzugef&uuml;gt werden, wird keine M&ouml;glichkeit mehr bestehen, um diese individuell dem </P
><P 

>Browsercache zu &uuml;bergeben. Auch besteht die Gefahr, dass hinzugef&uuml;gte Ressourcen auf un-terschiedlichen Seiten benutzt werden, auch wenn diese dort nicht n&ouml;tig sind. Die Gr&ouml;&szlig;e der HTML Datei wird dadurch auch zunehmen (Grigorik 2013, 205). </P
><H2 

><FONT size="+1">3.2. &bdquo;Evergreen&ldquo; Frontend &ndash; Optimierungsm&ouml;glichkeiten </H2
><P 

><FONT size="+1">Unabh&auml;ngig davon, welche Version des Netzwerkprotokolls verwendet wird, m&uuml;ssen alle Webapplikationen nach einer Reduzierung unn&ouml;tiger Netzwerklatenz und der Verringerung von transportierten Bytes streben. Diese beiden Kriterien geh&ouml;ren zu den &bdquo;Best Practices&ldquo; der Webperformance und sind Basis f&uuml;r viele weitere Optimierungen. Die wichtigsten Regeln dabei sind: </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Reduzierung von DNS &ndash; Lookups und Domainweiterleitungen. </DD
></DL
></DL
></DL
><P 

>Jede Aufl&ouml;sung des Hostnamens braucht einen &bdquo;Roundtrip&ldquo; aus dem Netzwerk, bis die IP &ndash; Adresse des dazugeh&ouml;rigen Hostnamens ermittelt wird (Grigorik 2013, 199-200). Dies passiert, bevor der erste Request zum Server geschickt werden kann. Je mehr Do-mains f&uuml;r das vollst&auml;ndige Laden der Webapplikation ben&ouml;tigt werden, desto gr&ouml;&szlig;er ist die Verz&ouml;gerung zum Herunterladen der Ressourcen. Dies betrifft auch die Domain-weiterleitungen (Grigorik 2013, 235). </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Wiederverwendung aufgebauter TCP &ndash; Verbindungen. </DD
></DL
></DL
></DL
><P 

>Da der Aufbau jeder TCP &ndash; Verbindung mit dem &bdquo;Drei-Wege-Handschlag&ldquo; beginnt und das TCP &ndash; Protokoll am Anfang nur eine geringere Anzahl von TCP &ndash; Segmenten er-laubt, sollten aufgebaute TCP &ndash; Verbindungen wieder verwendet werden (Grigorik 2013, 19), (Grigorik 2013, 235). </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Verwendung des CDNs (Content Delivery Network). </DD
></DL
></DL
></DL
><P 

>Je n&auml;her sich die Clients geographisch zum Server befinden, von dem die Ressourcen heruntergeladen werden, desto schneller wird die Webapplikation geladen. Der we-sentliche Grund daf&uuml;r ist, dass die Verbindungsaufbauzeit zum Server deutlich verrin-gert werden kann. CDNs k&ouml;nnen sowohl f&uuml;r statischen als auch f&uuml;r dynamischen Con-tent benutzt werden (Grigorik 2013, 235). </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Reduzierung von unn&ouml;tigen Ressourcen. </DD
></DL
></DL
></DL
><P 

>Je weniger Requests benutzt werden, desto schneller wird die Webapplikation geladen (Grigorik 2013, 235). </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Nutzung des Browser-Cachings. </DD
></DL
></DL
></DL
><P 

>Damit die Ressourcen nicht bei jedem Aufruf der Webapplikation immer wieder neu geladen werden, m&uuml;ssen diese die F&auml;higkeit haben, um einige Zeit im Cache des Brow-sers zu bleiben (Grigorik 2013, 236). </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Datenkompression w&auml;hrend des Transports. </DD
></DL
></DL
></DL
><P 

>Ressourcen der Webapplikation m&uuml;ssen mit minimaler Anzahl von Bytes transportiert werden. Aus diesem Grund muss eine Kompressionsmethode w&auml;hrend des Datentrans-ports angewendet werden (z.B. &bdquo;Gzip&ldquo;) (Grigorik 2013, 236-237). </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Reduzierung der Datenmenge der Ressourcen. </DD
></DL
></DL
></DL
><P 

>Die Datenmenge f&uuml;r die Webapplikation kann durch Reduzierung unn&ouml;tiger Informati-onen verringert werden. Es gibt unterschiedliche Reduzierungstechniken, die f&uuml;r unter-schiedliche Ressourcentypen angewendet werden k&ouml;nnen (Kuhn/Raith 2013, 218). </P
><DL 

><DL 

><DL 

><DD 

>&#61630; Verwendung protokollspezifischer Performance &ndash; Optimierungstechniken (Grigorik 2013, 236). </DD
></DL
></DL
></DL
><P 

>Die Funktionsweisen der verschiedenen Versionen des HTTP &ndash; Protokolls unterscheiden sich sehr. Aus diesem Grund muss genau beachtet werden, welche Performance &ndash; Optimierungs-techniken f&uuml;r welches HTTP &ndash; Protokoll geeignet sein k&ouml;nnen (Grigorik 2013, 236). Manche der oben beschriebenen Techniken, die sich unabh&auml;ngig von der Version des HTTP &ndash; Protokolls anwenden lassen, werden im Folgenden genauer dargestellt. </P
><H3 

><FONT size="+1">3.2.1. Browser Caching f&uuml;r statische Ressourcen </H3
><P 

><FONT size="+1">Um zus&auml;tzliche Bytes w&auml;hrend des Transports sparen zu k&ouml;nnen, kann der Cache des Browsers verwendet werden. Die Caching &ndash; Anweisungen werden durch Metainformationen im HTTP &ndash; Header der HTTP &ndash; Nachricht &uuml;bertragen. Dadurch werden die betroffenen Daten &uuml;ber l&auml;ngere Zeit im Cache des Browsers gespeichert. Es gibt mehrere M&ouml;glichkeiten, mithilfe derer die Caching &ndash; Anweisungen dem Client mitgeteilt werden k&ouml;nnen (Kuhn/Raith 2013, 168). </P
><P 

>Die erste M&ouml;glichkeit ist der Einsatz von &bdquo;Expires &ndash; Header&ldquo;. Dazu m&uuml;ssen die HTTP &ndash; Header der einzelnen Responses ein &bdquo;Verfallsdatum&ldquo; beinhalten. Danach wird der Browser dieses &bdquo;Ver-fallsdatum&ldquo; interpretieren und mit der dazugeh&ouml;rigen Datei bis zum angegebenen Zeitpunkt speichern. &bdquo;Expires &ndash; Header&ldquo; sind Caching &ndash; Anweisungen, die f&uuml;r jede Response angewendet werden k&ouml;nnen. Die Dateien werden im Browser Cache so lange gehalten, bis das &bdquo;Verfallsda-tum&ldquo; erreicht wird. Um die &bdquo;Expires &ndash; Header&ldquo; nutzen zu k&ouml;nnen, m&uuml;ssen diese Serverseitig aktiviert und je nach Ressourcentyp konfiguriert werden (Kuhn/Raith 2013, 168). </P
><P 

>Der Nachteil von &bdquo;Expires &ndash; Headern&ldquo; besteht darin, dass diese sich mit einer &Auml;nderung der Datei nicht dynamisch anpassen werden. Dies bedeutet, dass die Datei so lange vom Browser Cache aufgerufen wird, bis das &bdquo;Verfallsdatum&ldquo; erreicht ist, auch dann wenn die Datei server-seitig aktualisiert wurde (Kuhn/Raith 2013, 170). </P
><P 

>Eine zweite M&ouml;glichkeit ist es, um die sog. &bdquo;Etags&ldquo; zu benutzen. Diese Technologie ist den &bdquo;Expires &ndash; Headern&ldquo; &auml;hnlich, aber hier werden die HTTP &ndash; Header des Responses mit einem &bdquo;Etag&ldquo; markiert. Ein &bdquo;Etag&ldquo; wird im Request vom Browser mithilfe von<I> </I><I>&bdquo;If</I><I>-None-</I><I>Match: (Etag).&ldquo; </I>gesetzt. Am Server wird ein neuer &bdquo;Etag&ldquo; f&uuml;r die angeforderte Datei erzeugt und dieser wird mit dem vom Client gesendeten &bdquo;Etag&ldquo; verglichen. Wenn beide &bdquo;Etags&ldquo; nicht identisch sind, bedeutet es, dass der Client eine &auml;ltere Version der Datei hat. In diesem Fall wird der Server eine neue Version der angefragten Ressource schicken. Wenn die &bdquo;Etags&ldquo; identisch sind, wird der Webserver mit dem Statuscode &bdquo;304 &ndash; Not Modified&ldquo; antworten und keine Inhalte zur&uuml;ck-liefern (Kuhn/Raith 2013, 171). </P
><P 

>Der Vorteil von &bdquo;Etags&ldquo; im Vergleich zu &bdquo;Expires &ndash; Headern&ldquo; besteht darin, dass Datei&auml;nderun-gen erkannt werden. Jedoch werden in diesem Fall keine Requests gespart. Die &bdquo;Etags&ldquo; sind in einigen Webservern z.B. Apache2 (Apache Software Foundation 2016d) und Lighttpd (Lighttpd 2016) in der Standardkonfiguration aktiviert (Kuhn/Raith 2013, 171). </P
><P 

>Eine dritte M&ouml;glichkeit sind die &bdquo;Cache &ndash; Buster&ldquo;. Diese Technologie wird entweder durch die Erg&auml;nzung von Parametern an den Dateinamen oder durch die Ver&auml;nderung des Dateipfades realisiert. Der Browser identifiziert die zwischengespeicherte Datei mithilfe des dazugeh&ouml;rigen Dateipfads. Wenn dieser mithilfe von zus&auml;tzlich angeh&auml;ngten Parametern an den Dateinamen (z.B wird aus &bdquo;ressourcen/code.js&ldquo; &bdquo;ressourcen/ code.js?v=2&ldquo;) ge&auml;ndert wird, wird die Ressource als neu betrachtet und neu geladen (Kuhn/Raith 2013, 173). </P
><P 

>Der Nachteil der oben beschriebenen Technologie liegt darin, dass durch den Proxyserver diese Erg&auml;nzungen abgeschnitten und verworfen werden k&ouml;nnen. Dadurch wird die Anfrage nicht mehr korrekt sein (Kuhn/Raith 2013, 173). </P
><P 

>Die zweite Variante des &bdquo;Cache &ndash; Buster&ldquo; besteht in der &Auml;nderung des kompletten Dateipfades, der automatisch umgeschrieben wird. Z.B. kann der Pfad anstatt der urspr&uuml;nglichen Anfrage &bdquo;ressourcen/code.js&ldquo; dann &bdquo;ressourcen/123/code.js&ldquo; lauten. Diese automatische Umschreibung kann auf der Serverseite mithilfe von &bdquo;Rewrite&ldquo; &ndash; Regeln realisiert werden (Kuhn/Raith 2013, 173). </P
><H3 

><FONT size="+1">3.2.2. Datenkompression w&auml;hrend des Transports </H3
><P 

><FONT size="+1">Die &bdquo;Gzip&ldquo; &ndash; Kompression erm&ouml;glicht es, Daten w&auml;hrend des Transports vom Server zum Client zu komprimieren. Bei den quelltext-basierten Ressourcen, wie HTML, CSS, JavaScript u.s.w. k&ouml;n-nen mithilfe der &bdquo;Gzip&ldquo; &ndash; Kompression w&auml;hrend des Transports etwa 60-80% der Datenmenge gespart werden (Grigorik 2013, 237). Bei schon komprimierten Formaten (JPG, MP3 u.s.w) ist eine zus&auml;tzliche &bdquo;Gzip&ldquo; &ndash; Kompression nutzlos (Wikipedia 2016f). Wenn die &bdquo;Gzip&ldquo; &ndash; Kompres-sion aktiviert ist, k&ouml;nnen vom Server gesendete <FONT color="#242424">Nachrichtenr&uuml;mpfe (HTTP &ndash; <FONT color="#000000">Body) komprimiert werden. HTTP &ndash; Header werden innerhalb des HTTP/1.1 &ndash; Protokolls nicht komprimiert. Um die  &bdquo;Gzip&ldquo; &ndash; Kompression verwenden zu k&ouml;nnen, muss der Webserver entsprechend konfiguriert werden (Kuhn/Raith 2013, 211). </P
><P 

>F&uuml;r bin&auml;re Daten (z.B. Bilder) wird eine andere Kompressionstaktik angewendet. Sp&auml;ter wird noch beschrieben, wie man Quelltext-basierte Ressourcen minimieren kann. </P
><H3 

><FONT size="+1">3.2.3. Reduzierung der Datenmenge der Ressourcen </H3
><P 

><FONT size="+1">Die Datengr&ouml;&szlig;e der quelltextbasierten Daten kann mithilfe von Minimierungen reduziert wer-den. Textbasierte Quellcodes wie z.B. HTML, JavaScript oder CSS Dateien verf&uuml;gen oftmals &uuml;ber Tabulatoren, Kommentare, Zeilenumbr&uuml;che u.s.w. Diese sind f&uuml;r die Maschinenverarbeitung nicht wichtig und k&ouml;nnen entfernt werden, weil diese die Dateigr&ouml;&szlig;e erh&ouml;hen. Au&szlig;erdem gibt es datenspezifische Minimierungstechniken, die je nach Ressourcentyp angewendet werden </P
><P 

>k&ouml;nnen. Z.B. gibt innerhalb der HTML Datei &bdquo;Tags&ldquo;, die kein schlie&szlig;endes &bdquo;Tag&ldquo; ben&ouml;tigen. Wenn diese entfernt werden, wird weniger Bandbreite f&uuml;r die Datei&uuml;bertragung ben&ouml;tigt (Kuhn/Raith 2013, 215). </P
><P 

>Es gibt noch weitere datenspezifische Minimierungstechniken. Innerhalb des JavaScript Codes k&ouml;nnen die Variablen- und Methodennamen verk&uuml;rzt werden. So entstehen z.B. anstatt Funk-tionsnamen wie &bdquo;function1&ldquo; einfach Namen wie &bdquo;f&ldquo;. Die meisten JavaScript-Bibliotheken verf&uuml;-gen &uuml;ber bereits minimierte Versionen des Quellcodes. Diese haben am Dateinamen den An-hang &bdquo;min&ldquo; (Kuhn/Raith 2013, 216). </P
><P 

>CSS Dateien k&ouml;nnen auch zus&auml;tzlich spezifisch minimiert werden. Normalerweise verf&uuml;gen die CSS &ndash; Selektoren &uuml;ber mehrere CSS &ndash; Anweisungen. Manche CSS &ndash; Anweisungen k&ouml;nnen in ei-nem Befehl zusammengefasst werden. Dies betrifft z.B. &bdquo;margin&ldquo;, &bdquo;padding&ldquo;, &bdquo;border&ldquo; und &bdquo;background&ldquo; (Kuhn/Raith 2013, 218). </P
><P 

>Nachdem die Daten minimiert werden, werden diese f&uuml;r den Entwickler schlechter lesbar sein. Deshalb ist es empfehlenswert, um die Daten f&uuml;r Entwicklung und Ver&ouml;ffentlichung separat zu halten. </P
><P 

>F&uuml;r die Minimierung gibt es zahlreiche Online Tools, die sowohl allgemeine als auch datenspe-zifische Techniken anwenden k&ouml;nnen. Als Alternative kann ein automatisierendes Build &ndash; Sys-tem wie &bdquo;Gulp&ldquo; (Fractal 2016) oder &bdquo;Grunt&ldquo; (Grunt Development Team 2016) in den Entwick-lungsprozess eingebunden werden. Diese Tools k&ouml;nnen oben beschriebene Minimierungs-techniken anwenden. </P
><H3 

><FONT size="+1">3.2.4. Bildoptimierung </H3
><P 

><FONT size="+1">Etwa 60% einer durchschnittlichen Internetseite machen Bilder aus. Mittels Bildoptimierung kann die Gesamtladezeit der Webapplikation deutlich reduziert werden (Kuhn/Raith 2013, 219). Daf&uuml;r gibt es mehrere Techniken, die nach Kuhn/Raith (2013, 219) aufgelistet werden:  </P
><DL 

><DD 

>&#61630; Wahl der richtigen Art der Computergrafik (Vektorgrafiken vs. Rastergrafiken) und des richtigen Dateiformats. </DD
><DD 

>&#61630; Richtige Optimierungstechniken bei den ausgew&auml;hlten Bildformaten beachten. </DD
><DD 

>&#61630; Entfernung von Metadaten. </DD
><DD 

>&#61630; Anstatt Bilder CSS &ndash; Effekte verwenden, keinen Text in die Bilder schreiben. </DD
></DL
><P 

><I>Wahl der richtigen Art der Computergrafik (Vektorgrafiken vs. Rastergrafiken) und des richtigen </I><I>Dateiformats. </I></P
><P 

>Die Auswahl des richtigen Bildformats ist f&uuml;r die korrekte Darstellung des Bildes sehr wichtig. Haupts&auml;chlich unterscheiden sich zwei Arten von Computergrafiken: Vektorgrafiken und Ras-</P
><P 

>tergrafiken. Die Rastergrafiken dienen der Darstellung von komplizierten Bildern mit vielen De-tails und unregelm&auml;&szlig;igen Farben. Dabei muss beachtet werden, wie gut bei unterschiedlichen Zoomstufen die Bilder dargestellt werden (Grigorik 2016b). </P
><P 

>Die Vektorformate sind vom Zoomfaktor und der Aufl&ouml;sung unabh&auml;ngig. Deshalb ist es emp-fehlenswert, in Webapplikationen Vektorgrafiken vorzuziehen, weil diese sich unabh&auml;ngig von der Aufl&ouml;sung und der Gr&ouml;&szlig;e f&uuml;r die Darstellung auf vielen Endger&auml;ten eignen (Grigorik 2016b). </P
><P 

>Durch die richtige Wahl des Bildformates kann die Webapplikation deutlich optimiert werden. Die Beschreibung des einzelnen Bildformates &uuml;berschreitet jedoch den Rahmen dieser Master-arbeit. Das wichtigste ist, dass die Bilder eine m&ouml;glichst kleine Dateigr&ouml;&szlig;e haben und immer noch mit akzeptabler Qualit&auml;t dargestellt werden. Aus diesem Grund sollte man immer ein-sch&auml;tzen, welches Bildformat zu einem Bild am besten passen k&ouml;nnte. </P
><P 

><I>Richtige Optimierungstechniken bei den ausgew&auml;hlten Bildformaten beachten. </I></P
><P 

>F&uuml;r alle Bildformate existieren sowohl verlustfreie als auch verlustbehaftete Komprimierungen. Bei verlustbehafteter Komprimierung wird ein Filter angewendet, der vom Bild einige Pixelda-ten entfernt. Dabei muss man beachten, dass sich bei jedem einzelnen Bildformat das verlust-behaftete Komprimierungsverfahren unterscheidet. Bei verlustfreier Komprimierung wird ein Filter angewendet, der die Pixeldaten komprimiert. Alle Bildformate haben eine eigene Kombi-nation von Algorithmen, die die Funktionsweise der Komprimierung bestimmen. Um die pas-sende Optimierungstechnik f&uuml;r jedes einzelne Bildformat zu finden, muss die Bearbeitungs-weise jedes Bildformates genau betrachtet werden (Grigorik 2016b). </P
><P 

><I>Entfernung von Metadaten. </I></P
><P 

>Die Bilder k&ouml;nnen &uuml;ber Zusatzinformationen (sog. Metadaten) verf&uuml;gen. Diese k&ouml;nnen Kom-mentare, Anwendungs- oder EXIF (Exchangeable Image File Format) &ndash; Informationen sein. Diese enthalten z.B. Angaben zum Kameratyp, dem Aufnahmedatum, Kommentare usw. Es k&ouml;nnen auch Thumbnails f&uuml;r eine schnellere Vorschau des Bildes gespeichert werden (Kuhn/Raith 2013, 221). Diese Informationen sind f&uuml;r die Darstellung des Bildes in der Webapplikation nicht relevant und bestimmen die Bildqualit&auml;t nicht. Die Metainformationen k&ouml;nnen zus&auml;tzlichen Speicherplatz von bis zu 30Kb pro Bild haben. Diese Informationen sollten entfernt werden (Kuhn/Raith 2013, 221). </P
><P 

>Bei der Entfernung der Metadaten k&ouml;nnen sowohl viele Bildverarbeitungsprogramme als auch Plugins f&uuml;r die Bildoptimierung in den Taskmanagern (wie &bdquo;Gulp&ldquo; oder &bdquo;Grunt&ldquo;) helfen. </P
><P 

><I>Anstatt Bilder CSS </I><I>&ndash;</I><I> Effekte verwenden, keinen Text in Bilder schreiben. </I></P
><P 

>Man sollte immer auf die Konstruktion und die Bestandteile des Bildes achten. Bei vielen klei-nen Bildern (wie einfache Symbole, Pfeile oder einfache geometrische Figuren) kann man die </P
><P 

>Rastergrafiken durch CSS &ndash; Effekte oder Webschriften ersetzen. CSS &ndash; Effekte haben mehrere Vorteile gegen&uuml;ber Bildern (Grigorik 2016b): </P
><DL 

><DD 

>&#61630; Sie werden bei jeder Aufl&ouml;sung und Zoomstufe immer scharf bleiben. </DD
><DD 

>&#61630; Das &bdquo;Gewicht&ldquo; der Seite wird reduziert. </DD
><DD 

>&#61630; Es werden weniger HTTP &ndash; Requests stattfinden. </DD
></DL
><P 

>(Grigorik 2016b). </P
><P 

>Au&szlig;erdem darf man die Schrift, die zu einem Bild geh&ouml;rt, nicht au&szlig;er Acht lassen. Es ist immer besser, Text nicht direkt ins Bild zu schreiben, sondern Webschriften zu benutzen. Es gibt meh-rere Vorteile von Webschriften (Grigorik 2016b):  </P
><DL 

><DD 

>&#61630; Man kann die Gr&ouml;&szlig;e der Schriften oder die Schriftart immer ver&auml;ndern, wenn sich das Design der Webapplikation &auml;ndern wird. Au&szlig;erdem kann man unabh&auml;ngig von dem Bild arbeiten. </DD
><DD 

>&#61630; Es gibt sehr viele Schriftarten, die auch von den Browsern unterst&uuml;tzt werden. </DD
></DL
><P 

>(Grigorik 2016b). </P
><H2 

><FONT size="+1">3.3. Vorstellung des HTTP/2 &ndash; Protokolls </H2
><P 

><FONT size="+1">HTTP/2 ist der Nachfolger des fr&uuml;her entwickelten SPDY &ndash; Protokolls. Die Spezifikation des SPDY &ndash; Protokolls wurde als Startpunkt f&uuml;r das neue HTTP/2 &ndash; Protokoll adaptiert. Das SPDY &ndash; Protokoll ist ein experimentelles Protokoll, das von &bdquo;Google&ldquo; Mitte des Jahres 2009 entwickelt wurde. Das wichtigste Ziel, das dieses Protokoll erreichen sollte, war die &Uuml;berwin-dung der gut bekannten Einschr&auml;nkungen des HTTP/1.1 &ndash; Protokolls. Nach Grigorik (2015, 2-3) sind die Ziele: </P
><DL 

><DD 

>&#61630; Gesamtladezeit um 50% reduzieren. </DD
><DD 

>&#61630; Bei der Benutzung des neuen Protokolls &Auml;nderungen f&uuml;r die Endanwender vermeiden. </DD
><DD 

>&#61630; Bedarf an &Auml;nderungen am Inhalt der Webapplikation f&uuml;r die Webadministratoren ver-meiden. </DD
><DD 

>&#61630; Entwicklungskomplexit&auml;t reduzieren. </DD
><DD 

>&#61630; Entwicklung im Rahmen von Open-source. </DD
><DD 

>&#61630; Reelle Performance &ndash; Daten f&uuml;r die Validierung des neuen Protokolls erfassen. </DD
></DL
><P 

>(Grigorik 2015, 2-3). </P
><P 

>Das SPDY &ndash; Protokoll ist ein bin&auml;res Protokoll, das die Benutzung der TCP &ndash; Verbindung durch mehrere Funktionen effizienter machen kann. Dazu geh&ouml;ren: Multiplexierung von Requests und Responses, Priorisierungen und Kompression der Headerfelder (Grigorik 2015, 3). </P
><P 

>Das HTTP/2 &ndash; Protokoll ist ein neues Internetprotokoll, das im Februar 2015 von der IESG (The Internet Engineering Steering Group) genehmigt wurde. Im Mai des gleichen Jahres ist die of-fizielle Dokumentation des Protokolls erschienen: RFC &ndash; 7540 f&uuml;r das HTTP/2 &ndash; Protokoll (Belshe et al. 2015) und RFC &ndash; 7541 f&uuml;r die Header Kompression f&uuml;r HTTP/2 (Peon/Ruellan 2015; Grigorik 2015, 4). Das neue Protokoll erm&ouml;glicht mithilfe der Kompression von Header-feldern und der Multiplexierung, die innerhalb einer TCP &ndash; Verbindung stattfindet, eine effizi-entere Nutzung der Netzwerkressourcen und verringert die Latenz (Belshe et al. 2015). </P
><P 

>Das Ziel des HTTP/2 &ndash; Protokolls ist einerseits die &Uuml;berwindung der gut bekannten Schwach-stellen und Begrenzungen des HTTP/1.1 &ndash; Protokolls und anderseits die Erweiterung des HTTP/1.1 &ndash; Protokolls durch zus&auml;tzliche Funktionen:  </P
><DL 

><DD 

>&#61630; Kompression der HTTP - Headerfelder w&auml;hrend dem Transport zwischen Client und Server. </DD
><DD 

>&#61630; Bew&auml;ltigung des &bdquo;Head-Of-Line Blocking&ldquo; Problems in der HTTP &ndash; Schicht. </DD
><DD 

>&#61630; Multiplexierung der Requests und Responses. </DD
><DD 

>&#61630; Genaue Definition, wie das HTTP/2 &ndash; Protokoll mit dem HTTP/1.1 &ndash; Protokoll interagie-ren wird. </DD
><DD 

>&#61630; Priorisierung der Requests und Responses. </DD
><DD 

>&#61630; Anwendung des &bdquo;Server Pushs&ldquo;. </DD
></DL
><P 

> (Grigorik 2013, 209-210). </P
><P 

>Das HTTP/2 &ndash; Protokoll nutzt die gleichen Semantiken, wie das HTTP/1.1 &ndash; Protokoll. Es wurden keine gro&szlig;en &Auml;nderungen in den HTTP &ndash; Methoden, Statuscodes, URIs und Headerfeldern durchgef&uuml;hrt. Gro&szlig;e &Auml;nderungen haben vor allem die &Uuml;bertragungsart der Daten zwischen Client und Server betroffen (Grigorik 2013, 210). </P
><P 

>Das neue Protokoll wird von den meisten verwendeten Browsern unterst&uuml;tzt (Abb. 9). </P
><P 

>  </P
><IMG width="524" height="160"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_9.jpg" ><DL 

><DD 

><I>Abb. 9:</I><I> </I><I>Browserunterst&uuml;tzung des HTTP/2 </I><I>&ndash;</I><I> Protokolls, Stand: 26.08.2016 (&lt;</I><A href="http://caniuse.com/#search=http2">
<I>http://cani-use.com/#search=http2</I></A>
<I>&gt;). </I></DD
></DL
><P 

>Die serverseitige Unterst&uuml;tzung des HTTP/2 &ndash; Protokolls und die Serverwahl wird im Teil &bdquo;Test-vorbereitung&ldquo; beschrieben. </P
><H3 

><FONT size="+1">3.3.1. Wichtigste Bestandteile des HTTP/2 &ndash; Protokolls </H3
><P 

><FONT size="+1">Im Vergleich zum HTTP/1.1 &ndash; Protokoll, in dem die Daten im Klartext transportiert wurden, hat das HTTP/2 &ndash; Protokoll ein bin&auml;res Format. Die Protokolle, die die ASCII &ndash; Kodierung imple-mentieren, sind meistens einfach zu untersuchen und zu benutzen. Allerdings sind diese nicht effizient genug und es ist meistens schwieriger, um diese korrekt zu implementieren. Durch zus&auml;tzliche Leerzeichen, &auml;ndernde Abbr&uuml;che und weitere Eigenschaften ist es schwer, das Pro-tokoll unter Nutzdaten, Parserhinweisen und Sicherheitsfehlern zu erkennen. Im Gegenteil zu Protokollen mit ASCII &ndash; Kodierung ist die Benutzung des bin&auml;ren Protokolls schwieriger, aber diese neigen dazu perfomanter, stabiler und mit der korrekteren Implementierung versehen zu sein (Grigorik 2015, 7). </P
><P 

>In Abb. 10 ist die bin&auml;re Frameschicht des HTTP/2 &ndash; Protokolls dargestellt. Diese schreibt vor, wie HTTP &ndash; Nachrichten zwischen dem Client und dem Server eingekapselt und transportiert werden m&uuml;ssen (Grigorik 2013, 211). </P
><P 

> </P
><IMG width="412" height="214"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_10.jpg" ><DL 

><DD 

><I>Abb. 10:</I><I> </I><I>Bin&auml;re Frameschicht des HTTP/2 - Protokolls (Grigorik 2013, 212). </I></DD
></DL
><P 

>Es gibt eine wichtige Voraussetzung f&uuml;r die Nutzung des HTTP/2 &ndash; Protokolls: sowohl Client als auch Server m&uuml;ssen einen Mechanismus der bin&auml;ren Kodierung unterst&uuml;tzen, damit sich beide Seiten der Kommunikation verstehen werden (Grigorik 2015, 6). </P
><P 

>  </P
><IMG Alt="G:\Eigene Dokumente\MasterStudium\Masterarbeit\TEXTE\HTTP2\Steams, Messages, Frames.jpg" width="387" height="309"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_11.jpg" ><DL 

><DD 

><I>Abb. 11:</I><I> </I><I>&bdquo;Streams&ldquo;, &bdquo;Messages&ldquo; und &bdquo;Frames&ldquo; unter dem HTTP/2</I><I> </I><I>&ndash;</I><I> Protokoll (Grigorik 2013, 213). </I></DD
></DL
><P 

><I>Ein Grundkonzept von Streams, Messages und Frames. </I></P
><P 

>F&uuml;r die Kommunikation zwischen Client und Server wird nur eine TCP &ndash; Verbindung ben&ouml;tigt. Die Kommunikation unter dem HTTP/2 &ndash; Protokoll wurde in &bdquo;Streams&ldquo;, &bdquo;Messages&ldquo; und &bdquo;Fra-mes&ldquo; aufgeteilt (Abb. 11).  </P
><P 

>&bdquo;Stream&ldquo; ist ein Bytestrom innerhalb der bestehenden Verbindung. Innerhalb eines &bdquo;Streams&ldquo; werden eine oder mehrere &bdquo;Messages&ldquo; transportiert (Grigorik 2015, 7). Die Anzahl an &bdquo;Streams&ldquo;, die gleichzeitig bearbeitet werden kann, wird per Server definiert. Jeder &bdquo;Stream&ldquo; hat einen einzigartigen Identifikator (ID), der nicht wiederverwendbar ist. </P
><P 

>Eine &bdquo;Message&ldquo; ist eine logische HTTP &ndash; Nachricht, die aus Requests und Responses  besteht. Diese kann einen oder mehrere &bdquo;Frames&ldquo; in sich haben (Grigorik 2015, 7 - 8). </P
><P 

>&bdquo;Frame&ldquo; ist die kleinste Ma&szlig;einheit innerhalb der Kommunikation unter dem HTTP/2 &ndash; Proto-koll. Jeder &bdquo;Frame&ldquo; verf&uuml;gt &uuml;ber einen &bdquo;Frame Header&ldquo;, der zumindest Informationen &uuml;ber den Stream beinhaltet, zu dem dieser geh&ouml;rt. &bdquo;Frames&ldquo; definieren den spezifischen Typ von Daten, wie z.B. HEADERS &ndash; Frame f&uuml;r den Nachrichtenkopf (HTTP &ndash; Header), DATA &ndash; Frame f&uuml;r den Nachrichtenrumpf (HTTP &ndash; Nutzdaten) u.s.w. Alle &bdquo;Frames&ldquo; werden im bin&auml;ren Format darge-stellt (Grigorik 2015, 7 - 8). </P
><P 

>  </P
><P 

>Es gibt mehrere Typen von &bdquo;Frames&ldquo;, die im HTTP/2 &ndash; Protokoll spezifiziert sind (Tabelle 2). </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

><B>TYP </P
></TD
><TD  
 valign="top"
><P 

>Frame </P
></TD
><TD  
 valign="top"
><P 

>Beschreibung </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

></B>0 </P
></TD
><TD  
 valign="top"
><P 

>DATA </P
></TD
><TD  
 valign="top"
><P 

>Wird f&uuml;r den Transport der Nutzdaten der HTTP &ndash; Nachrichten (Body) benutzt. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>1 </P
></TD
><TD  
 valign="top"
><P 

>HEADERS </P
></TD
><TD  
 valign="top"
><P 

>Wird f&uuml;r die Er&ouml;ffnung eines &bdquo;Streams&ldquo; und die &Uuml;bertragung der HTTP &ndash; Headerfelder eines &bdquo;Streams&ldquo; verwendet. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>2 </P
></TD
><TD  
 valign="top"
><P 

>PRIORITY </P
></TD
><TD  
 valign="top"
><P 

>Spezifiziert die Priorit&auml;t eines &bdquo;Streams&ldquo;, die vom Sender ange-k&uuml;ndigt ist. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>3 </P
></TD
><TD  
 valign="top"
><P 

>RST_STREAM </P
></TD
><TD  
 valign="top"
><P 

>RST_STREAM wird f&uuml;r die sofortige Beendigung eines &bdquo;Streams&ldquo; gesendet, oder um zu signalisieren, dass ein Fehler passiert ist. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>4 </P
></TD
><TD  
 valign="top"
><P 

>SETTINGS </P
></TD
><TD  
 valign="top"
><P 

>Wird f&uuml;r die &Uuml;bertragung von Konfigurationsparametern be-nutzt, um zu bestimmen, wie die Kommunikationspartner mitei-nander interagieren werden. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>5 </P
></TD
><TD  
 valign="top"
><P 

>PUSH_PROMISE </P
></TD
><TD  
 valign="top"
><P 

>K&uuml;ndigt dem Client einen Stream vom Server an, mit den im pri-m&auml;ren Stream referenzierten Ressourcen. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>6 </P
></TD
><TD  
 valign="top"
><P 

>PING </P
></TD
><TD  
 valign="top"
><P 

>Wird sowohl f&uuml;r die Messung des minimalen &bdquo;Round Trip Time&ldquo; vom Absender benutzt, als auch f&uuml;r die Best&auml;tigung, dass die bestehende Verbindung noch funktionsf&auml;hig ist. Diese &bdquo;Frames&ldquo; k&ouml;nnen von jedem Kommunikationspartner gesendet werden. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>7 </P
></TD
><TD  
 valign="top"
><P 

>GOAWAY </P
></TD
><TD  
 valign="top"
><P 

>Wird f&uuml;r die Beendigung der bestehenden Verbindung oder zum Signalisieren massiver Fehlermeldungen verwendet. Dieser Frametyp erlaubt es, die Erzeugung von neuen &bdquo;Streams&ldquo; zu un-terbinden, w&auml;hrend fr&uuml;her erzeugte &bdquo;Streams&ldquo; fertig bearbeitet werden. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>8 </P
></TD
><TD  
 valign="top"
><P 

>WINDOW_UPDATE </P
></TD
><TD  
 valign="top"
><P 

>Wird f&uuml;r die Implementierung von &bdquo;Flow Control&ldquo; benutzt. </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>9 </P
></TD
><TD  
 valign="top"
><P 

>CONTINUATION </P
></TD
><TD  
 valign="top"
><P 

>Wird f&uuml;r die Fortsetzung einer Sequenz von Header Block - Fragmenten (ein Bestandteil des &bdquo;Frames&ldquo;: HEADERS, PUSH_PROMISE und CONTINUATION) verwendet. Es kann eine beliebige Anzahl von diesen &bdquo;Frames&ldquo; gesendet werden, wenn der fr&uuml;her gesendete &bdquo;Frame&ldquo; zu den Typen HEADERS, PUSH_PROMISE oder CONTINUATION geh&ouml;rt, die keinen &bdquo;END_HEADERS&ldquo; - Flag an sich haben und zum gleichen &bdquo;Stream&ldquo; geh&ouml;ren. </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 2:</I><I> </I><I>Typen von HTTP/2 </I><I>&bdquo;Frames&ldquo; (Belshe et </I><I>al. 2015, 31-49) </I></DD
></DL
><P 

>Nachdem die Verbindung des HTTP/2 &ndash; Protokolls aufgebaut ist, k&ouml;nnen Server und Client an-fangen, um die &bdquo;Frames&ldquo; auszutauschen. Alle &bdquo;Frames&ldquo; haben einen auf 9 Byte fixierten &bdquo;Frame Header&ldquo;, auf den die Nutzdaten (&bdquo;Frame Payload&ldquo;) folgen. Der &bdquo;Frame Header&ldquo; hat  mehrere </P
><P 

>Felder: Length, Type, Flags und Stream Identifier (Abb. 12) &bdquo;Frame Payload &ldquo; hat keine fixierte L&auml;nge: sie unterscheidet sich je nach Typ des &bdquo;Frames&ldquo; (Belshe et al. 2015, 12). </P
><P 

> </P
><IMG width="503" height="156"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_12.jpg" ><DL 

><DD 

><I>Abb. 12:</I><I> </I><I>Bestandteile eines &bdquo;Frames&ldquo;</I><I> (Belshe et al. 2015, 12). </I></DD
></DL
><P 

>Length Feld </P
><P 

>Das &bdquo;Length Feld&ldquo; definiert die maximale Gr&ouml;&szlig;e der Nutzdaten und ist vom Empf&auml;nger inner-halb der SETTINGS_MAX_FRAME_SIZE in den Einstellungen des HTTP/2 &ndash; Protokolls definiert.  Diese kann einen Wert zwischen 214 Bit und 224 Bit haben. Der &bdquo;Frame Header&ldquo; ist in diesen Daten nicht enthalten. Gleichzeitig wird im HTTP/2 &ndash; Standard die maximale Gr&ouml;&szlig;e auf 2<FONT size="+1">24<FONT size="+1"> - 1 Bit gesetzt, um Client und Server h&ouml;here Werte zum Senden zu erlauben. Je kleiner der Wert w&auml;hrend der &Uuml;bertragung gehalten wird, desto effizienter funktioniert die Multiplexierung (Belshe et al. 2015, 12-13). </P
><P 

>Type Feld </P
><P 

>&bdquo;Type&ldquo; ist ein 8 - Bit Feld. In diesem Feld wird der Typ des &bdquo;Frames&ldquo; (z.B. HEADERS, DATA, u.s.w.) und seine Semantiken dargestellt. Der Frame &bdquo;Type&ldquo; bestimmt in Bezug auf die HTTP/2 Imple-mentierung sowohl das Format als auch die Semantik eines Frames (Belshe et al. 2015, 12). </P
><P 

>Flags Feld </P
><P 

>&bdquo;Flag&ldquo; ist ein 8 - Bit Feld, das f&uuml;r framespezifische boolesche &bdquo;Flags&ldquo; reserviert ist. Flags werden Semantiken zugewiesen, die spezifisch f&uuml;r den entsprechenden Frame-Typ sind (Belshe et al. 2015, 12). </P
><P 

>R Feld </P
><P 

>Das &bdquo;R Feld&ldquo; ist ein Feld, das immer auf 1 Bit reserviert ist. Die Semantiken dieses Bits sind undefiniert. Dieses Feld wird immer auf den Wert 0 gesetzt (Belshe et al. 2015, 12). </P
><P 

>Stream Identifier Feld </P
><P 

>Das &bdquo;Stream Identifier&ldquo; Feld ist ein 31 - Bit integer Feld, das den &bdquo;Stream&ldquo; einzigartig identifi-ziert (Belshe et al. 2015, 12).<FONT color="#FF0000"> </P
><P 

><FONT color="#000000">  </P
><P 

>Er&ouml;ffnung und Beendigung eines Streams </P
><P 

>Bevor die Daten der Webapplikation innerhalb des HTTP/2 &ndash; Protokolls gesendet werden k&ouml;n-nen, muss ein neuer &bdquo;Stream&ldquo; ge&ouml;ffnet werden. Ein &bdquo;Stream&ldquo; kann sowohl clientseitig als auch serverseitig ge&ouml;ffnet werden: der Client kann mithilfe des HEADERS &ndash; Frame und der Server kann mithilfe des PUSH_PROMISE &ndash; Frames einen neuen &bdquo;Stream&ldquo; &ouml;ffnen. Um Kollisionen zwi-schen clientseitigen und serverseitigen &bdquo;Streams&ldquo; zu vermeiden, haben diese unterschiedliche IDs. Serverseitige &bdquo;Streams&ldquo; werden mit geraden IDs und clientseitige werden mit ungeraderen IDs gekennzeichnet (Grigorik 2015, 26 - 27), (Belshe et al. 2015, 40-42). </P
><P 

>Um ge&ouml;ffnete &bdquo;Streams&ldquo; zu beenden, wird ein RST_STREAM &ndash; Frame gesendet. Nachdem ein GOAWAY &ndash; Frame gesendet wird, werden keine &bdquo;Streams&ldquo; innerhalb der bestehenden TCP &ndash; Verbindung mehr erzeugt (Belshe et al. 2015, 36, 43). </P
><H3 

><FONT size="+1">3.3.2. Request und Response Multiplexierung </H3
><P 

><FONT size="+1">Unter dem HTTP/1.1 &ndash; Protokoll kann nur eine Antwort vom Server (Response) innerhalb einer TCP &ndash; Verbindung geliefert werden. Aus diesem Grund entsteht eine Warteschlange von Responses, die die Bezeichnung &bdquo;Head-Of-Line Blocking&ldquo; hat. Dies macht die Nutzung der TCP &ndash; Verbindung sehr ineffektiv (Grigorik 2015, 9). </P
><P 

>Im Vergleich zum HTTP/1.1 &ndash; Protokoll, werden im HTTP/2 &ndash; Protokoll die Requests und Responses in einzelne &bdquo;Frames&ldquo; aufgeteilt, die innerhalb eines &bdquo;Streams&ldquo; transportiert werden. Innerhalb des HTTP/2 &ndash; Protokolls ist es m&ouml;glich geworden, um die Lieferung einzelner &bdquo;Fra-mes&ldquo; von Requests und Responses  zu mischen. Vor dem Versand werden HTTP &ndash; Nachrichten vom Client und Server auf einzelne &bdquo;Frames&ldquo; aufgeteilt und nach dem Empfang auf der anderen Seite wieder zusammengesetzt (Grigorik 2015, 9). Abb. 13 veranschaulicht diesen Prozess. </P
><P 

> </P
><IMG Alt="G:\Eigene Dokumente\MasterStudium\Masterarbeit\TEXTE\HTTP2\miltiplexierung.jpg" width="530" height="155"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_13.jpg" ><DL 

><DD 

><I>Abb. 13:</I><I> </I><I>Request und Response Multiplexierung innerhalb einer TCP Verbindung  (Grigorik 2015, 9). </I></DD
></DL
><P 

>  </P
><P 

>Mithilfe dieser Besonderheit des neuen Protokolls soll die Performance der Webapplikationen deutlich besser sein: </P
><DL 

><DD 

>&#61630; Sowohl Requests als auch Responses werden multiplexiert und blockieren sich nicht mehr gegenseitig. </DD
><DD 

>&#61630; Es wird nur eine TCP &ndash; Verbindung ben&ouml;tigt, um die wechselnden Requests und Responses gleichzeitig in beide Richtungen liefern zu k&ouml;nnen. </DD
><DD 

>&#61630; Die HTTP/1.1 &ndash; Optimierungstechniken, wie Sprites von Bildern, Zusammenf&uuml;gen der Dateien (JavaScript, CSS) und Aufteilung der Ressourcen auf unterschiedliche Domains werden nicht mehr ben&ouml;tigt. </DD
><DD 

>&#61630; Dadurch, dass im HTTP/2 &ndash; Protokoll das &bdquo;Head-Of-Line Blocking&ldquo; Problem auf der HTTP &ndash; Ebene besser gel&ouml;st ist, wird die Kapazit&auml;t des Netzwerks effizienter genutzt. </DD
></DL
><P 

>(Grigorik 2015, 9 - 10). </P
><H3 

><FONT size="+1">3.3.3. Stream Priorisierung </H3
><P 

><FONT size="+1">Aufgrund der Besonderheit des HTTP/2 &ndash; Protokolls, HTTP &ndash; Nachrichten auf einzelne &bdquo;Frames&ldquo; aufteilen zu k&ouml;nnen, &ouml;ffnen sich zus&auml;tzliche M&ouml;glichkeiten. Au&szlig;er dass &bdquo;Frames&ldquo; unterschied-licher &bdquo;Streams&ldquo; unabh&auml;ngig voneinander geliefert werden k&ouml;nnen, kann die Reihenfolge, in der die &bdquo;Frames&ldquo; am Client ankommen, eine gro&szlig;e Rolle f&uuml;r den kritischen Rendering &ndash; Pfad spielen. Um dies zu erm&ouml;glichen, wurde dem HTTP/2 &ndash; Protokoll noch eine weitere Funktion hinzugef&uuml;gt: &bdquo;Stream Priorisierung&ldquo; (Grigorik 2015, 10). </P
><P 

>Die Spezifikation des HTTP/2 &ndash; Protokolls erlaubt es, jedem &bdquo;Stream&ldquo; Abh&auml;ngigkeiten und Ge-wichte zu geben: </P
><DL 

><DD 

>&#61630; Jeder &bdquo;Stream&ldquo; darf ein Gewicht (ein Integer-Wert) zwischen 1 und 256 haben. </DD
><DD 

>&#61630; Jeder &bdquo;Stream&ldquo; kann in Abh&auml;ngigkeit mit einem anderen &bdquo;Stream&ldquo; stehen (Grigorik 2015, 10). </DD
></DL
><P 

>Die Kombination zwischen Abh&auml;ngigkeiten und Gewichten eines jeden &bdquo;Streams&ldquo; erlaubt dem Client einen Priorisierungsbaum zu bauen. Der Priorisierungsbaum ist ein Hinweis f&uuml;r den Ser-ver, in welcher Reihenfolge die angefragten Ressourcen am besten geliefert werden sollen. Der Server kontrolliert gleichzeitig die Auslastung von CPU, RAM und Bandbreite und soweit die Daten zum Senden zur Verf&uuml;gung stehen, werden diese gem&auml;&szlig; den vom Client gelieferten Priorit&auml;ten an den Client geliefert. Allerdings kann der Client keine genaue Lieferreihenfolge vom Server verlangen. Es ist au&szlig;erdem nicht gew&uuml;nscht, die Serververarbeitung zu verlangsa-men, wenn Ressourcen mit h&ouml;herer Priorit&auml;t blockiert sind (Grigorik 2015, 10-12).  Im schlimms-ten Fall kann das &bdquo;Head-Of-Line Blocking&ldquo; -  Problem zur&uuml;ckkehren.<FONT color="#FF0000"><B> </P
><P 

><FONT color="#000000"></B>Alle &bdquo;Streams&ldquo; im HTTP/2 &ndash; Protokoll h&auml;ngen von einem &bdquo;Root Stream&ldquo; ab. Abh&auml;ngigkeit eines &bdquo;Streams&ldquo; im HTTP/2 &ndash; Protokoll bedeutet, dass der &bdquo;Eltern Stream&ldquo; vor seinen &bdquo;Kin-der Streams&ldquo; bearbeitet werden soll. In Abb. 14, Beispiel B, wird gezeigt, dass &bdquo;Stream C&ldquo; von </P
><P 

>&bdquo;Stream D&ldquo; abh&auml;ngig ist. Dies bedeutet, dass &bdquo;Stream D&ldquo; alle verf&uuml;gbaren Bandbreiteressour-cen bekommt und vom Server als erster verarbeitet wird (Grigorik 2015, 11). Um die Abh&auml;n-gigkeiten zu zeigen, verweisen die &bdquo;Kinder Streams&ldquo; mithilfe einer &bdquo;Parent Stream ID&ldquo; auf ihre &bdquo;Eltern Streams&ldquo;. </P
><P 

> </P
><IMG width="475" height="227"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_14.jpg" ><DL 

><DD 

><I>Abb. 14:</I><I> </I><I>Abh&auml;ngigkeiten und Gewichte von Streams (Grigorik 2015, 11). </I></DD
></DL
><P 

>Zwischen &bdquo;Streams&ldquo; mit gemeinsamem &bdquo;Eltern Stream&ldquo;, wird die Bandbreite je nach zugewie-senem Gewicht eines jeden &bdquo;Streams&ldquo; aufgeteilt. Je gr&ouml;&szlig;er das Gewicht eines &bdquo;Streams&ldquo; ist, desto mehr verf&uuml;gbare Bandbreiteressourcen bekommt er. In Abb. 14 sind mehrere Beispiele dargestellt. Die Aufteilung der Bandbreite wird f&uuml;r jedes Beispiel kurz beschrieben. </P
><P 

>Im Beispiel A haben &bdquo;Stream A&ldquo; und &bdquo;Stream B&ldquo; einen gemeinsamen &bdquo;Root - Stream&ldquo;. Da &bdquo;Stream A&ldquo; das Gewicht 12 hat und &bdquo;Stream B&ldquo; ein Gewicht von 4 hat, wird &bdquo;Stream A&ldquo; 2/3 aller verf&uuml;gbaren Bandbreiteressourcen bekommen (Grigorik 2015, 11). </P
><P 

>Im Beispiel B ist &bdquo;Stream C&ldquo; von &bdquo;Stream D&ldquo; abh&auml;ngig. Deshalb wird &bdquo;Stream D&ldquo; zuerst alle verf&uuml;gbaren Bandbreiteressourcen bekommen (Grigorik 2015, 11). </P
><P 

>Im Beispiel C wird zuerst &bdquo;Stream D&ldquo; die gesamte Bandbreite bekommen, danach &bdquo;Stream C&ldquo;. Anschlie&szlig;end wird die Bandbreite zwischen &bdquo;Stream A&ldquo; und &bdquo;Stream B&ldquo; aufgeteilt. Nur wird &bdquo;Stream A&ldquo; 2/3 aller verf&uuml;gbaren Bandbreiteressourcen bekommen (Grigorik 2015, 11). </P
><P 

>Im Beispiel D wird zuerst &bdquo;Stream D&ldquo; alle verf&uuml;gbaren Bandbreiteressourcen bekommen. Da-nach wird die Bandbreite zwischen &bdquo;Stream E&ldquo; und &bdquo;Stream C&ldquo; gleichm&auml;&szlig;ig aufgeteilt. Am Ende wird die Bandbreite je nach den Gewichten zwischen &bdquo;Stream A&ldquo; und &bdquo;Stream B&ldquo; aufgeteilt (Grigorik 2015, 11). </P
><P 

>In der HTTP/2 &ndash; Spezifikation ist es erlaubt, dass der Client Abh&auml;ngigkeiten und Gewichte zu jedem Zeitpunkt aktualisiert (Grigorik 2015, 12). Priorisierungen von &bdquo;Streams&ldquo; sind nur Hin-weise und deren Implementierungsstrategie h&auml;ngen sowohl vom Server, als auch vom Client ab: Der Client muss geeignete Priorisierungsdaten erstellen und der Server muss diese Daten </P
><P 

>annehmen und in der entsprechenden Priorisierungsreihenfolge zur&uuml;ck an den Client liefern k&ouml;nnen (Buch IG, 216). </P
><P 

>Es kann jedoch vorkommen, dass der Server die Priorisierungsinformationen nicht akzeptiert (Buch IG, 216). Dadurch k&ouml;nnen Hindernisse f&uuml;r den kritischen Rendering &ndash; Pfad entstehen: anstatt kritische Ressourcen zuerst zu liefern, wird der Server nicht kritische Ressourcen senden. </P
><P 

>Au&szlig;erdem unterst&uuml;tzen nicht alle modernen Browser die Priorisierungen (Tabelle 3) (Ishizawa 2015, 7). </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Namen </P
></TD
><TD  
 valign="top"
><P 

>Version </P
></TD
><TD  
 valign="top"
><P 

>Unterst&uuml;tzung </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Mozilla Firefox </P
></TD
><TD  
 valign="top"
><P 

>38.0.5 </P
></TD
><TD  
 valign="top"
><P 

>Ja </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Google Chrome </P
></TD
><TD  
 valign="top"
><P 

>43.0.2357.65 </P
></TD
><TD  
 valign="top"
><P 

>Nur Gewichte </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Microsoft Edge </P
></TD
><TD  
 valign="top"
><P 

>0.11.10074.0 (Preview). </P
></TD
><TD  
 valign="top"
><P 

>Nein </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Apple Safari </P
></TD
><TD  
 valign="top"
><P 

>9,0 (Preview). </P
></TD
><TD  
 valign="top"
><P 

>Nein </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 3:</I><I> </I><I>Implementierung der HTTP/2 </I><I>&ndash;</I><I> Priorisierungen im Browser  (Ishizawa 2015, 7). </I></DD
></DL
><P 

>Es ist schwer, um genau vorherzusagen, wie die Priorisierungsb&auml;ume von unterschiedlichen Browsern gebaut werden. Der Grund daf&uuml;r ist, dass jeder Browser auf seine eigene Art die Priorisierungen erstellt. In &bdquo;Mozilla Firefox&ldquo; liegen die Priorit&auml;ten zuerst bei CSS Dateien, danach bei JavaScript Dateien und zuletzt bei den Bildern. &bdquo;Google Chrome&ldquo; erstellt Priorisierungen nur auf Basis von Gewichten. Dies ist allerdings nicht effizient genug. &bdquo;Microsoft Edge&ldquo; unter-st&uuml;tzt Priorisierungen nicht (Moto Ishizawa, &bdquo;Understanding HTTP/2 prioritization&ldquo;, Folie 64). Aus diesem Grund ist es schwer, um die clientseitige Priorisierungsimplementierung unter Kon-trolle zu bringen. </P
><P 

>Priorit&auml;ten f&uuml;r &bdquo;Streams&ldquo; werden mithilfe des &bdquo;PRIORITY&ldquo; &ndash; Frames vom Sender angek&uuml;ndigt. Dieser &bdquo;Frame&ldquo; hat innerhalb der Nutzdaten (&bdquo;Frame&ldquo; &ndash; Payload) nur zwei Felder: &bdquo;Stream De-pendency&ldquo; &ndash; f&uuml;r die Abh&auml;ngigkeit und &bdquo;Weight&ldquo; &ndash; f&uuml;r das Gewicht (Belshe et al. 2015, 34-35). </P
><H3 

><FONT size="+1">3.3.4. Header Kompression </H3
><P 

><FONT size="+1">&bdquo;Header Kompression&ldquo; (kurz &bdquo;HPACK&ldquo;) ist ein Kompressionsformat f&uuml;r die effizientere &Uuml;bertra-gung von HTTP &ndash; Headerfeldern innerhalb der HTTP/2 &ndash; Verbindung (Peon/Ruellan 2015, 4). </P
><P 

>Innerhalb des HTTP/1.1 &ndash; Protokolls wurden alle Request -  und Response  Headerfelder ohne Kompression im Klartext &uuml;bertragen. Wenn eine Webapplikation innerhalb einer Sitzung meh-rere Dutzend Requests braucht, w&auml;chst der Anteil der angefragten Header zunehmend. Dies verbraucht Bandbreite und f&uuml;hrt dazu, dass zus&auml;tzliche Latenz entsteht (Peon/Ruellan 2015, 4). Manchmal kann diese Gr&ouml;&szlig;e bis zu 800 Bytes (ohne Cookies) pro Request - Response erreichen (Grigorik 2015, 19). </P
><P 

>Viele Metadaten, die als Schl&uuml;ssel &ndash; Werte Paare dargestellt sind, unterscheiden sich von Re-quest zu Request oder von Response zu Response oftmals nicht voneinander. Dazu geh&ouml;ren </P
><P 

>z.B. Method: GET, User - Agent: Mozilla, Chrome, u.s.w. Diese wiederholen sich und verbrau-chen die Bandbreiteressourcen. Aus diesem Grund werden in &bdquo;HPACK&ldquo; sowohl statische als auch dynamische Tabellen verwendet (Abb. 15). Eine Statische Tabelle ist in der Spezifikation definiert und besteht aus den &uuml;blichen HTTP &ndash; Headerfeldern, die in allen Requests und Responses benutzt werden. Jedes Headerfeld hat in der statischen Tabelle seine eigene Num-mer (Peon/Ruellan 2015, 4), (Grigorik 2015, 19). </P
><P 

> </P
><IMG width="607" height="194"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_15.jpg" ><DL 

><DD 

><I>Abb. 15:</I><I> </I><I>Funktionsweise des &bdquo;HPACK&ldquo; in HTTP/2, (Grigor</I><I>ik 2015, 19). </I></DD
></DL
><P 

>Au&szlig;er den &uuml;blichen Werten existieren auch andere Schl&uuml;ssel - Werte Paare in Headerfeldern, die zur bestimmten Webapplikation geh&ouml;ren (z.B. Servername) und sich mit zunehmenden An-fragen und Antworten mehrmals wiederholen k&ouml;nnen. Daf&uuml;r wird die dynamische Tabelle an-gewendet. Zuerst ist die dynamische Tabelle leer, wird sich aber innerhalb der HTTP/2 &ndash; Ver-bindung erweitern. Jeder Wert in der dynamischen Tabelle wird auch indexiert (Abb. 15). An-statt ganze Schl&uuml;ssel &ndash; Werte Paare jedes Mal neu zu &uuml;bertragen, werden in den kodierten Headern nur indexierte Nummern hinzugef&uuml;gt (Peon/Ruellan 2015, 4), (Grigorik 2015, 19-20). </P
><P 

>Statische und Dynamische Tabellen existieren sowohl auf der Client- als auch auf der Server-seite und werden innerhalb der bestehenden Verbindung laufend aktualisiert. Jedes neue Schl&uuml;ssel - Werte Paar wird entweder zur existierenden Tabelle hinzugef&uuml;gt oder zuvor &uuml;ber-tragene Werte in der Tabelle werden ersetzt (Buch IG, 222). Au&szlig;er statischen und dynamischen Tabellen werden die Headerfelder w&auml;hrend der &Uuml;bertragung mithilfe des statischen Huff-man &ndash; Code kodiert, um die Gesamtgr&ouml;&szlig;e zu reduzieren (Grigorik 2015, 19 - 20). </P
><P 

>Wie zuvor erw&auml;hnt wurde, wird die Definition von Requests- und Responses- Headerfeldern im HTTP/2 &ndash; Protokoll nicht ver&auml;ndert. Nur zwei &Auml;nderungen im HTTP/2 &ndash; Protokoll haben die Darstellung der Headerfelder betroffen. Erstens, dass alle Headerfelder klein geschrieben wer-den. Zweitens werden die Requests &ndash; Headerfelder &bdquo;:authority&ldquo;, &bdquo;:method&ldquo;, &bdquo;:path&ldquo; und &bdquo;:scheme&ldquo; als pseudo - Headerfelder dargestellt werden (Grigorik 2015, 20). </P
><H3 

><FONT size="+1">3.3.5. Eine TCP &ndash; Verbindung pro Domain </H3
><P 

><FONT size="+1">Um im HTTP/1.1 &ndash; Protokoll die Request und Response Parallelisierung zu erm&ouml;glichen, werden mehrere TCP &ndash; Verbindungen (je nach Browser) gleichzeitig ge&ouml;ffnet. Im Gegenteil werden im </P
><P 

>HTTP/2 &ndash; Protokoll alle &bdquo;Streams&ldquo; innerhalb einer TCP &ndash; Verbindung multiplexiert. Deshalb ist es nicht mehr n&ouml;tig, mehrere Verbindungen gleichzeitig zu halten (Grigorik 2015, 13). </P
><P 

>Die Wiederverwendung einer TCP &ndash; Verbindung hat mehrere Vorteile: </P
><DL 

><DD 

>&#61630; Innerhalb einer TCP &ndash; Verbindung k&ouml;nnen die Streams besser priorisiert werden. Au-&szlig;erdem wird die Zeit f&uuml;r jede einzelne Verbindungseinrichtung (Three - Way - Hands-hake) gespart. Wenn die Verbindung durch eine SSL &ndash; Verschl&uuml;sselung l&auml;uft, wird diese Zeitersparnis noch deutlicher sein. </DD
><DD 

>&#61630; Bessere Kompressionsm&ouml;glichkeiten (&bdquo;Header Kompression&ldquo;) innerhalb einer TCP &ndash; Verbindung. </DD
><DD 

>&#61630; Je weniger Verbindungen gleichzeitig bearbeitet werden, desto weniger CPU- und  RAM-Leistungen werden verbraucht. Dies betrifft sowohl den Client als auch den Ser-ver. </DD
></DL
><P 

>(Grigorik 2015, 13 - 14). </P
><P 

>Andererseits wird die Verwendung einer TCP &ndash; Verbindung nicht nur vorteilhaft sein:  </P
><DL 

><DD 

>&#61630; Falls das TCP &ndash; Paket verloren geht, wird die Kapazit&auml;t der TCP &ndash; Fenstergr&ouml;&szlig;e (TCP Re-ceive Window Size) automatisch verringert (siehe Unterkapitel &bdquo;HTTP/1 &ndash; Optimie-rungstechniken, Stand bisher&ldquo;). Dies f&uuml;hrt dazu, dass die maximale Datenrate der kom-pletten TCP &ndash; Verbindung verringert wird und die Daten den Client verz&ouml;gert erreichen werden.<FONT color="#FF0000"> </DD
><DD 

><FONT color="#000000">&#61630; Das &bdquo;Head-Of-Line Blocking&ldquo; &ndash; Problem wurde zwar von der HTTP &ndash; Schicht genom-men (durch die Multiplexierung), findet aber immer noch in der TCP &ndash; Schicht statt. Dies passiert, da beim Verlust eines TCP &ndash; Pakets auf dem Weg zum Empf&auml;nger, die gesamte Sequenz von TCP &ndash; Paketen im TCP &ndash; Puffer gehalten wird, bis das verlorene TCP &ndash; Pa-ket den Empf&auml;nger erreichen wird (Buch IG, 216). Weil innerhalb des HTTP/2 &ndash; Proto-kolls nur eine TCP &ndash; Verbindung zur Verf&uuml;gung steht, k&ouml;nnen diese Verz&ouml;gerungen deutlich ausfallen. </DD
><DD 

>&#61630; Falls die TCP &ndash; Fensterskalierung (TCP Window Scale Option) deaktiviert ist, wird die gesamte Datenrate der TCP &ndash; Verbindung durch Verz&ouml;gerungen in der Bandbreite li-mitiert. </DD
></DL
><P 

>(Grigorik 2015, 14). </P
><P 

>Aus den zuvor beschriebenen Vor- und Nachteilen k&ouml;nnen m&ouml;gliche Szenarien gedacht wer-den, in denen wenige TCP &ndash; Verbindungen vorteilhafter sein k&ouml;nnen. Es gab Tests, in denen best&auml;tigt wurde, dass die negative Wirkung des &bdquo;Head-Of-Line Blocking&ldquo; die Vorteile der &bdquo;Hea-der Kompression&ldquo; und der Priorisierung &uuml;berwiegt, wenn TCP &ndash; Pakete w&auml;hrend der Verbin-dung verloren gehen (Grigorik 2015, 14 - 15). </P
><H3 

><FONT size="+1">3.3.6. Flow Control </H3
><P 

><FONT size="+1">Die M&ouml;glichkeit, um innerhalb des neuen Protokolls Ressourcen zu multiplexieren, verursacht einen Wettbewerb zwischen allen Ressourcen, die die Bandbreite zwischen sich aufteilen m&uuml;s-sen. Priorit&auml;ten, die f&uuml;r &bdquo;Streams&ldquo; gesetzt werden k&ouml;nnen, sind daf&uuml;r nicht effizient genug, um die Verteilung zwischen den Streams zu kontrollieren. Um den &bdquo;Stream&ldquo; &ndash; Durchfluss zu vertei-len und damit das Problem zu l&ouml;sen, gibt es innerhalb des HTTP/2 &ndash; Protokolls einen einfachen Mechanismus: &bdquo;Flow Control&ldquo;. &bdquo;Flow Control&ldquo; basiert auf den WINDOW_UPDATE &ndash; Frames. Der Empf&auml;nger k&uuml;ndigt an, wie viele Bytes innerhalb des &bdquo;Streams&ldquo; und der Sitzung er annehmen kann. Die Fenstergr&ouml;&szlig;e des &bdquo;Flow Controls&ldquo; wird w&auml;hrend der Sitzung ver&auml;ndert und WINDOW_UPDATE &ndash; Frames &uuml;bertragen die &bdquo;Stream ID&ldquo; und die Fenstergr&ouml;&szlig;e f&uuml;r die einzel-nen &bdquo;Streams&ldquo;. Au&szlig;erdem kann der Empf&auml;nger jede Fenstergr&ouml;&szlig;e f&uuml;r einzelne &bdquo;Streams&ldquo; inner-halb der bestehenden Verbindung ausw&auml;hlen. &bdquo;Flow Control&ldquo; kann beim Empf&auml;nger sowohl f&uuml;r einzelne &bdquo;Streams&ldquo; als auch f&uuml;r eine komplette Sitzung deaktiviert werden (Buch IG, 219). </P
><P 

>Soweit die Verbindung unter dem HTTP/2 &ndash; Protokoll aufgebaut wird, werden Client und Ser-ver den SETTINGS &ndash; Frame miteinander austauschen. In diesen &bdquo;Frames&ldquo; wird die Fenstergr&ouml;&szlig;e des &bdquo;Flow Controls&ldquo; f&uuml;r beide Seiten der Kommunikation gesetzt. Innerhalb der Spezifikation des HTTP/2 &ndash; Protokolls gibt es keine bestimmten Algorithmen und keine definierten Parame-ter f&uuml;r die WINDOW_UPDATE &ndash; Frames. Es ist dem Entwickler &uuml;berlassen, die Gr&ouml;&szlig;e der anzu-nehmenden Daten einzustellen (Buch IG, 219). </P
><P 

>Der Mechanismus des &bdquo;Flow Controls&ldquo; ist zum Mechanismus der &bdquo;Flow Control&ldquo; Funktion des TCP &ndash; Protokolls sehr &auml;hnlich. &bdquo;Flow Control&ldquo; kann aber nicht einzelne &bdquo;Streams&ldquo; innerhalb ei-ner TCP &ndash; Verbindung unter Kontrolle nehmen. Aus diesem Grund gibt es den &bdquo;Flow Control&ldquo; f&uuml;r das HTTP/2 &ndash; Protokoll (Buch IG, 219). </P
><H3 

><FONT size="+1">3.3.7. Server Push </H3
><P 

><FONT size="+1">&bdquo;Server Push&ldquo; ist eine m&auml;chtige Funktion des HTTP/2 &ndash; Protokolls. &bdquo;Server Push&ldquo; ist die F&auml;hig-keit des Servers, zu den vom Client angefragten Ressourcen noch weitere Ressourcen zu liefern. D.h., dass mithilfe von &bdquo;Server Push&ldquo; der Client mit Erhalt der angefragten Ressource noch wei-tere Ressourcen zur&uuml;ckbekommt. Dadurch m&uuml;ssen f&uuml;r die anderen Ressourcen keine weiteren Anfragen gestellt werden. Abb. 16 verdeutlicht die Funktionsweise des &bdquo;Server Pushs&ldquo; (Grigorik 2015, 17). </P
><P 

> </P
><IMG width="479" height="184"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_16.jpg" ><DL 

><DD 

><I>Abb. 16:</I><I> </I><I>Funktionsweise des &bdquo;Server Pushs&ldquo; (Buch IG, 220).</I><I> </I></DD
></DL
><P 

>Warum k&ouml;nnte diese Funktion so n&uuml;tzlich sein? Eine typische Webapplikation besteht aus dut-zenden Ressourcen, die nacheinander entdeckt und angefragt werden. &bdquo;Server Push&ldquo; spart die Anfragezeit an den Server (Grigorik 2015, 17). Besonders n&uuml;tzlich kann &bdquo;Server Push&ldquo; dann sein, wenn dem Server bekannt ist, dass der Client f&uuml;r bestimmte Ressourcen eines bestimmten Re-quests unmittelbar darauf weitere Ressourcen braucht und bald selbst nach ihnen fragen wird (Belshe et al. 2015, 60-61). </P
><P 

>Alle Ressourcen, die gepusht werden sollen, werden vom Server in Abh&auml;ngigkeit von einem vom Client zuvor initiierten Requests geschickt (Belshe et al. 2015, 60). Au&szlig;erdem m&uuml;ssen sie die gleiche Herkunft (gleiche Domain) wie der Request haben (Buch IG, 221). </P
><P 

>Soweit die HTTP/2 &ndash; Verbindung aufgebaut wird, werden der Client und der Server die SET-TINGS &ndash; Frames austauschen, in denen steht, wie viele &bdquo;Streams&ldquo; in beiden Richtungen gleich-zeitig geliefert werden k&ouml;nnen. Deswegen kann der Client die Anzahl an gepushten &bdquo;Streams&ldquo; begrenzen oder &uuml;berhaupt abschaffen, wenn diese Anzahl auf null gestellt wird (Buch IG, 220).  </P
><P 

>Um im HTTP/1.1 &ndash; Protokoll die Anzahl von Requests und die Anfragezeit zu sparen, wurden die Dateien per Ressource Inlining in der HTML &ndash; Datei hinzugef&uuml;gt. Im Gegenteil zu den Op-timierungstechniken f&uuml;r das HTTP/1.1 &ndash; Protokoll (siehe Unterkapitel &bdquo;3.1. HTTP/1 &ndash; Optimie-rungstechniken, Stand bisher&ldquo;) hat &bdquo;Server Push&ldquo; unter dem HTTP/2 &ndash; Protokoll mehrere Vor-teile: </P
><DL 

><DD 

>&#61630; Gepushte Ressourcen k&ouml;nnen beim Client in den Cache gelegt werden. </DD
><DD 

>&#61630; Gepushte Ressourcen k&ouml;nnen zwischen Unterseiten einer Webapplikation benutzt wer-den. </DD
><DD 

>&#61630; Gepushte Ressourcen k&ouml;nnen mit anderen Ressourcen multiplexiert werden. </DD
><DD 

>&#61630; Gepushte Ressourcen k&ouml;nnen vom Server priorisiert werden. </DD
></DL
><P 

>(Grigorik 2015, 18). </P
><P 

> &bdquo;Streams&rdquo;, die durch &bdquo;Server Push&ldquo; ge&ouml;ffnet werden, werden durch PUSH_PROMISE &ndash; Frames initiiert. Dieses &bdquo;Frame&ldquo; signalisiert die Bereitschaft des Servers, um noch andere in den Einstel-lungen beschriebene Ressourcen zus&auml;tzlich zum Response (DATA &ndash; Frame der angefragten </P
><P 

>Ressource) zu liefern. Der PUSH_PROMISE &ndash; Frame besteht vor allem aus typischen &bdquo;Frame Headern&ldquo; und einer zus&auml;tzlichen &bdquo;Promised - Stream ID&ldquo;, die diesen Stream eindeutig identifi-ziert. Alle PUSH_PROMISE &ndash; Frames erreichen den Client vor dem DATA &ndash; Frame des eigentli-chen Requests. Diese Reihenfolge ist wichtig, weil dies dem Client das Signal gibt, nicht mehr selber nach diesen Dateien zu fragen. Nachdem der Client diesen &bdquo;Frame&ldquo; bekommt, hat er die Option, den ganzen &bdquo;Stream&ldquo; zu verwerfen, falls z.B. die Datei schon im Browser Cache liegt. Dies passiert mithilfe des RST_STREAM &ndash; Frames (Grigorik 2015, 18). </P
><P 

>Der Client hat auch die M&ouml;glichkeit, die Anzahl von gepushten Ressourcen zu begrenzen. Diese Einstellungen wurden innerhalb des SETTINGS &ndash; Frames &uuml;bertragen, der nach dem Aufbau der HTTP/2 &ndash; Verbindung ausgetauscht wird und der sich jeder Zeit innerhalb der Sitzung &auml;ndern kann (Grigorik 2015, 18). </P
><H3 

><FONT size="+1">3.3.8. Verbindungsaufbau unter dem HTTP/2 &ndash; Protokoll </H3
><P 

><FONT size="+1">Wie zuvor erw&auml;hnt wurde, m&uuml;ssen, um das neue Protokoll benutzen zu k&ouml;nnen, beide Seiten der Kommunikation bin&auml;re Kodierung unterst&uuml;tzen (Grigorik 2015, 6). Da nicht alle Browser und Browserversionen das neue Protokoll unterst&uuml;tzen (Abb. 9), muss zwischen dem Client und dem Server eine &bdquo;Verabredung&ldquo; &uuml;ber die Nutzung des geeigneten Protokolls stattfinden. Sollte eine von beiden Seiten der Kommunikation das neue Protokoll nicht unterst&uuml;tzen, wird das HTTP/1.1 &ndash; Protokoll benutzt. Soweit der Client das HTTP/2 &ndash; Protokoll unterst&uuml;tzt, muss er herausfinden, ob der Server das gleiche tut. </P
><P 

>Unter dem HTTP/2 &ndash; Protokoll ist es auch m&ouml;glich, die Webapplikation unter unverschl&uuml;sselter Verbindung aufzurufen, da dies im HTTP/2 &ndash; Standard festgehalten ist (Eissing 2015). Wenn HTTP/1.1- und HTTP/2 &ndash; Protokolle unter dem gleichen Port  (80) laufen und wenn es keine anderen Informationen dar&uuml;ber gibt, ob der Server das HTTP/2 &ndash; Protokoll unterst&uuml;tzt, wird der Client einen &bdquo;Upgrade&ldquo; &ndash; Mechanismus zur Nutzung des HTTP/2 &ndash; Protokolls durchf&uuml;hren. Dadurch wird eine &bdquo;Vereinbarung&ldquo; f&uuml;r die weitere Kommunikation getroffen. Dieser Mechanis-mus hat den folgenden Ablauf: (Grigorik 2015, 21-22) </P
><P 

><I>Clientseitiger Request: </I></P
><P 

>GET /page HTTP/1.1 </P
><P 

>Host: server.example.com </P
><P 

>Connection: Upgrade, HTTP/2-Settings </P
><P 

>Upgrade: h2c <B>(1)</B> </P
><P 

>HTTP/2-Settings: (SETTINGS payload) <B>(2)</B> </P
><P 

> </P
><P 

><I>  </I></P
><P 

><I>Serverseitiger Response: </I></P
><P 

>HTTP/1.1 200 OK <B>(3)</B> </P
><P 

>Content-length: 243 </P
><P 

>Content-type: text/html </P
><P 

>(... HTTP/1.1.1 response ...) </P
><P 

> </P
><P 

>(oder) </P
><P 

> </P
><P 

>HTTP/1.1 101 Switching Protocols <B>(4)</B> </P
><P 

>Connection: Upgrade </P
><P 

>Upgrade: h2c </P
><P 

>(... HTTP/2 response ...) </P
><P 

><B>(1):</B> Es wird ein HTTP/1.1 Request mit HTTP/2 &bdquo;Upgrade&ldquo; &ndash; Header initialisiert, um zu zeigen, dass der Client das HTTP/2 &ndash; Protokoll unterst&uuml;tzt (Grigorik 2015, 21-22). </P
><P 

><B>(2):</B> Der Client schickt gleich einen bin&auml;ren SETTINGS &ndash; Frame mit den HTTP/2 &ndash; Einstellungen (Grigorik 2015, 21-22). </P
><P 

><B>(3): </B>Wenn der Server das HTTP/2 &ndash; Protokoll nicht unterst&uuml;tzt, wird der Response durch das HTTP/1.1 &ndash; Protokoll zur&uuml;ckgeliefert (Grigorik 2015, 21-22). </P
><P 

><B>(4):</B> Im Fall, dass der Server das HTTP/2 &ndash; Protokoll unterst&uuml;tzt, wird er den &bdquo;101 Switching Protocols&ldquo; &ndash; Response zur&uuml;ckgeben und sofort zur unverschl&uuml;sselten HTTP/2 &ndash; Verbindung (h2c) wechseln (Grigorik 2015, 21-22). </P
><P 

>Wenn der Client durch vorherige Aufrufe der Webapplikation gemerkt hat, dass entsprechen-der Server das HTTP/2 &ndash; Protokoll unterst&uuml;tzt, wird der &bdquo;Upgrade&ldquo; &ndash; Mechanismus nicht wieder stattfinden, sondern die Kommunikation wird gleich unter dem HTTP/2 &ndash; Protokoll anfangen (Grigorik 2015, 21-22). </P
><P 

>Oben wurde der Fall beschrieben, wie die Kommunikation zwischen Client und Server unter unverschl&uuml;sselten Verbindung stattfinden kann. Im Anhang befindet sich unter &bdquo;Upgrade HTTP/2&ldquo; der Code von Requests und Responses der Webapplikation, welche f&uuml;r die Tests in dieser Masterarbeit benutzt wird. Diese wurde am lokalen PC mithilfe des &bdquo;Curl&ldquo; &ndash; Clients auf-gerufen. </P
><P 

>Allerdings muss man beachten, dass die Browser, die das HTTP/2 &ndash; Protokoll unterst&uuml;tzen, nur verschl&uuml;sselte (TLS) Verbindungen erlauben (Grigorik 2015, 21), (NGINX, Inc. 2015, 3). Aus die-sem Grund wird der oben beschriebene Fall im Browser nicht funktionieren und die Kommu-nikation wird nur unter dem HTTP/1.1 &ndash; Protokoll laufen. </P
><P 

>Um die verschl&uuml;sselte Kommunikation zwischen Browser und Server unter dem HTTP/2 &ndash; Pro-tokoll erlauben zu k&ouml;nnen, ben&ouml;tigt man die TLS &ndash; Verschl&uuml;sselung mit der Erweiterung &bdquo;Ap-plication-Layer Protocol Negotiation&ldquo; (kurz: ALPN) (Buch IG, 226). ALPN ist notwendig, um das Protokoll zwischen dem Client und dem Server auszuhandeln, das &uuml;ber eine verschl&uuml;sselte Ver-bindung laufen soll. Hierbei werden zus&auml;tzliche &bdquo;Round Trips&ldquo; und als Folge dessen unn&ouml;tige Latenz zwischen Client und Server vermieden (Wikipedia 2016g), (Buch IG, 53-54). </P
><P 

>Um die Kommunikation unter einer TLS &ndash; verschl&uuml;sselten Verbindung mit dem HTTP/2 &ndash; Pro-tokoll zu zeigen, wird der Code von Requests und Responses der aufgerufenen Test-Webappli-kation gespeichert, die f&uuml;r diese Masterarbeit entwickelt wurde. Dieser befindet sich im Anhang unter &bdquo;9.1 Upgrade HTTP/2&ldquo;. Die Webapplikation wurde am lokalen PC mithilfe des &bdquo;Curl&ldquo; &ndash; Cli-ents aufgerufen. Im ersten Fall, die Webapplikation wird mit TLS &ndash; Verschl&uuml;sselung aufgerufen, ist zu sehen, dass die TLS &ndash; Verbindung mit &bdquo;ALPN&ldquo; benutzt wird und &bdquo;ALPN&ldquo; die Verwendung des neuen Protokolls erlaubt. Dadurch wird die Kommunikation unter dem HTTP/2 &ndash; Protokoll laufen. Wenn die Webapplikation ohne Verschl&uuml;sselung aufgerufen wird, wird die weitere Kommunikation unter dem HTTP/1.1 &ndash; Protokoll laufen.<FONT color="#FF0000"> <FONT color="#000000">Man sieht, dass der Client beim Requ-est kein &bdquo;Upgrade&ldquo; &ndash; Header initialisiert. Deshalb hat der Server das HTTP/1.1 &ndash; Protokoll nicht auf das HTTP/2 &ndash; Protokoll gewechselt. </P
><H2 

><FONT size="+1">3.4. M&ouml;gliche Optimierungstechniken f&uuml;r das HTTP/2 &ndash; Protokoll </H2
><P 

><FONT size="+1">Im vorherigen Unterkapitel wurde die Funktionsweise des HTTP/2 &ndash; Protokolls beschrieben. In diesem Teil der Masterarbeit wird auf m&ouml;gliche Frontend- und Backend-Optimierungstechni-ken f&uuml;r das neue Protokoll aufmerksam gemacht. Man muss die Funktionsweise des neuen Protokolls verstehen, um einsch&auml;tzen zu k&ouml;nnen, welche Optimierungstechniken geeignet sein k&ouml;nnen. Deshalb wird ein kurzer &Uuml;berblick &uuml;ber neue Funktionen des HTTP/2 &ndash; Protokolls auf-gelistet: </P
><DL 

><DD 

>&#61630; Innerhalb des HTTP/2 &ndash; Protokolls wird nur eine TCP &ndash; Verbindung ben&ouml;tigt. </DD
><DD 

>&#61630; Alle HTTP &ndash; Header werden w&auml;hrend dem Transport komprimiert. </DD
><DD 

>&#61630; Alle Requests und Responses werden auf kleine &bdquo;Frames&ldquo; aufgeteilt und innerhalb der Sitzung multiplexiert. </DD
><DD 

>&#61630; Es gibt die M&ouml;glichkeit, um die Ressourcen per &bdquo;Server Push&ldquo; zu &uuml;bergeben. </DD
><DD 

>&#61630; Alle &bdquo;Streams&ldquo; k&ouml;nnen priorisiert werden. </DD
></DL
><P 

>(Grigorik 2015, 6-23). </P
><P 

>Ausgehend von der Funktionsweise des neuen Protokolls, kann man &uuml;berlegen, was man im Vergleich zu den Frontend &ndash; Optimierungstechniken des HTTP/1.1 &ndash; Protokolls unternehmen kann. Da es im HTTP/2 &ndash; Protokoll nur eine TCP &ndash; Verbindung gibt, kann es sein, dass innerhalb dieser Verbindung alle Ressourcen besser priorisiert werden k&ouml;nnen, als bei mehreren Verbin-dungen (Grigorik 2013, 242). Wenn die Ressourcen nicht mehr auf unterschiedliche Domains aufgeteilt werden, wird der Client genauer wissen, welche Ressourcen er zuerst bekommen </P
><P 

>m&ouml;chte und kann die Ressourcen nach Priorit&auml;ten sortieren. In der Theorie k&ouml;nnen sowohl clientseitige als auch serverseitige &bdquo;Streams&ldquo; priorisiert werden (Grigorik 2015, 18), (Buch IG, 216). In der Dokumentation des &bdquo;mod_http2&ldquo;-Moduls des Apache-Servers steht, dass &bdquo;Streams&ldquo;, die clientseitig ge&ouml;ffnet werden, vom Client priorisiert werden m&uuml;ssen. Nur im Fall des &bdquo;Server Pushes&ldquo; werden serverseitig ge&ouml;ffnete &bdquo;Streams&ldquo; vom Server priorisiert (Apache Software Foundation 2016a). </P
><P 

>Wenn man die Funktionsweise der dynamischen Tabellen in &bdquo;HPACK&ldquo; genauer betrachtet, wird man sehen, dass innerhalb einer TCP &ndash; Verbindung diese effizienter benutzt werden k&ouml;nnen (Grigorik 2013, 242). Der Grund daf&uuml;r ist, dass dynamische Tabellen f&uuml;r eine Verbindung weni-ger Inhalte haben werden. </P
><P 

>Aufgrund der Funktionsweise der Priorisierungen des &bdquo;Streams&ldquo; und &bdquo;HPACK&ldquo; kann festgestellt werden, dass die Aufteilung der Ressourcen einer Webapplikation auf unterschiedliche Do-mains im Fall der Verwendung des HTTP/2 &ndash; Protokolls nur schaden wird (Grigorik 2013, 242). Aus diesem Grund wird diese Optimierungstechnik f&uuml;r die Test-Webapplikation nicht ange-wendet werden. </P
><P 

>Innerhalb des HTTP/1 &ndash; Protokolls ist es immer empfehlenswert, mehrere Dateien gleichen Typs in einer gr&ouml;&szlig;eren Datei zusammenzufassen, damit Requests gespart werden (Grigorik 2013, 241). Es stellt sich die Frage, ob diese Ma&szlig;nahme auch f&uuml;r das HTTP/2 &ndash; Protokoll ange-wendet werden muss. Theoretisch gesehen, sollte es f&uuml;r das HTTP/2 &ndash; Protokoll nicht wichtig sein, ob die Ressourcen zusammengefasst sind oder nicht, weil alle Ressourcen auf einzelne &bdquo;Frames&ldquo; aufgeteilt und miteinander  multiplexiert werden. Die Zusammenfassung von Dateien (inkl. Sprites f&uuml;r Bilder) hat viele Nachteile, die im Unterkapitel &bdquo;3.1. HTTP/1.1 &ndash; Optimierungs-techniken, Stand bisher&ldquo; aufgelistet sind. Aus diesem Grund ist es empfehlenswert, bei der Verwendung des HTTP/2 &ndash; Protokolls Dateien einzeln zu halten (Grigorik 2013, 243). </P
><P 

>Noch eine gew&ouml;hnliche Optimierung f&uuml;r das HTTP/1 &ndash; Protokoll ist das &bdquo;Ressourcen Inlining&ldquo; in der HTML Datei, wenn diese f&uuml;r die Erstdarstellung kritisch sind. Dadurch werden zus&auml;tzliche Requests gespart und Inhalte schnellstm&ouml;glich an den Client &uuml;bergeben. Dies hat &auml;hnliche Nachteile, wie die Zusammenfassung mehrerer Dateien (NGINX, Inc. 2015, 13). Da es innerhalb des HTTP/2 &ndash; Protokolls die &bdquo;Server Push&ldquo; Funktion gibt, wird diese Optimierung unn&ouml;tig und eher sch&auml;dlich sein. Mithilfe des &bdquo;Server Pushs&ldquo; k&ouml;nnen einzelne Dateien unabh&auml;ngig bearbei-tet, gecached und f&uuml;r jede Seite der Webapplikation benutzt werden. Au&szlig;erdem kann die Ver-wendung des &bdquo;Server Pushs&ldquo; sehr vorteilhaft unter mobilen Netzwerkverbindungen sein, weil dadurch viele Anfragen gespart werden (Grigorik 2013, 243).<I>  </I></P
><P 

><I>Serverseitige Optimierungstechniken </I></P
><P 

>Der Fokus des HTTP/2 &ndash; Protokolls liegt auf der Verbesserung des Datentransports, der Erm&ouml;g-lichung besseren Datendurchsatzes und der niedrigeren Latenz zwischen Client und Server. Au&szlig;er den zuvor beschriebenen m&ouml;glichen Optimierungstechniken ist es auch wichtig, m&ouml;g-lichst gute Bedingungen f&uuml;r die Funktionsweise von TCP und TLS einzurichten. Aus diesem Grund muss wenigstens auf drei serverseitige Einstellungen geachtet werden. Zuerst muss der Server f&uuml;r die TCP &ndash; Verbindung die &bdquo;cwnd&ldquo; &ndash; Startgr&ouml;&szlig;e von mind. 10 &bdquo;TCP &ndash; Segmenten&ldquo; un-terst&uuml;tzen (zur Begr&uuml;ndung siehe Kapitel &bdquo;3.1 HTTP/1.1 &ndash; Protokoll: Optimierungstechniken, Stand bisher&ldquo;).<FONT color="#FF0000"> <FONT color="#000000">Au&szlig;erdem muss der Server die TLS &ndash; Verschl&uuml;sselung mit Erweiterung von ALPN unterst&uuml;tzen, um zus&auml;tzliche &bdquo;Round-Trip Times&ldquo; zu vermeiden. Sodann muss der Server Mechanismen unterst&uuml;tzen, die beim &bdquo;TLS &ndash; Handshake &ldquo; die Latenz reduzieren (Grigorik 2013, 241-242).<B> </P
><P 

></B>In der aktuellen Arbeit liegt der Fokus auf Frontend &ndash; Optimierungstechniken. Deshalb werden dieselben serverseitigen Einstellungen (bez&uuml;glich oben beschriebenen serverseitigen Optimie-rungstechniken) sowohl f&uuml;r die Anwendung des HTTP/1.1- als auch f&uuml;r das HTTP/2 &ndash; Protokoll f&uuml;r die Test-Webapplikation angewendet. F&uuml;r Untersuchungen unter verschl&uuml;sselter Verbin-dung wurde die TLS &ndash; Verschl&uuml;sselung mit Erweiterung von ALPN verwendet. Die &bdquo;cwnd&ldquo; &ndash; Startgr&ouml;&szlig;e betr&auml;gt 16 &bdquo;TCP &ndash; Segmente&ldquo;. </P
><P 

><I>Serverseitige Anforderungen </I></P
><P 

>Um am Ende eine perfomante Webanwendungen haben zu k&ouml;nnen, muss man nicht nur ge-eignete Optimierungstechniken anwenden, sondern noch ganz genau aufpassen, wie gut der Server und der Client oben beschriebene Funktionen bearbeiten. Es ist schwierig, um die Funk-tionen des Clients zu beobachten und zu beeinflussen. Die Funktionsweise jedes Clients unter-scheidet sich je nach Entwicklung und Version. </P
><P 

>Der Webserver spielt bei der Ausarbeitung des HTTP/2 &ndash; Protokolls jedoch eine gro&szlig;e Rolle. Wie qualitativ die Funktionen des HTTP/2 &ndash; Protokolls verarbeitet werden, ob &bdquo;Server Push&ldquo; vorhanden ist, und wie gut die Multiplexierung der einzelnen &bdquo;Frames&ldquo; funktionieren wird, liegt an der Qualit&auml;t der Implementierung des Webservers (Grigorik 2013, 247). Aus diesem Grund muss der Webserver genau ausgew&auml;hlt werden: </P
><DL 

><DD 

>&#61630; Der HTTP/2 &ndash; Webserver muss die vom Client gesetzten Priorit&auml;ten der &bdquo;Streams&ldquo; ver-stehen, verarbeiten und in entsprechender Reihenfolge zur&uuml;ckliefern. </DD
><DD 

>&#61630; Der HTTP/2 &ndash; Webserver muss &bdquo;Server Push&ldquo; unterst&uuml;tzen. </DD
><DD 

>&#61630; Der HTTP/2 &ndash; Server muss mehrere Strategien der Implementierung des &bdquo;Server Pushs&ldquo; unterst&uuml;tzen. </DD
></DL
><P 

>(Grigorik 2013, 247). </P
><P 

>Wie der Webserver ausgew&auml;hlt wird, wird im Kapitel &bdquo;4. Vorbereitung der Tests und zur Teste-valuation&ldquo;<FONT color="#FF0000"> <FONT color="#000000">beschrieben.<I> </I></P
><P 

><I>Zusammenfassung: M&ouml;gliche Optimierungstechniken f&uuml;r das HTTP/2 </I><I>&ndash;</I><I> Protokoll </I></P
><P 

>Oben wurden m&ouml;gliche sowohl client- als auch serverseitige Optimierungstechniken unter dem HTTP/2 &ndash; Protokoll beschrieben. Es werden unter anderem einige Empfehlungen f&uuml;r clientsei-tige Techniken zur Performance &ndash; Optimierung vorgestellt, die unter dem neuen Protokoll ge-macht werden sollten. Im praktischen Teil dieser Masterarbeit wird darauf geachtet, ob es sich best&auml;tigt, dass einzeln gehaltene (nicht wie unter dem HTTP/1.1 - Protokoll zusammenge-fasste) Ressourcen f&uuml;r die Performanz der Webapplikation unter dem neuen Protokoll besser sind. </P
><P 

>Au&szlig;erdem wird im praktischen Teil dieser Masterarbeit darauf geachtet, wie gut der Webserver oben beschriebene Funktionen, wie Multiplexierung von &bdquo;Frames&ldquo;, &bdquo;Server Push&ldquo; und Priorisie-rung von gepuschten Ressourcen verarbeitet. Bei per &bdquo;Server Push&ldquo; &uuml;bergebenen Ressourcen ist es auch wichtig, dass diese nach dem ersten Aufruf der Webapplikation im Browser-Cache landen werden. Im praktischen Teil der Arbeit wird verglichen, wie die in diesem Kapitel be-schriebenen theoretischen Aussagen zur aktuellen Implementierung des neuen Protokolls pas-sen. </P
><P 

>  </P
><H1 

><FONT size="+1">4. Vorbereitung der Tests und zur Testevaluation </H1
><H2 

><FONT size="+1">4.1. Vorbereitung der Tests </H2
><P 

><FONT size="+1">Im aktuellen Unterkapitel wird beschrieben, wie die Tests aufgebaut und vorbereitet werden und wie der Server eingestellt wird. Deshalb werden in diesem Teil der Masterarbeit folgende Fragen bearbeitet: </P
><DL 

><DD 

>&#61630; Welche Webapplikation ist f&uuml;r die Untersuchung der Fragestellung der aktuellen Mas-terarbeit am besten geeignet? </DD
><DD 

>&#61630; Wie soll die Webapplikation f&uuml;r die zwei Protokolle HTTP/1.1 und HTTP/2 optimiert werden, damit man f&uuml;r jedes Protokoll bestm&ouml;gliche Ergebnisse erreichen kann? </DD
><DD 

>&#61630; Welcher Server und welche Serverversion eignen sich f&uuml;r die Tests? Was sind die wich-tigsten Voraussetzungen f&uuml;r den ausgew&auml;hlten Server? </DD
><DD 

>&#61630; Welche Ma&szlig;nahmen m&uuml;ssen f&uuml;r die Verwendung des HTTP/2 &ndash; Protokolls unternom-men werden? Wie soll der Server konfiguriert werden? </DD
></DL
><P 

><I>Welche Webapplikation ist f&uuml;r die Untersuchung der Fragestellung der aktuellen Masterarbeit </I><I>am besten geeignet? </I></P
><P 

>In der aktuellen Masterarbeit liegt der Fokus auf Frontend-Optimierungstechniken im Bereich des kritischen Rendering &ndash; Pfades. Welche Webapplikation kann am besten zum Testen ge-nommen werden, um die Wirkung dieser Techniken besser beobachten zu k&ouml;nnen? Aus der User Experience-Sicht ist es wichtig, dass nicht nur die Webapplikation selbst schnellstm&ouml;glich geladen wird, sondern auch die Reihenfolge, in der die einzelnen Komponenten dieser Webapplikation geladen werden, ist wichtig. Besonders wichtig sind die Komponenten, die sich innerhalb des Viewports (aktueller Viewport) befinden (Abb. 17) (Sexton 2015). </P
><P 

> </P
><IMG width="370" height="148"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_17.jpg" ><DL 

><DD 

><I>Abb. 17:</I><I> </I><I>Prim&auml;re und sekund&auml;re Komponenten einer Webseite innerhalb des Viewports (&lt;</I><A href="https://varvy.com/pagespeed/critical-render-path.html">
<I>https://varvy.com/pagespeed/critical-render-path.html</I></A>
<I>&gt;) </I></DD
></DL
><P 

>Der Browser kann unterschiedliche Priorit&auml;ten, je nach Typ der Ressource, setzen (Grigorik 2013, 172). Aus diesem Grund werden verschiedene Seitenkomponenten je nach Ressourcen-typ in einer unterschiedlichen Reihenfolge auf dem Viewport erscheinen. Deshalb wurde ent-schieden, eine Webapplikation mit vielen unterschiedlichen Ressourcentypen zur Untersu-chung zu nehmen. Dadurch kann besser beobachtet werden, in welcher Reihenfolge die </P
><P 

>Webapplikation geladen wird. Das Ziel ist nat&uuml;rlich, dass der erste Eindruck des Nutzers zur geladenen Webapplikation positiv bleiben wird. </P
><P 

>Es muss also eine Webapplikation entwickelt werden, die aus m&ouml;glichst vielen Ressourcenty-pen besteht, die auf dem Viewport des Browsers zusammen passen werden: CSS Dateien, Ja-vaScript Dateien, Bilder und Schriften. Vor 1,5 Jahren wurde eine Internetseite f&uuml;r die Master-studieng&auml;nge &bdquo;Audiovisuelle Medien&ldquo;, &bdquo;Medienwirtschaft&ldquo; und &bdquo;Unternehmenskommunika-tion&ldquo; der Hochschule der Medien von mehreren Studenten (inkl. der Verfasserin dieser Mas-terarbeit) entwickelt (Medienmaster.de 2016). Die Startseite verf&uuml;gt &uuml;ber oben beschriebene Kriterien. Diese Webapplikation wurde unter dem Content-Management-System &bdquo;Wordpress&ldquo; entwickelt. Im Rahmen dieser Masterarbeit wurde entschieden, statische Ressourcen zu neh-men, weil die Bearbeitungszeit dynamischer Sprachen (PHP) und st&auml;ndige Aufrufe der Daten-bank auf die in den Tests zu untersuchenden Parameter einen gro&szlig;en Einfluss haben kann. Aus diesem Grund wird nur die Struktur dieser Webapplikation &uuml;bernommen und in vielen Stellen zus&auml;tzlich angepasst. </P
><P 

>So wird eine statische Webapplikation zum Testen erstellt. Diese ist unter: <A href="http://im-im2.hdm-stuttgart.de/">
<FONT color="#0462C1">http://im-im2.hdm-stuttgart.de/</A>
<FONT color="#000000"> oder 141.62.110.42 erreichbar. Deren Startseite besteht aus mehreren Kompo-nenten (von oben nach unten): ein Logo, ein Men&uuml;, eine gro&szlig;geschriebene Zeile mit zwei un-terschiedlichen Schriftarten, ein JavaScript-Slider mit zwei gro&szlig;en Bildern und zwei verkleiner-ten Bildern (Thumbnails), zwei Reihen von Studienganglogos (Bilder mit daruntergeschriebe-nem Text) und ein Footer von Jahrgangssponsoren. Die Startseite beinhaltet insgesamt f&uuml;nf Schriftarten. </P
><P 

>Im Viewport eines Browsers am lokalen PC sind alle Seitenkomponenten bis zum Footer zu sehen. Dies bedeutet, dass bei der Untersuchung der Ladezeit der Webapplikation beobachtet werden kann, wie schnell und in welcher Reihenfolge unterschiedliche Ressourcentypen der Startseite geladen werden. </P
><P 

>Au&szlig;er der Startseite wurden noch zwei Unterseiten zum Testen hinzugef&uuml;gt. Diese sind &bdquo;do-zenten.html&ldquo; und &bdquo;dozenten2.html&ldquo;. Sie beinhalten das Logo, ein Men&uuml;, Navigationszeile und Bilder von Dozenten aus oben beschriebenen Masterstudieng&auml;ngen. Wenn man mit der Maus &uuml;ber einzelne Bilder f&auml;hrt, sieht man detaillierte Informationen zum einzelnen Dozenten. Die Unterseiten &bdquo;dozenten.html&ldquo; und &bdquo;dozenten2.html&ldquo; haben nur einen einzigen Unterschied: in &bdquo;dozenten.html&ldquo; werden alle Bilder der Dozenten durch zus&auml;tzliche CSS Dateien geladen und in &bdquo;dozenten2.html&ldquo; werden alle Bilder der Dozenten in der HTML Datei hinzugef&uuml;gt. Dies wurde gemacht, um zu schauen, ob die Ressourcenreihenfolge sich zwischen beiden Untersei-ten unterscheiden wird. Diese Seiten sind auch deshalb interessant f&uuml;r die Untersuchung, weil diese bildlastig sind. </P
><P 

><I>  </I></P
><P 

><I>Wie soll die Webapplikation f&uuml;r die zwei Protokolle HTTP/1.1 und HTTP/2 optimiert werden, </I><I>damit man f&uuml;r jedes Protokoll bestm&ouml;gliche Ergebnisse erreichen kann? </I></P
><P 

>Wie im theoretischen Teil beschrieben wurde, wurden oftmals f&uuml;r die Fronend-Optimierung unter dem HTTP/1.1 &ndash; Protokoll mehrere Dateien eines Datentypes in einer Datei zusammen-gefasst, um die Anzahl von Requests zu reduzieren. Da diese Zusammenfassung viele Nachteile mit sich bringt, wurde f&uuml;r das HTTP/2 &ndash; Protokoll empfohlen, die Dateien einzeln zu halten. </P
><P 

>Aus diesem Grund werden alle Ressourcen sowohl auf der Startseite als auch bei den Unter-seiten f&uuml;r jedes Protokoll unterschiedlich aufgeteilt. Von den Inhalten wird die Webapplikation gleich sein. </P
><P 

>Es gibt zwei CSS Dateien, die sowohl unter Verwendung des HTTP/1.1- als auch des HTTP/2 &ndash; Protokolls unver&auml;ndert benutzt werden: &bdquo;style.css&ldquo; und &bdquo;slider.css&ldquo;. Unter Verwen-dung des HTTP/1.1 &ndash; Protokolls entstehen noch drei CSS Dateien: &bdquo;animate.css&ldquo;, &bdquo;bootstrap.css&ldquo; und &bdquo;stylehttp1.css&ldquo;. Diese drei Dateien wurden bei Verwendung des HTTP/2 &ndash; Protokolls zus&auml;tzlich aufgeteilt: &bdquo;animate.css&ldquo; wurde auf &bdquo;animate1.css&ldquo; und &bdquo;ani-mate2.css&ldquo;aufgeteilt; &bdquo;bootstrap.css&ldquo; wurde auf &bdquo;bootstrap1.css&ldquo;, &bdquo;bootstrap2.css&ldquo; und &bdquo;bootstrap3.css&ldquo; aufgeteilt; &bdquo;stylehttp1.css&ldquo; wurde auf &bdquo;stylehttp2.css&ldquo;, &bdquo;menu.css&ldquo;, &bdquo;footer.css&ldquo; und &bdquo;team.css&ldquo; oder &bdquo;team2.css&ldquo; f&uuml;r &bdquo;dozenten.html&ldquo; und &bdquo;dozenten2.html&ldquo; aufgeteilt. So ent-stehen bei Verwendung des HTTP/1.1 &ndash; Protokolls f&uuml;nf CSS Dateien und bei Verwendung des HTTP/2 &ndash; Protokolls insg. 12 CSS Dateien. </P
><P 

>Die &bdquo;bootstrap.min.js&ldquo; JavaScript Datei wird auf einzelne Bootstrap-Komponenten aufgeteilt und zus&auml;tzlich minimiert, sodass unter Verwendung des HTTP/1.1 &ndash; Protokolls eine JavaScript Datei benutzt wird und unter Verwendung des HTTP/2 &ndash; Protokolls 11 Dateien benutzt werden. Diese Ma&szlig;nahme ist f&uuml;r die eigentliche Entwicklung nicht n&ouml;tig, hier wird damit nur ein Fall mit vielen JavaScript Dateien simuliert. F&uuml;r beide Protokolle werden noch vier JavaScript Dateien f&uuml;r die Webapplikation benutzt: &bdquo;jquery.min.js&ldquo; und auf der Startseite noch: &bdquo;jssor.slider.mini.js&ldquo;, &bdquo;slider.js&ldquo; und &bdquo;wow.min.js&ldquo;. </P
><P 

>F&uuml;r die Unterseiten &bdquo;dozenten.html&ldquo; und &bdquo;dozenten2.html&ldquo; werden zus&auml;tzlich die Bilder unter-schiedlich aufgeteilt. Unter Verwendung des HTTP/1.1 &ndash; Protokolls werden alle kleinen Bilder in einer Datei (Sprite) zusammengefasst, w&auml;hrenddessen unter Verwendung des HTTP/2 &ndash; Pro-tokolls alle Bilder als einzelne kleine Bilder gehalten werden. </P
><P 

><I>Welcher Server und welche Serverversion eignen sich f&uuml;r die Tests? Was sind die wichtigsten </I><I>Voraussetzungen f&uuml;r den ausgew&auml;hlten Server? </I></P
><P 

>Es gibt mehrere Webserver, die das HTTP/2 &ndash; Protokoll implementieren (Thomson/Nottingham 2016). In den ersten Schritten dieser Masterarbeit wird &uuml;berlegt, welcher Webserver sich am besten anwenden l&auml;sst. Daf&uuml;r wird geschaut, welche Webserver am h&auml;ufigsten verwendet wer-den. Abb. 18 veranschaulicht den prozentualen Anteil der sechs popul&auml;rsten Webbrowser. Es </P
><P 

>kann von Vorteil sein, um den Server zu nehmen, an dem schon Tests und Untersuchungen zur Verwendung des HTTP/2 &ndash; Protokolls durchgef&uuml;hrt wurden. </P
><P 

>  </P
><IMG width="287" height="134"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_18.jpg" ><DL 

><DD 

><I>Abb. 18:</I><I> </I><I>Prozentualer Anteil der meist verwendeten Webserver, Stand: 17.08.2016 (&lt;</I><A href="https://w3techs.com/technologies/overview/web_server/all">
<I>https://w3techs.com/technologies/overview/web_server/all</I></A>
<I>&gt;) </I></DD
></DL
><P 

>Bei der Suche nach existierenden Beispielen und Implementierungen des HTTP/2 &ndash; Protokolls werden oftmals Testbeispiele unter dem &bdquo;H2O&ldquo;-Server (DeNA Co., Ltd. 2015) oder dem &bdquo;NGINX&ldquo;-Server (NGINX, 2016) gefunden. </P
><P 

>Im Fokus dieser Masterarbeit liegt u.a. die Untersuchung der &bdquo;Server Push&ldquo; &ndash; Funktion des HTTP/2 &ndash; Protokolls. Deshalb ist die Anwesenheit dieser Funktion ein wichtiges Kriterium zur Serverwahl. In der elektronischen Ausgabe &bdquo;HTTP/2 for Web Application Developers&ldquo; des &bdquo;NGINX&ldquo;-Servers hei&szlig;t es am 16.09.2015, dass die aktuelle Serverimplementierung (NGINX Ver-sion 1.9.5) den &bdquo;Server Push&ldquo; nicht unterst&uuml;tzt (NGINX, 2015). Nach fast einem Jahr hat sich dieses Status nicht ver&auml;ndert. Aus diesem Grund kann der &bdquo;NGINX&ldquo;-Server im Rahmen dieser Masterarbeit nicht genommen werden. </P
><P 

>Obwohl ein paar Tests und Untersuchungen des &bdquo;H2O&ldquo;-Webservers gefunden wurden, wurde auf Grund der mangelnden Erfahrung mit diesem Server und einer nicht ausf&uuml;hrlichen Doku-mentation dieses Servers ein anderer Server genommen. </P
><P 

>Aus Abb. 18 ist zu sehen, dass der Apache-Server der meist verwendete Webserver ist, der jedes zweite Mal verwendet wird. Au&szlig;erdem gab es schon ein wenig Erfahrung mit diesem Server. Zu der Zeit, als der Server ausgew&auml;hlt wurde, wurden keine &ouml;ffentlichen Tests, Beispiele oder Untersuchungen des HTTP/2 &ndash; Protokolls unter dem Apache-Server gefunden. F&uuml;r die HTTP/2 &ndash; Implementierung ist das Apache-Modul &bdquo;mod_http2&ldquo; verantwortlich. Dieses stellt un-ter anderem &bdquo;Server Push&ldquo; zur Verf&uuml;gung. Aus diesen Gr&uuml;nden wurde entschieden, den Apache-Webserver als Webserver f&uuml;r die Untersuchungen zu nehmen. </P
><P 

><I>Welche Ma&szlig;nahmen m&uuml;ssen f&uuml;r die Verwendung des HTTP/2 </I><I>&ndash;</I><I> Protokolls unternommen wer-</I><I>den? Wie soll der Server konfiguriert werden? </I></P
><P 

>Das Apache-Modul &bdquo;mod_http2&ldquo; ist nur ab der Apache-Version 2.4.17 verf&uuml;gbar. Allerdings ist zu beachten, dass sich zum Zeitpunkt dieser Masterarbeit das Modul im Status &bdquo;experimentell&ldquo; befand. Dies bedeutet, dass sich sein Verhalten, seine Direktiven und Standardeinstellungen von Version zu Version noch stark &auml;ndern k&ouml;nnen (Apache Software Foundation 2016a).<FONT color="#0462C1"> </P
><P 

><FONT color="#000000">Welche Version des Apache-Servers wird genommen? Die Implementierung des HTTP/2 &ndash; Pro-tokolls ist ab der Apache-Version 2.4.17 verf&uuml;gbar. Es ist nun empfehlenswert, um neuere Ver-sionen zu nehmen, weil einige Funktionen und Direktiven verbessert und erg&auml;nzt wurden (Apache Software Foundation 2016b). Die Serverinstallation und Serverkonfiguration f&uuml;r die Tests wurde im Mai 2016 vollzogen. Damals war die Apache-Version 2.4.21 gerade erschienen. Aus Gr&uuml;nden m&ouml;glicher Instabilit&auml;t der neuesten Version wurde die n&auml;chst&auml;ltere Version des Apache-Servers 2.4.20 bevorzugt.  </P
><P 

>Um Apache 2.4.20 installieren zu k&ouml;nnen, ben&ouml;tigt man ein entsprechendes Betriebssystem, das genau diese Serverversion unterst&uuml;tzt. Wenn diese Version manuell installiert und konfi-guriert wird, w&uuml;rden keine automatischen Updates durchgef&uuml;hrt. Falls Sicherheits- oder Funk-tionsl&uuml;cken in der ausgew&auml;hlten Version auftreten w&uuml;rden, m&uuml;sste man diese auch manuell l&ouml;sen k&ouml;nnen. </P
><P 

>Deshalb bestand der n&auml;chste Schritt darin, das passende Betriebssystem f&uuml;r die m&ouml;glichst neu-este Apache-Version zu finden. Es standen nur &bdquo;Linux&ldquo;- Betriebssysteme zur Diskussion. Das Betriebssystem wurde mithilfe der Liste der meist verwendeten &bdquo;Linux&ldquo;-Betriebssysteme (Dis-troWatch 2016) ausgew&auml;hlt. Es gab zwei wichtige Auswahlkriterien zum Betriebssystem: gro&szlig;e Community und detaillierte Endanwenderdokumentation. Nach der Recherche zur Unterst&uuml;t-zung neuerer Apache-Versionen wurde festgestellt, dass nur wenige &bdquo;Linux&ldquo;-Betriebssysteme oben beschriebenen Kriterien entsprechen. Es wurden nur zwei solche Betriebssysteme gefun-den: &bdquo;Fedora&ldquo; (Red Hat, Inc. and others 2015) und sp&auml;ter &bdquo;openSUSE&ldquo; (SUSE LLC 2015). </P
><P 

>Die erste Wahl fiel auf  &bdquo;Fedora&ldquo; mit Apache-Version 2.4.18. Nach kurzer Zeit wurde aber Fest-gestellt, dass in der Apache-Version 2.4.20 viele Funktionen bearbeitet und erg&auml;nzt wurden (Apache Software Foundation 2016b). Das Betriebssystem &bdquo;Fedora&ldquo; hat aber diese Apache-Version nicht unterst&uuml;tzt. Dann wurde das Betriebssystem &bdquo;openSUSE&ldquo; unter Version &quot;20160907&quot; gefunden, das die ben&ouml;tigte Apache-Version unterst&uuml;tzt. Diese wurde als Server f&uuml;r die Tests genommen. </P
><P 

>Die Unterst&uuml;tzung des HTTP/2 &ndash; Protokolls ist schon in Apache ab Version 2.4.17 integriert (Eissing 2015). Allerdings muss man beachten, dass sich nach der Installation des Apache-Ser-vers das Modul zum HTTP/2 &ndash; Protokoll auch in der Liste aller installierten Module befindet: APACHE_MODULES=&quot;http2, <I>andere Module</I>&ldquo;. Alle Module sind in der Konfigurationsdatei &bdquo;apache2&ldquo; aufgelistet. </P
><P 

>Das Modul &bdquo;mod_http2&ldquo; basiert auf der &bdquo;Nghttp2&ldquo;-Bibliothek, die die Funktionsweise des HTTP/2 &ndash; Protokolls implementiert (Apache Software Foundation 2016a), (Tsujikawa 2016). Dies bedeutet, dass zus&auml;tzlich noch diese Bibliothek mit einer m&ouml;glichst neuen Version auf dem Server installiert werden muss. </P
><P 

>Das HTTP/2 &ndash; Protokoll fordert die verschl&uuml;sselte Netzwerkverbindung nicht, deshalb sind zwei serverseitige Anwendungen m&ouml;glich: h2(HTTP/2 &ndash; Protokoll &uuml;ber verschl&uuml;sselte Netzwerkver-bindung - TLS) und h2c (&uuml;ber unverschl&uuml;sselte Netzwerkverbindung - TCP) (Apache Software Foundation 2016a). Gleichzeitig erlauben die Browser die Verwendung des HTTP/2 &ndash; Protokolls nur &uuml;ber TLS (Grigorik 2015, 21), (NGINX, Inc. 2015, 3). Daf&uuml;r ben&ouml;tigt man eine TLS-Bibliothek mit der Erweiterung &bdquo;Application-Layer Protocol Negotiation&ldquo; (kurz: ALPN, siehe genaue Defi-nition des ALPNs im Kapitel &bdquo;3.3 Vorstellung des HTTP/2 &ndash; Protokolls&ldquo;). Soweit bei der TLS-Bibliothek das ALPN nicht unterst&uuml;tzt wird, wird der Client (Browser) die Kommunikation nur unter dem HTTP/1.1 &ndash; Protokoll erlauben (Eissing 2015). </P
><P 

>Um das HTTP/2 &ndash; Protokoll unter verschl&uuml;sselter Verbindung zu erlauben, muss man &bdquo;Protocols h2 http/1.1&ldquo; innerhalb der Konfigurationsdatei des Protokolls einf&uuml;gen. Um das HTTP/2 &ndash; Pro-tokoll unter unverschl&uuml;sselter Verbindung zu erlauben, muss man &bdquo;Protocols h2 h2c http/1.1&ldquo; ebenso innerhalb der Konfigurationsdatei des HTTP/2 &ndash; Protokolls einf&uuml;gen. Alternativ k&ouml;nnen diese Regeln auch innerhalb des &lt;VirtualHost&gt; geschrieben werden (Eissing 2015).  </P
><P 

>All diese Schritte m&uuml;ssen gemacht werden, um das HTTP/2 &ndash; Protokoll anwenden zu k&ouml;nnen. Nun sollen noch ein paar Worte &uuml;ber die Konfiguration des Apache-Servers unter dem Be-triebssystem &bdquo;OpenSuse&ldquo; geschrieben werden. </P
><P 

>Die Apache Konfigurationsdateien befinden an zwei Orten: </P
><DL 

><DD 

>&#61630; /etc/sysconfig/apache2 </DD
></DL
><P 

>In dieser Datei befindet sich die globale Konfiguration des Apache-Servers, wie Module; zus&auml;tzliche Konfigurationsdateien zum Einschlie&szlig;en; Flags, mit denen der Server ge-startet werden muss und die in der Kommandozeile hinzugef&uuml;gt werden m&uuml;ssen (Suse 2013). </P
><DL 

><DD 

>&#61630; /etc/apache2/&hellip; </DD
></DL
><P 

>In diesem Ordner befinden sich alle Konfigurationsdateien des Apache-Servers. Jeder Ordner und jede Datei beinhaltet mehrere Konfigurationsoptionen (Suse 2013). </P
><P 

>Manche Ordner und Dateien des Ordners &bdquo;apache2&ldquo; unter dem Pfad &bdquo;/etc/apache2&ldquo; werden detaillierter dargestellt. Die Datei &bdquo;httpd.conf&ldquo; ist die Hauptkonfigurationsdatei des Apache-Servers, die haupts&auml;chlich globale Einstellungen einbezieht. Es wird nicht empfohlen, um &Auml;n-derungen innerhalb dieser Datei durchzuf&uuml;hren (Suse 2013). </P
><P 

>Alle Host-Spezifizierten Einstellungen m&uuml;ssen sich innerhalb der Hostkonfiguration befinden (unter dem Ordner &bdquo;/etc/apache2/vhosts.d&ldquo;). Dieser Ordner beinhaltet ein Template f&uuml;r den Virtual Host mit und ohne SSL. Jede Datei mit dem Dateityp &bdquo;.conf&ldquo;, die sich innerhalb dieses Ordners befindet, wird in die Apache-Konfiguration aufgenommen (Suse 2013).<FONT color="#0462C1"> </P
><P 

><FONT color="#000000">Innerhalb des Ordners &bdquo;conf.d&ldquo; unter dem Pfad &bdquo;/etc/apache2/conf.d&ldquo; k&ouml;nnen sich alle Dateien zur Konfiguration einzelner Module befinden. Diese k&ouml;nnen in einem bestimmten Virtual Host </P
><P 

>miteinbezogen werden (Suse 2013). In diesem Ordner befindet sich z.B. die Konfigurationsdatei &bdquo;http2.conf&ldquo; zum Modul &bdquo;mod_http2&ldquo; und die Konfigurationsdatei zum Clientseitigen Cache &bdquo;mod_expires.conf&ldquo;. Diese und alle anderen Dateien in diesem Ordner wurden im Rahmen die-ser Masterarbeit erstellt und konfiguriert. </P
><P 

>Damit eine verschl&uuml;sselte TLS &ndash; Verbindung aufgebaut werden kann, muss man zuerst dem Server ein SSL &ndash; Zertifikat und den dazugeh&ouml;rigen Schl&uuml;ssel &uuml;bergeben. In die Datei zur Kon-figuration des &lt;VirtualHosts&gt;: &bdquo;vhosts.d&ldquo; befinden sich zwei Pfade, einer zum SSL &ndash; Zertifikat und einer zum SSL &ndash; Schl&uuml;ssel: </P
><P 

>SSLCertificateFile /etc/apache2/ssl.crt/server.crt </P
><P 

>SSLCertificateKeyFile /etc/apache2/ssl.key/server.key </P
><P 

> Im Vergleich zum &ouml;ffentlichen SSL &ndash; Zertifikat, m&uuml;ssen begrenzte Zugriffsrechte zum geheimen SSL &ndash; Schl&uuml;ssel erstellt werden. </P
><H2 

><FONT size="+1">4.2. Vorbereitung zur Testevaluation </H2
><P 

><FONT size="+1">Nachdem alle zu untersuchenden Parameter von &bdquo;Navigation Timing API&ldquo; und &bdquo;Ressource Ti-ming API&ldquo; definiert wurden, kann die Webapplikation unter unterschiedlichen Einstellungen getestet werden.  </P
><P 

>In diesem Unterkapitel wurden folgende Fragen ausgearbeitet: </P
><DL 

><DD 

>&#61630; Welches Tool k&ouml;nnte als Hilfsmittel f&uuml;r die Testausf&uuml;hrung dienen?  </DD
><DD 

>&#61630; Anwendung des &bdquo;Webpagetest.org&ldquo; &ndash; Tools. </DD
><DD 

>&#61630; Wie werden die zur Untersuchung ausgew&auml;hlten Parameter berechnet? </DD
><DD 

>&#61630; Wie werden die Tests ausgewertet?  </DD
><DD 

>&#61630; Wie kann die Funktionsweise des HTTP/2 &ndash; Protokolls am lokalen PC untersucht wer-den? </DD
></DL
><P 

><I>Welches Tool k&ouml;nnte als Hilfsmittel f&uuml;r die Testausf&uuml;hrung dienen? </I></P
><P 

>Wie im Kapitel &bdquo;2. Der kritische Rendering &ndash; Pfad und seine wichtigsten Komponenten&ldquo; er-w&auml;hnt wurde, verf&uuml;gt fast jeder moderne Browser sowohl &uuml;ber die &bdquo;Navigation Timing API&ldquo; als auch &uuml;ber die &bdquo;Ressource Timing API&ldquo;. Deshalb ist es m&ouml;glich, die zur Untersuchung ausge-w&auml;hlten Parameter am lokalen PC aufzunehmen. Neben den Parametern aus der &bdquo;Navigation Timing API&ldquo; und der &bdquo;Ressource Timing API&ldquo; ist auch ein Messwert wichtig, der den Zeitpunkt misst, zu dem erste Pixel auf dem Viewport erscheinen. Es w&auml;re auch interessant, einen visuel-len Vergleich zu machen, mittels dem die Reihenfolge der geladenen Ressourcen zu sehen ist. Daf&uuml;r k&ouml;nnen sogenannte &bdquo;Screenshots&ldquo; dienen, die in der Gr&ouml;&szlig;e des Viewports das Laden der Webapplikation aufnehmen. Dadurch entsteht eine Reihe von Bildern, die das visuelle Laden der Webapplikation veranschaulicht. </P
><P 

>Wenn man in den Tests zus&auml;tzlich die Parameter unter mobilen Netzwerkverbindungen unter-suchen m&ouml;chte, gibt es bei manchen Browsern die M&ouml;glichkeit, um die Parameter f&uuml;r die Band-breite zum Hoch- und Herunterladen und die Latenz einzustellen. Dadurch wird eine be-stimmte Netzwerkverbindung simuliert. Meistens befinden sich diese Einstellungen in den Ent-wicklertools des Browsers. </P
><P 

>Allerdings muss man beachten, dass nicht jeder Browser alle diese notwendigen Funktionen besitzt. Zum Beispiel sind im Browser &bdquo;Mozilla Firefox&ldquo; die Funktionen zur Aufnahme der Screenshots und der Simulation der Netzwerkverbindung nicht verf&uuml;gbar. Um zuverl&auml;ssigere Ergebnisse zu bekommen, m&uuml;ssen die Parameter mehrmals getestet werden. Aus dem Browser am lokalen PC kann man die Parameter der &bdquo;Navigation Timing API&ldquo; und der &bdquo;Ressource Timing API&ldquo; in der *.har Datei speichern. Diese kann zwar ausgewertet werden, aber bei mehreren Tests w&uuml;rde die &Uuml;bertragung der einzelnen Parameter zu viel Zeit in Anspruch nehmen. </P
><P 

>Deshalb wurde entschieden, das online Tool: &bdquo;Webpagetest.org&ldquo; (WebPagetest 2016a) zu be-nutzen. Dieses ist ein sehr umfangreiches Tool f&uuml;r die Web &ndash; Performance Analyse, das &uuml;ber viele Funktionen verf&uuml;gt, die f&uuml;r die clientseitige Performance &ndash; Optimierung hilfreich sein k&ouml;n-nen. Mit dem &bdquo;Webpagetest.org&ldquo; &ndash; Tool ist es m&ouml;glich, um alle im Kapitel &bdquo;2. Der kritische Ren-dering &ndash; Pfad und seine wichtigsten Komponenten&ldquo; beschriebenen Parameter zu untersuchen. Unter anderem kann man mithilfe des &bdquo;Webpagetest.org&ldquo; &ndash; Tools (Webpagetest 2016a) mit bestimmten Parametern die Webapplikation mehrmals in einem Browser aufrufen. Wenn die Tests fertig sind, werden alle Informationen zum Ressourcenwasserfall, der &bdquo;Navigation Timing API&ldquo;, der &bdquo;Ressource Timing API&ldquo; und der &bdquo;*.har&ldquo; Datei f&uuml;r den gesamten Zeitraum zur Verf&uuml;-gung gestellt. Au&szlig;erdem kann man aus den aufgenommenen Screenshots sehen, wann und was im Browserfester angezeigt wird. </P
><P 

><I>Einstellungen des &bdquo;Webpagetest.org&ldquo;</I><I> </I><I>&ndash;</I><I> Tools </I></P
><P 

>Bei dem &bdquo;Webpagetest.org&ldquo; &ndash; Tool gibt es eine gro&szlig;e Auswahl an Einstellungen. Zur Stan-dardeinstellung geh&ouml;ren die Lokalisierung und der Browser, aus denen die Webapplikation aufgerufen werden soll. Im Rahmen dieser Masterarbeit wurde entschieden, die Webapplika-tion vom Ort &bdquo;Frankfurt, Germany&ldquo; aufzurufen. An diesem Ort stehen drei Browser zur Verf&uuml;-gung: &bdquo;Mozilla Firefox&ldquo; mit Version 47.0, &bdquo;Google Chrome&ldquo; mit Version 52.0 und &bdquo;Microsoft IE11&ldquo;. Innerhalb des &bdquo;Webpagetest.org&ldquo; &ndash; Tools im Bereich &bdquo;Advanced Settings&ldquo; im ersten Tab &bdquo;Test Settings&ldquo; kann man die Netzwerkverbindung ausw&auml;hlen (es gibt mehrere mit der Stan-dardkonfiguration) oder man kann eine neue hinzuf&uuml;gen und diese zum Testen benutzen. Im Rahmen dieser Masterarbeit wurde entschieden, die Tests bei einer Kabel-Netzwerkverbindung unter Standardkonfigurationen zu belassen. Diese hat folgende Parameter: </P
><P 

>Bandbreite zum Herunterladen: 5000 Kbit/s </P
><P 

>Bandbreite zum Hochladen: 1000 Kbit/s </P
><P 

>Latenz: 28 ms </P
><P 

> Um ausgew&auml;hlte Parameter und das Verhalten der Webapplikation beim Laden genauer un-tersuchen zu k&ouml;nnen, wurde entschieden, die Webapplikation auch unter mobilen Netzwerken zu testen.  </P
><P 

>Eine entscheidende Rolle f&uuml;r das Laden der Webseite spielt die Latenz. Es wurden Perfor-mance &ndash; Tests gemacht, in denen untersucht wurde, wie gro&szlig; der Einfluss der Bandbreite und der Latenz auf die Gesamtladezeit (&bdquo;Load Time&ldquo;) der Webseite ist (Abb. 19). Im ersten Test aus der Abb. 19 wird die Latenz fixiert und die Bandbreite wurde von 1 Mbps bis 10 Mbps inkre-mentell erh&ouml;ht. Man sieht, dass sich die Ladezeit der Webseite bis 5 Mbps &auml;ndert. Danach spielt die Bandbreite  kaum eine Rolle mehr bei der Ladezeit. Anders ist die Situation mit der Latenz, mit deren Zunahme auch die Ladezeit proportional w&auml;chst (Grigorik 2013, 177). </P
><P 

> </P
><IMG width="433" height="218"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_19.jpg" ><DL 

><DD 

><I>Abb. 19:</I><I> </I><I>Gesamtladezeit der Webseite unter Einfluss von Bandbreite (oben) und Latenz (unten). (Grigorik 2013, 177) </I></DD
></DL
><P 

>Da die mobile 3G &ndash; Netzwerkverbindung &uuml;ber eine gro&szlig;e Latenz verf&uuml;gt, wurde entschieden, diese f&uuml;r die Untersuchungen unter mobilen Netzwerken zu nehmen. Deren Werte wurden innerhalb Deutschlands genauer untersucht. In Deutschland gibt es vier Netzbetreiber: Tele-kom, Vodafone, E-Plus und O2. Es werden die Werte f&uuml;r die Bandbreite zum Hoch- und Her-unterladen und die Latenz der einzelnen Netzbetreiber ermittelt. F&uuml;r die Parameteruntersu-chung unter 3G-Netzwerken wurde dann der Mittelwert von allen Werten der Netzbetreiber genommen und innerhalb des &bdquo;Webpagetest.org&ldquo; &ndash; Tools eingestellt. </P
><P 

>  </P
><P 

>Werte f&uuml;r 3G-Netzwerkverbindung innerhalb Deutschlands wurden nach OpenSignal (2016a) in Tabelle 4 dargestellt. </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Provider </P
></TD
><TD  
 valign="top"
><P 

>Bandbreite zum Herunterladen </P
></TD
><TD  
 valign="top"
><P 

>Bandbreite zum Hochladen </P
></TD
><TD  
 valign="top"
><P 

>Latenz </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Telekom (OpenSignal 2016a) </P
></TD
><TD  
 valign="top"
><P 

>3,7 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>0,9 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>338 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Vodafone (OpenSignal 2016a) </P
></TD
><TD  
 valign="top"
><P 

>4,8 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>1,5 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>263 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>E-Plus (OpenSignal 2016c) </P
></TD
><TD  
 valign="top"
><P 

>4,4 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>1,2 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>251 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>O2 (OpenSignal 2016d)  </P
></TD
><TD  
 valign="top"
><P 

>3,7 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>1,2 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>377 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Mittelwert </P
></TD
><TD  
 valign="top"
><P 

>4,5 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>1,2 Mb/s </P
></TD
><TD  
 valign="top"
><P 

>307,25 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 4:</I><I> </I><I>3G- Netzwerkverbindungen in Deutschland, Stand: 25.07.2016 </I></DD
></DL
><P 

>Nachdem die Netzwerkverbindung innerhalb des &bdquo;Webpagetest.org&ldquo; &ndash; Tools eingestellt wird, kann festgelegt werden, wie viele Tests innerhalb eines Durchgangs gemacht werden sollen (max. 9 Webseitenaufrufe pro ein Durchgang m&ouml;glich). Im Rahmen dieser Masterarbeit wurde entschieden, f&uuml;r jede Untersuchung drei Durchl&auml;ufe mit jeweils neun Tests zu machen. D.h., dass f&uuml;r jeden zu untersuchenden Fall die Webapplikation 27 Mal unter gleichen Bedingungen aufgerufen wurde. </P
><P 

>Beim n&auml;chsten Parameter des &bdquo;Webpagetest.org&ldquo; &ndash; Tools kann eingestellt werden, ob die Webapplikation bei jedem Test nur ein Mal (First View) oder zwei Mal (Repeat View) aufgerufen werden soll. Beim zweiten Aufruf sieht man, welche Ressourcen nicht im Browser Cache gela-den wurden. </P
><P 

>Wenn man beim n&auml;chsten Parameter die Option &bdquo;Capture Video&ldquo; ausw&auml;hlt, kann man nachdem der Testdurchgang fertig ist, Screenshots aus dem simulierten Viewport anschauen. </P
><P 

>Beim Parameter &bdquo;Label&ldquo; kann man den Namen f&uuml;r den Testdurchgang vergeben. </P
><P 

>Es gibt noch viele Einstellungen, die innerhalb dieses Tools angewendet werden k&ouml;nnen. Oben wurden nun alle Parameter beschrieben, die f&uuml;r die Tests in dieser Masterarbeit relevant sind. </P
><P 

><I>Woher kann man die f&uuml;r die Auswertung ben&ouml;tigten Parameter bekommen? </I></P
><P 

>Nachdem der Test mithilfe des &bdquo;Webpagetest.org&ldquo; - Tools durchgef&uuml;hrt wurde, hat man die M&ouml;glichkeit, um die aufgenommenen Parameter zu speichern. Es gibt drei Dateien, die daf&uuml;r zur Verf&uuml;gung stehen: &bdquo;Page Data.csv&ldquo;, die alle Parameter der &bdquo;Navigation Timing API&ldquo; bein-haltet; &bdquo;Object Data.csv&ldquo;, die alle Parameter der &bdquo;Ressource Timing API&ldquo; beinhaltet und &bdquo;HTTP Archive (.har)&ldquo;, die alle Informationen &uuml;ber HTTP-Transaktionen gespeichert hat. Soweit man vor dem Test den Testparameter &bdquo;Capture Video&ldquo; ausgew&auml;hlt hat, hat man die M&ouml;glichkeit bei der Auswahl eines einzelnen Tests (z.B. Run 1) die aufgenommenen Screenshots zusammen mit dem Ressourcenwasserfall auf einer Timeline zu beobachten. Alle aufgenommenen </P
><P 

>Screenshots kann man auch speichern. Au&szlig;erdem besteht die M&ouml;glichkeit, auf der Basis von Screenshots ein Video generieren zu lassen. </P
><P 

>Zus&auml;tzlich kann man die durchgef&uuml;hrten Tests innerhalb des &bdquo;Webpagetest.org&ldquo; &ndash; Tools mitei-nander vergleichen. Dies ist sehr n&uuml;tzlich, wenn man mehrere Eins&auml;tze miteinander vergleichen m&ouml;chte (z.B. Einsatz mit und ohne &bdquo;Server Push&ldquo;). Dadurch kann man Unterschiede innerhalb des Ressourcenwasserfalls und der aufgenommenen Screenshots deutlicher sehen.  </P
><P 

>Alle oben beschriebenen Dateien wurden f&uuml;r jeden durchgef&uuml;hrten Test gespeichert und sind auf dem beigelegten Datentr&auml;ger einsehbar. Um die Testdurchg&auml;nge mit ihren dazugeh&ouml;rigen Tests unterscheiden zu k&ouml;nnen, sind die Dateien mit den Ziffern von 1 bis 3 markiert. </P
><P 

><I>Wie werden die zu untersuchenden Parameter berechnet? </I></P
><P 

>Au&szlig;er den Parametern der &bdquo;Navigation Timing API&ldquo; und der &bdquo;Ressource Timing API&ldquo; verf&uuml;gen die vom &bdquo;Webpagetest.org&ldquo; &ndash; Tool erstellten Dateien &bdquo;Page Data.csv&ldquo; und &bdquo;Object Data.csv&ldquo; noch &uuml;ber weitere Zusatzinformationen. Manchmal speichert das &bdquo;Webpagetest.org&ldquo; &ndash; Tool zus&auml;tzliche Metriken, die auch f&uuml;r die Untersuchung der Ladezeit der Webapplikation hilfreich sind. Z.B. kann man im Dokument &bdquo;Page Data.csv&ldquo; den Parameter &bdquo;Start Render&ldquo; finden, der ausgegeben wird, sobald erste Pixel auf dem Viewport erscheinen werden. Dieser Parameter ist eine eigene Metrik des &bdquo;Webpagetest.org&ldquo; - Tools (Viscomi et al. 2014, 15). </P
><P 

>&bdquo;Load Time&ldquo; ist auch eine eigene Metrik des &bdquo;Webpagetest.org&ldquo; - Tools. Diese misst die Zeit, zwischen dem ersten an den Server gesendeten Request und der Ausgabe des &bdquo;load&ldquo;-Events durch den Browser. Diese Metrik ist auch als &bdquo;domComplete&ldquo;-Parameter aus der &bdquo;Navigation Timing API&ldquo; bekannt (Viscomi et al. 2014, 11). </P
><P 

>Wenn man den Parameter &bdquo;Time To First Byte&ldquo; aus &bdquo;Page Data.csv&ldquo; und &bdquo;Object Data.csv&ldquo; ver-gleicht, ist zu sehen, dass diese sich um einige Millisekunden unterscheiden. F&uuml;r die Testaus-wertung wird der Parameter aus &bdquo;Object Data.csv&ldquo; genommen, weil der Parameter &bdquo;Time To First Byte&ldquo; in dieser Datei f&uuml;r jede einzelne Ressource (inkl. HTML Datei) gespeichert ist. </P
><P 

>&bdquo;Bytes Out&ldquo; wurde als Metrik weder in der Dokumentation des &bdquo;Webpagetest.org&ldquo; &ndash; Tools (WebPagetest 2016b) noch bei Viscomi et al. 2014 beschrieben. Aber f&uuml;r den Parameter &bdquo;Bytes In&ldquo; hei&szlig;t es, dass dieser zeigt, wie viele Bytes innerhalb der Sitzung der Client vom Server be-kommen hat (Viscomi et al. 2014, 11). Deshalb kann man davon ausgehen, dass der Parameter &bdquo;Bytes Out&ldquo; anzeigt, wie viele Bytes vom Client gesendet werden, um Ressourcen anzufragen. Diese Metrik wird vom &bdquo;Object Data.csv&ldquo; f&uuml;r einzelne Dateien genommen, um zu schauen, wie viele Anfragebytes ausgegeben werden. Diese Metrik k&ouml;nnte Interessant sein, wenn der Einsatz von &bdquo;Server Push&ldquo; getestet wird. </P
><P 

>Der Parameter &bdquo;domInteractive&ldquo; ist nur innerhalb der Datei &bdquo;HTTP Archive (.har)&ldquo; zu treffen. Um die DOM-Erstellung berechnen zu k&ouml;nnen, wird die Differenz zwischen dem Parameter &bdquo;domI-nteractive&ldquo; und dem Parameter &bdquo;Start Time&ldquo; genommen. Der Parameter &bdquo;Start Time&ldquo; befindet </P
><P 

>sich innerhalb der Datei &bdquo;Object Data.csv&ldquo; und gibt f&uuml;r jede einzelne Ressource die Zeit an, zu der der Request gesendet wurde.<I> </I></P
><P 

>&bdquo;Visual Progress&ldquo; ist eigentlich kein Parameter. Dies ist eine Grafik, die zeigt, wie schnell die Inhalte der Webapplikation (prozentual gesehen) auf dem Viewport erscheinen. Um den &bdquo;Visual Progress&ldquo; sehen zu k&ouml;nnen, muss man ein oder mehrere Tests online innerhalb des &bdquo;Webpa-getest.org&ldquo; &ndash; Tools miteinander vergleichen. Alle Tests m&uuml;ssen mithilfe der Funktion  &bdquo;Capture Video&ldquo; (siehe Testparameter) aufgenommen werden. Um die Tests miteinander zu vergleichen, muss man innerhalb des &bdquo;Webpagetest.org&ldquo; &ndash; Tools die URL &bdquo;<A href="https://www.webpagetest.org/video/compare.php?tests">
<FONT color="#0462C1">https://www.webpagetest.org/vi-deo/compare.php?tests</A>
<FONT color="#000000">=&ldquo; gefolgt von der Test-ID, die bei jedem Test in der Adressleiste des Browsers angezeigt wird, eingeben. </P
><P 

><I>Wie werden die Tests ausgewertet? </I></P
><P 

>F&uuml;r jeden Test wird die Webapplikation 27 Mal aufgerufen. F&uuml;r die Auswertung der aufgenom-menen Parameter muss ein Mittel gefunden werden, um diese visuell darstellen zu k&ouml;nnen. Die erste Darstellungsidee war die tabellarische Darstellung mit drei Werten zu allen aufgenom-menen Werten: der Medianwert, das Minimum und das Maximum. Diese drei Werte k&ouml;nnen als aussagekr&auml;ftigste betrachtet werden. Da die Werte aus mehreren Tests miteinander vergli-chen werden sollen, wird sich die Darstellungsart dieser Werte in der Form eines Liniendia-gramms besser eignen. In allen Tests gibt es nur eine Achse, n&auml;mlich die Zeit, an der die Para-meter ausgegeben werden.  </P
><P 

>Allerdings gibt es oftmals Werte, die sich von allen anderen stark unterscheiden und an denen festgestellt werden kann, dass diese seltene Ausnahmen sind. Dann wird in solchen F&auml;llen die gesamte Messreihe nicht mehr aussagekr&auml;ftig sein, da Maximum und Minimum verzerrt sind. </P
><P 

>Aus diesem Grund muss eine Darstellung gefunden werden, die deutlich zeigt, in welchem Bereich sich die meisten Werte befinden, wo die Ausnahmen sind, wo minimale und maximale Werte sind und wo sich der Median befindet. Der Median wurde dem arithmetischen Mittelwert vorgezogen, weil er robuster gegen&uuml;ber Ausrei&szlig;ern ist. F&uuml;r alle diese Anforderungen eignet sich das Boxplot-Diagramm gut. </P
><P 

>Das Boxplot-Diagramm enth&auml;lt ein Rechteck, die sogenannte Box, und zwei Linien, die dieses Rechteck verl&auml;ngern. Die Bezeichnung f&uuml;r diese Linien ist &bdquo;Antenne&ldquo; oder &bdquo;Whisker&ldquo;. Innerhalb der Box befindet sich ein Strich, der die Position des Median markiert. Abb. 20 veranschaulicht das Boxplot-Diagramm. Die Box enth&auml;lt die mittleren 50% aller Werte. Der Median teilt das komplette Boxplot-Diagramm in zwei H&auml;lften, sodass links und rechts vom Median sich jeweils 50% aller Werte befinden. Je nachdem, wo sich der Median innerhalb der Box befindet, kann man sagen, wie sich die Werte innerhalb des gesamten Zeitraums verteilen. Wenn sich der Median in der rechten H&auml;lfte der Box befindet, ist die Datenverteilung linksschief (Abb. 20). </P
><P 

>Wenn der Median in der linken H&auml;lfte der Box liegt, ist die Datenverteilung rechtsschief (Wi-kipedia 2016a). </P
><P 

>Die Grenzen der Box sind das untere und obere Quartil. Die L&auml;nge der Box wird durch die Differenz zwischen dem unteren und oberen Quartil definiert. Die Spannweite ist der komplette Wertebereich aller Daten. Das Maximum steht f&uuml;r den gr&ouml;&szlig;ten Datenwert der ganzen Spann-weite. Das Minimum steht f&uuml;r den kleinsten Datenwert der gesamten Spannweite. Der Bereich zwischen Minimum und unterem Quartil, als auch der Bereich zwischen dem oberen Quartil und dem Maximum umfasst 25% aller Werte (Wikipedia 2016a). </P
><P 

>Mithilfe der Antennen werden die Werte angezeigt, die sich au&szlig;erhalb der Box befinden. Die L&auml;nge der Antenne wird als das maximal 1,5-Fache der L&auml;nge der Box bestimmt. Dies gilt so-wohl f&uuml;r die untere als auch f&uuml;r die obere Antenne. Die Antenne endet nicht genau nach der 1,5-fachen L&auml;nge der Box, sondern nimmt den Wert an, der gerade noch innerhalb der berech-neten L&auml;nge liegt. Deshalb kann es sein, dass die untere und obere Antenne unterschiedlich lang sind (Wikipedia 2016a). </P
><P 

>Alle Werte, die au&szlig;erhalb der Antennen liegen, sind die Ausrei&szlig;er. Die Ausrei&szlig;er werden mit Krei&szlig;en im Boxplot-Diagramm dargestellt (Abb. 20). Sowohl Maximum als auch Minimum k&ouml;n-nen Ausrei&szlig;er sein (Wikipedia 2016a). Meistens unterscheiden sich die Ausrei&szlig;er von allen an-deren Werten der Werteverteilung und sind ein Zeichen daf&uuml;r, dass entweder diese Werte falsch gemessen wurden oder sie eine Ausnahme darstellen. Deshalb bedeutet die Markierung als Ausrei&szlig;er, dass diese Werte innerhalb der 27 gemessenen Werte nicht betrachtet werden sollten. </P
><P 

> </P
><IMG width="524" height="225"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_20.jpg" ><DL 

><DD 

><I>Abb. 20:</I><I> </I><I>Beispiel eines Boxplot-Diagramms </I></DD
></DL
><P 

>Die f&uuml;r die Tests verwendeten Boxplot-Diagramme wurden mithilfe der Statistikprogrammier-sprache &bdquo;R&ldquo;, der Entwicklungsumgebung &bdquo;RStudio&ldquo; und der Erweiterung &bdquo;ggplot2&ldquo; erstellt (The R Foundation 2016), (Wickham 2013), (RStudio 2016). </P
><P 

><I>  </I></P
><P 

><I>Wie kann man die Funktionsweise des HTTP/2 </I><I>&ndash;</I><I> Protokolls am lokalen PC untersuchen? </I></P
><P 

>F&uuml;r eine detaillierte Untersuchung des Netzwerk-Datenverkehrs von Datenprotokollen eignet sich die &bdquo;Wireshark&ldquo; Software sehr gut (Wireshark Foundation 2016a). Diese wird f&uuml;r Untersu-chungen am lokalen PC benutzt. </P
><P 

>Es wird der TCP-Port 443 f&uuml;r das HTTP/2 &ndash; Protokoll benutzt (Wireshark Foundation 2016b) weil die Browser dieses Protokoll nur unter verschl&uuml;sselter TLS-Verbindung laufen lassen (Gri-gorik 2015, 21). Da es sich um eine verschl&uuml;sselte Verbindung handelt, kann &bdquo;Wireshark&ldquo; nicht ohne zus&auml;tzliche Mittel die Kommunikation zwischen Client und Server betrachten (Shaver 2015). Um verschl&uuml;sselte Verbindungen unter dem HTTP/2 &ndash; Protokoll mithilfe von &bdquo;Wireshark&ldquo; untersuchen zu k&ouml;nnen, muss man das HTTP/2 &ndash; Protokoll innerhalb von &bdquo;Wireshark&ldquo; ent-schl&uuml;sseln (Wireshark Foundation 2016b). Um eine Verschl&uuml;sselte Verbindung knacken zu k&ouml;n-nen, kann ein &bdquo;Man-in-the-Middle&ldquo; &ndash; Angriff benutzt werden. Der &bdquo;Man-in-the-Middle&ldquo; stellt sich zwischen beide Kommunikationspartner und &uuml;berwacht den kompletten Datenverkehr zwischen den Netzwerkteilnehmern. Dies wird erm&ouml;glicht, indem sich der Angreifer bei beiden Kommunikationspartnern f&uuml;r den jeweils anderen Partner ausgibt.<FONT color="#FF0000"> <FONT color="#000000">Die Informationen, die der Angreifer bekommt, k&ouml;nnen eingesehen und manipuliert werden (Wikipedia 2016b).  </P
><P 

>Die Browser &bdquo;Mozilla Firefox&ldquo; und &bdquo;Google Chrome&ldquo; erm&ouml;glichen das mitschreiben des sym-metrischen Sitzungsschl&uuml;ssels. Dieser wird benutzt, um den TLS- Datenverkehr in einer Datei verschl&uuml;sselt abzulegen. Wenn nun &bdquo;Wireshark&ldquo; diese Datei &uuml;bergeben wird, kann der TLS-Datenverkehr eingesehen werden (Shaver 2015).  </P
><P 

>Der lokale PC, der f&uuml;r die Testuntersuchung benutzt wird, hat das Betriebssystem &bdquo;Microsoft Windows 7&ldquo;. Um den zuvor beschriebenen &bdquo;Man-in-the-Middle-Angriff&ldquo; bei den Browsern &bdquo;Mozilla Firefox&ldquo; und &bdquo;Google Chrome&ldquo; benutzen zu k&ouml;nnen, muss man eine Umgebungsvari-able im Betriebssystem setzen. Der Name der Variable muss &bdquo;SSLKEYLOGFILE&ldquo; sein und der Wert der Variable &bdquo;C:\Users\<I>Name des Benutzers</I>\sslkeylog.log&ldquo; (Shaver 2015). Die Datei muss unter diesem Pfad existieren.  </P
><P 

>Im zweiten Schritt muss man diese Datei an &bdquo;Wireshark&ldquo; &uuml;bergeben. Man braucht daf&uuml;r &bdquo;Wire-shark&ldquo; ab der Version 1.12.0 (CloudFlare 2016). Unter &bdquo;Edit&ldquo;-&gt;&bdquo;Preferences&ldquo; -&gt;&bdquo;Protocols&ldquo; -&gt;&bdquo;SSL&ldquo; im Feld &bdquo;(Pre)-Master-Secret log filename&ldquo; muss man den Pfad zur Datei &bdquo;sslkeylog.log&ldquo; &uuml;bergeben. </P
><P 

>Diese Methode hilft, um in &bdquo;Wireshark&ldquo; die Inhalte der TCP-Pakete (unter Decrypted SSL Data) und die Inhalte des HTTP/2 &ndash; Protokolls (&bdquo;Frames&ldquo; mit allen Parametern) zu sehen. Man sollte nur nicht vergessen, dass das HTTP/2 &ndash; Protokoll ein bin&auml;res Protokoll ist, d.h., um alle Inhalte verstehen zu k&ouml;nnen, m&uuml;ssen die bin&auml;ren Inhalte erst entschl&uuml;sselt werden. </P
><P 

>Um aus dem gesamten Datenmitschnitt nur das HTTP/2 &ndash; Protokoll verfolgen zu k&ouml;nnen, muss man den Filter &bdquo;http2&ldquo; anwenden. Es werden alle Pakete angezeigt, die zu diesem Protokoll </P
><P 

>geh&ouml;ren. Es gibt eine Liste von Filtern, die man f&uuml;r den Datenmitschnitt aus &bdquo;Wireshark&ldquo; an-wenden kann (Wireshark Foundation 2016c). Es ist auch m&ouml;glich, um Filter selbst zu erstellen, wenn man z.B. einen konkreten &bdquo;Stream&ldquo;, &bdquo;Frame&ldquo; oder eine Datei verfolgen m&ouml;chte. Wenn die Benutzeroberfl&auml;che von &bdquo;Wireshark&ldquo; benutzt wird, muss man einen bestimmten Parameter (z.B. &bdquo;Stream Identifier: 7&ldquo;) ausw&auml;hlen, dann aus dem Kontextmen&uuml; &bdquo;Apply as Filter&ldquo; &bdquo;Selected&ldquo; aus-w&auml;hlen. </P
><P 

>  </P
><H1 

><FONT size="+1">5. Tests und Testevaluation </H1
><P 

><FONT size="+1">In diesem Kapitel wird der praktische Teil der Masterarbeit vorgestellt. Innerhalb dieses Kapitels werden mehrere Fragen in Bezug auf die Funktionsweise des HTTP/2 &ndash; Protokolls und dessen Funktion &bdquo;Server Push&ldquo; beantwortet. Es werden mehrere Tests zu clientseitigen Techniken der Performance &ndash; Optimierung durchgef&uuml;hrt und ausgewertet. Au&szlig;erdem werden Tests zum Ver-gleich der Ladezeiten bei den HTTP/1.1- und HTTP/2 &ndash; Protokollen durchgef&uuml;hrt. </P
><H2 

><FONT size="+1">5.1. Wie funktioniert &bdquo;Server Push&ldquo;? </H2
><P 

><FONT size="+1">Die Funktionsweise des &bdquo;Server Pushes&ldquo; wurde im theoretischen Teil der Masterarbeit kurz er-l&auml;utert. Allerdings stellen sich einige Fragen, wie diese Funktion des neuen Protokolls tats&auml;ch-lich funktioniert. Einige davon sind: </P
><DL 

><DD 

>&#61630; Wird die Lieferung der HTML Datei verz&ouml;gert, bis alle gepushten Ressourcen den Client erreicht haben? Wenn nein, wie wird der &bdquo;Server Push&ldquo; &ndash; Einsatz genau funktionieren? Wann werden diese Ressourcen zum Client geliefert? </DD
><DD 

>&#61630; In welcher Reihenfolge werden die gepushten Ressourcen beim Client ankommen? </DD
><DD 

>&#61630; Lassen sich die unterschiedlichen Typen von gepushten Ressourcen priorisieren? </DD
><DD 

>&#61630; Werden sich die gepushten Dateien bei erneutem Aufruf der Webapplikation im Brow-ser Cache befinden? </DD
></DL
><P 

>In diesem Teil wird die genauere Funktionsweise des &bdquo;Server Pushes&ldquo; bei einem Apache Server mit Version 2.4.20 beschrieben. Um einzelne Frames w&auml;hrend des Transports besser zu be-obachten, kann man mithilfe von &bdquo;Wireshark&ldquo; ein Blick in die einzelnen Pakete geworfen wer-den. Als Client wird der Browser &bdquo;Mozilla Firefox&ldquo; mit Version 47.0 genommen, damit die Ver-sionen des &bdquo;Webpagetest.org&ldquo; &ndash; Tools mit der Version des lokalen PCs gleich bleiben werden. Es werden zus&auml;tzliche Tests gemacht, in denen das HTTP/2 &ndash; Protokoll in anderen Webbrow-sern untersucht wird. </P
><P 

><I>Wie kann man &bdquo;Server Push&ldquo; mit A</I><I>pache Server anwenden? </I></P
><P 

>F&uuml;r &bdquo;Server Push&ldquo; ist die &bdquo;H2Push&ldquo;-Direktive verantwortlich. Diese ist im Apache-Modul &bdquo;mod-_http2&ldquo; schon enthalten. Diese Direktive muss sich innerhalb des &lt;VirtualHost&gt; befinden. &bdquo;Ser-ver Push&ldquo; ist standardm&auml;&szlig;ig eingeschaltet. Um &bdquo;Server Push&ldquo; auszuschalten, muss man inner-halb des &lt;VirtualHost&gt; &bdquo;H2Push off&ldquo; setzen. Der &bdquo;Server Push&ldquo;-Ablauf wird gemessen, indem man die &bdquo;Link-Header&ldquo; der Responses untersucht. Wenn ein Link mit dem Attribut &bdquo;rel=preload&ldquo; versehen ist, wird er als zu pushende Ressource betrachtet. &bdquo;Link-Header&ldquo; k&ouml;n-nen entweder im Code der Webapplikation stehen oder mithilfe von &bdquo;mod_headers&ldquo; konfigu-riert werden. Um die zweite Variante anwenden zu k&ouml;nnen, muss beachtet werden, dass das Apache-Modul &bdquo;mod_headers&ldquo; installiert ist (Apache Software Foundation 2016a). </P
><P 

>  </P
><P 

>&bdquo;Link-Headers&ldquo; k&ouml;nnen folgenderma&szlig;en angewendet werden: </P
><P 

>&lt;Location /index.html&gt; </P
><P 

>        Header add Link &quot;&lt;/css/style.css&gt;;rel=preload&quot; </P
><P 

>        Header add Link &quot;&lt;/css/slider.css&gt;;rel=preload&quot; </P
><P 

>&lt;/Location&gt; </P
><P 

> </P
><P 

>(Apache Software Foundation 2016a) </P
><P 

> </P
><P 

>Man muss allerdings beachten, dass die Ressourcen nur einmal aufgelistet sind, weil es keine &Uuml;berpr&uuml;fung nach Duplikaten innerhalb dieses Moduls gibt. Falls die Ressourcen mehrmals aufgelistet werden, werden diese mehrmals zum Client gepusht (Apache Software Foundation 2016a).<FONT color="#FF0000"> </P
><P 

><FONT color="#000000">Es gibt eine wichtige Voraussetzung bei der Verwendung des &bdquo;Server Pushes&ldquo;: dieser funktio-niert nur dann, wenn der Client signalisiert, dass er gepushte Ressourcen annehmen will. Die meisten Browser machen dies, aber manche, wie &bdquo;Safari 9&ldquo;, akzeptieren sie nicht. &bdquo;Server Push&ldquo; funktioniert nur f&uuml;r Ressourcen, die zu demselben &lt;VirtualHost&gt; geh&ouml;ren, wie die angefragte Ressource (Apache Software Foundation 2016a). </P
><P 

>Alle Ressourcen, die per &bdquo;Header&ldquo; im &bdquo;&lt;VirtualHost&gt;&ldquo;-Bereich des Apache-Servers aufgelistet sind, m&uuml;ssen auch im Code der Webapplikation stehen. </P
><P 

>Im Fall des &bdquo;Server Pushes&ldquo; werden alle &bdquo;Streams&ldquo; vom Server ge&ouml;ffnet. In der Dokumentation des Apache-Moduls &bdquo;mod_http2&ldquo; steht, dass sich verschiedene Typen von gepushten Ressour-cen je nach MIME-Typ unterschiedlich priorisieren lassen. Das Ziel des Priorisierens besteht darin, die verf&uuml;gbare Bandbreite zwischen den Ressourcen sinnvoll aufzuteilen. Z.B. ist es wich-tig, dass die CSS Dateien so schnell wie m&ouml;glich den Client erreichen. Deshalb ist f&uuml;r sie eine hohe Priorit&auml;t sehr wichtig. Wie die serverseitige Priorisierung eingestellt wird, ist dem Weben-twickler &uuml;berlassen. Man kann mit Servereinstellungen Gewichte f&uuml;r &bdquo;Streams&ldquo;, je nach MIME-Typ der Dateien, bestimmen (Apache Software Foundation 2016a). </P
><P 

><I>Wie funktioniert die serverseitige Priorisierung der per &bdquo;Server Push&ldquo; &uuml;bergebenen Ressourcen?</I><I> </I></P
><P 

>Serverseitige Priorisierungen lassen sich mithilfe der &bdquo;H2PushPriority&ldquo;-Direktive implementie-ren (Apache Software Foundation 2016a). Diese Funktion ist dann besonders hilfreich, wenn unterschiedliche Typen von Ressourcen per &bdquo;Server Push&ldquo; &uuml;bergegeben werden. Wenn z.B. so-wohl kritische CSS Dateien als auch kritische JavaScript Dateien gepusht werden m&uuml;ssen, ist es hilfreich, zuerst alle CSS Dateien an den Client zu liefern, damit es keine zus&auml;tzlichen Verz&ouml;ge-rungen geben wird. </P
><P 

>Normalerweise werden alle &bdquo;Streams&ldquo; clientseitig ge&ouml;ffnet und diese werden vom Client mit-hilfe von PRIORITY &ndash; Frames priorisiert. Aber im Fall von gepushten Ressourcen, deren </P
><P 

>&bdquo;Streams&ldquo; serverseitig ge&ouml;ffnet werden, darf der Server entscheiden, wie Priorit&auml;ten gesetzt werden sollen (Apache Software Foundation 2016a). </P
><P 

>Die &bdquo;H2PushPriority&ldquo;-Direktive gibt die M&ouml;glichkeit, die Gewichte der gepushten Ressourcen zu steuern. Diese kann sich entweder innerhalb des &lt;VirtualHost&gt; oder innerhalb der HTTP/2 &ndash; Serverkonfiguration befinden. Der Syntax der &bdquo;H2PushPritority&ldquo;-Direktive ist der Folgende: </P
><P 

>H2PushPriority <I>mime-type</I> (after | before | interleaved) (weight) </P
><P 

>Wenn man gleiche Gewichte auf alle Ressourcentypen anwenden m&ouml;chte, muss man anstatt eines bestimmten MIME-Typs an der Stelle <I>&bdquo;mime</I><I>-type</I>&ldquo;<I> </I>einen <I>&bdquo;*&ldquo;</I> schreiben. Je gr&ouml;&szlig;er das Ge-wicht ist, desto h&ouml;her wird die Priorit&auml;t gesetzt. &bdquo;After&ldquo;, &bdquo;Before&ldquo; und &bdquo;Interleaved&ldquo; zeigen, wie die Bandbreite zwischen den gepushten Ressourcen und dem clientseitigen &bdquo;Stream&ldquo; (von dem die gepushten Ressourcen abh&auml;ngig sind) aufgeteilt werden soll. &bdquo;After&ldquo; bedeutet, dass die gepushten Ressourcen nach dem clientseitigen &bdquo;Stream&ldquo; geschickt werden m&uuml;ssen. &bdquo;Inter-leaved&ldquo; bedeutet vermischt mit dem clientseitigen &bdquo;Stream&ldquo;. &bdquo;Before&ldquo; steht daf&uuml;r, dass ge-pushte Ressourcen den Client vor dem clientseitigen &bdquo;Stream&ldquo; erreichen (Apache Software Foundation 2016a). </P
><P 

>Die standardm&auml;&szlig;ige Priorisierungsregel lautet: <I>H2PushPriority * After 16</I>. Dies bedeutet, dass alle per &bdquo;Server Push&ldquo; &uuml;bergebenen Ressourcentypen, die vom clientseitigen &bdquo;Stream&ldquo; abh&auml;n-gig sind, nach diesem &bdquo;Stream&ldquo; mit einem Gewicht von 16 gesendet werden (Apache Software Foundation 2016a).  </P
><P 

>Um genauer zu zeigen, wie Gewichte eingesetzt werden m&uuml;ssen, wird ein Beispiel gezeigt. Es wird angenommen, dass X der clientseitige &bdquo;Stream&ldquo; ist, der vom Y-&ldquo;Stream&ldquo; abh&auml;ngig ist. Der Server muss entscheiden, wie er die &bdquo;Streams&ldquo; P1 und P2 zum X-&ldquo;Stream&ldquo; pushen wird. Wenn die Regel &bdquo;H2PushPriority text/css Interleaved 256&quot; lautet, kann der Server es so interpretieren, dass alle gepushten CSS Ressourcen die gleiche Abh&auml;ngigkeit und das gleiche Gewicht haben werden, wie der clientseitige &bdquo;Stream&ldquo;. Das effektive Gewicht (&bdquo;Effective weight&ldquo;, kurz: &bdquo;ew&ldquo;) wird mit einer Formel berechnet: </P
><P 

>&#119875;1<FONT size="+1">&#119890;&#119908;<FONT size="+1">=&#119883;<FONT size="+1">&#119908;<FONT size="+1">&lowast;(&#119875;1<FONT size="+1">&#119908;<FONT size="+1">/256), &#119875;1<FONT size="+1">&#119890;&#119908;<FONT size="+1"> -  effektives Gewicht des gepushten &bdquo;Streams&ldquo; </P
><P 

>&#119883;<FONT size="+1">&#119908;<FONT size="+1"> - Gewicht des clientseitigen &bdquo;Streams&ldquo; </P
><P 

>&#119875;1<FONT size="+1">&#119908;<FONT size="+1"> - eingestelltes Gewicht der gepushten Ressource </P
><P 

> </P
><P 

>(Apache Software Foundation 2016a) </P
><P 

>Das effektive Gewicht darf nicht mehr als 256 sein. Im aktuellen Beispiel, wenn die gepushte Datei eine CSS Ressource ist und das Gewicht auf 256 gesetzt wurde, wird der gepushte &bdquo;Stream&ldquo; ein effektives Gewicht gleich dem Gewicht des X-&ldquo;Streams&ldquo; haben. Dies bedeutet, wenn X und P1 Daten zum Senden haben werden, wird P1 genau so viel Bandbreite bekommen, wie der clientseitige &bdquo;Stream&ldquo; (in diesem Fall X-&bdquo;Stream&ldquo;). Wenn das Gewicht der gepushten </P
><P 

>Ressource auf 512 eingestellt w&uuml;rde, w&uuml;rde er doppelt so viel Bandbreite bekommen, als der clientseitige &bdquo;Stream&ldquo;. Falls das Gewicht der gepushten Ressource auf 128 eingestellt w&uuml;rde, w&uuml;rde er nur die H&auml;lfte der verf&uuml;gbaren Bandbreite nach dem clientseitigen &bdquo;Stream&ldquo; bekom-men (Apache Software Foundation 2016a). </P
><P 

><I>Fallbeispiel: Funktionsweise </I><I>des &bdquo;Server Pushs&ldquo;</I><I> </I></P
><P 

>Es wird die Startseite der Test-Webapplikation mit 10 gepushten CSS Dateien untersucht. Es wurden keine serverseitigen Priorisierungen f&uuml;r sie gesetzt. Etwas sp&auml;ter wird untersucht, wie weit gepushte Ressourcen die Webapplikation beeinflussen k&ouml;nnen, wenn diese serverseitig priorisiert werden. Nach der Aufnahme des Datentransportes mit &bdquo;Wireshark&ldquo; kann man alle HTTP/2 &ndash; Frames genau betrachten, die zwischen Client und Server ausgetauscht werden. Die Webapplikation wird mithilfe des Browsers &bdquo;Mozilla Firefox&ldquo; aufgerufen. Um diese ohne Cache aufrufen zu k&ouml;nnen, muss man mit der Tastenkombination &bdquo;Strg + F5&ldquo; die Seite aktualisieren. </P
><P 

>In der &bdquo;Wireshark&ldquo;-Aufnahme sieht man, dass der Client kein besonderes Signal gibt, die Res-sourcen annehmen zu wollen, wie es in der Dokumentation des &bdquo;mod_http2&ldquo;-Moduls des Apache-Servers steht (Apache Software Foundation 2016a). </P
><P 

>Unmittelbar nachdem die HTML Datei vom Server aufgerufen wurde, kommen alle PUSH_PRO-MISE &ndash; Frames der gepushten Dateien zum Client. Da nur zehn Dateien gepusht werden, pas-sen alle &bdquo;Frames&ldquo; in ein TCP &ndash; Paket. PUSH_PROMISE &ndash; Frames kommen genau in der Reihen-folge, wie sie im &lt;VirtualHost&gt; beim Server aufgelistet sind. Jeder PUSH_PROMISE &ndash; Frame enth&auml;lt Informationen &uuml;ber den &bdquo;Stream&ldquo;, zu dem er geh&ouml;rt (im aktuellen Fall ist es die HTML Datei mit dem &bdquo;Stream&ldquo; Identifier 13); &uuml;ber die eigene gepushte &bdquo;Stream-ID&ldquo; (&bdquo;Promised-Stream-ID&ldquo;) und &uuml;ber den &bdquo;Frame Header&ldquo;. Es gibt eine wichtige Bemerkung: &bdquo;Promised-Stream-ID&ldquo; wird nur einmal pro PUSH_PROMISE &ndash; Frame gesetzt. Danach werden gew&ouml;hnliche &bdquo;Stream Identifier&ldquo; verwendet. Es ist zu beachten, dass alle &bdquo;Promised-Stream-IDs&ldquo; gerade Zah-len haben, weil deren &bdquo;Streams&ldquo; serverseitig ge&ouml;ffnet werden. </P
><P 

>Nachdem alle PUSH_PROMISE &ndash; Frames den Client erreicht haben, werden die dazugeh&ouml;rigen &bdquo;Streams&ldquo; vom Client priorisiert. Allerdings ist schwer zu erkl&auml;ren, warum vom Server ge&ouml;ffnete &bdquo;Streams&ldquo; vom Client priorisiert werden. Dies wiederspricht der Dokumentation des Moduls &bdquo;mod_http2&ldquo; des Apache-Servers (Apache Software Foundation 2016a). </P
><P 

>Der Client schickt die PRIORITY &ndash; Frames f&uuml;r jeden einzelnen gepushten &bdquo;Stream&ldquo;. Diese &bdquo;Fra-mes&ldquo; haben eine Reihenfolge gem&auml;&szlig; des &bdquo;FIFO&ldquo;-Prinzips: wenn der PUSH_PROMISE &ndash; Frame des &bdquo;Streams&ldquo; &bdquo;A&ldquo; den Client zuerst erreicht hat, wird der PRIORITY &ndash; Frame dieses &bdquo;Streams&ldquo; als erster gesendet. Danach erreichen per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen den Client genau in der Reihenfolge, wie diese innerhalb des &lt;VirtualHost&gt; aufgelistet sind.  </P
><P 

>Die wichtigsten Informationen, die die PRIORITY &ndash; Frames enthalten, sind &bdquo;Stream Identifier&ldquo; (ID des gepushten &bdquo;Streams&ldquo;), &bdquo;Stream Dependency&ldquo; und &bdquo;Weight&ldquo;. Alle PRIORITY &ndash; Frames </P
><P 

>haben gleiche Gewichte. Dies k&ouml;nnte daran liegen, dass die Ressourcen keine bestimmten ser-verseitigen Priorisierung haben.  </P
><P 

>Nachdem alle PRIORITY &ndash; Frames geschickt wurden, erreichen den Client HEADERS &ndash; Frames gefolgt vom DATA &ndash; Frame der HTML Datei. Nach der Beobachtung werden alle PUSH_PRO-MISE- und PRIORITY &ndash; Frames dem Client geliefert, bevor der DATA &ndash; Frame der HTML Datei den Client erreicht. Danach werden alle gepushten Ressourcen den Client erreichen. Erst nach-dem alle per &bdquo;Server Push&ldquo; &uuml;bergebenen Ressourcen den Client erreichen, werden weitere Res-sourcen der Webapplikation vom Server abgefragt. </P
><P 

><I>Werden die Ressourcen nach dem zweiten Aufruf der Webapplikation im Browser Cache landen?  </I></P
><P 

>Diese Fragestellung wurde am lokalen PC gepr&uuml;ft und es wurde festgestellt, dass bei der Ver-wendung des f&uuml;r den Test festgelegten Browsers &bdquo;Mozilla Firefox&ldquo; die gepushten Ressourcen wieder neu geladen werden. Dies wurde mithilfe von &bdquo;Wireshark&ldquo; und den Entwicklertools des Browsers festgestellt. Es w&auml;re jedoch zu erwarten gewesen, dass, nachdem der PUSH_PRO-MISE &ndash; Frame den Client erreicht hat, der dazugeh&ouml;rige &bdquo;Stream&ldquo; vom Client abgelehnt worden w&auml;re. Vermutlich h&auml;tte an dieser Stelle ein RST_STREAM &ndash; Frame vom Client gesendet werden sollen. </P
><P 

>Bei der Verwendung des &bdquo;Webpagetest.org&ldquo; &ndash; Tools konnte dagegen festgestellt werden, dass alle Ressourcen der Webapplikation beim zweiten Aufruf aus dem Browser Cache geladen wer-den. Dabei waren die Browserversionen des &bdquo;Webpagetest.org&ldquo; &ndash; Tools und des lokalen PCs die gleichen. </P
><H2 

><FONT size="+1">5.2. Zwischenfazit: Wie funktioniert &bdquo;Server Push&ldquo; </H2
><P 

><FONT size="+1"><I>Wof&uuml;r k&ouml;nnte &bdquo;Server Push&ldquo; hilfreich sein? Welche Parameter des kritischen Rendering</I><I> </I><I>&ndash;</I><I> Pfades </I><I>k&ouml;nnen durch &bdquo;Server Push&ldquo; verz&ouml;gert werden?</I><I> </I></P
><P 

>Nachdem genauer betrachtet wurde, wie der &bdquo;Server Push&ldquo; &ndash; Einsatz funktioniert, wurden viele der am Anfang gestellten Fragen beantwortet. Es werden keine kompletten gepushten Dateien zum Client geliefert, bevor die HTML Datei den Client erreicht. Stattdessen werden, bevor der DATA &ndash; Frame der HTML Datei den Client erreicht, PUSH_PROMISE &ndash; Frames des gepushten &bdquo;Streams&ldquo; zum Client geliefert und dann werden Priorit&auml;ten mithilfe von PRIORITY &ndash; Frames gesetzt. Deshalb wird die HTML Datei mit jeder gepushten Ressource durch PUSH_PROMISE-und PRIORITY &ndash; Frames sp&auml;ter an den Client geliefert. Deshalb wird mit dem &bdquo;Server Push&ldquo; &ndash; Einsatz der Parameter &bdquo;Time To First Byte&ldquo; und m&ouml;glicherweise die DOM-Erstellung verz&ouml;gert. Andererseits werden Bytes f&uuml;r Requests dieser Dateien gespart, sodass sie schneller den Client erreichen werden. Deshalb wird der Render &ndash; Baum vermutlich schneller aufgebaut, wenn die f&uuml;r die Erstdarstellung kritischen Ressourcen per &bdquo;Server Push&ldquo; &uuml;bergeben werden. Au&szlig;erdem ist zu erwarten, dass die Gesamtladezeit f&uuml;r alle Ressourcen durch weniger ange-fragte Bytes verk&uuml;rzt wird. </P
><P 

><I>Wie viele Dateien k&ouml;nnen per &bdquo;Server Push&ldquo; &uuml;bergegeben werden?</I><I> </I></P
><P 

>Wenn viele Dateien gepusht werden, ist zu erwarten, dass m&ouml;glicherweise der Parameter &bdquo;Time To First Byte&ldquo; und die DOM-Erstellung deutlich verz&ouml;gert werden. Deshalb k&ouml;nnte dieser Fall die Erstellung des Render &ndash; Baums bremsen. </P
><P 

>Wichtig scheint auch zu sein, dass keine gro&szlig;en Ressourcen per &bdquo;Server Push&ldquo; &uuml;bergeben wer-den. Wenn diese lange Zeit zum Herunterladen brauchen werden (dies ist der Fall in mobilen Netzwerken), dann werden alle anderen Ressourcen auf der Seite warten, bis diese Dateien vollst&auml;ndig heruntergeladen wurden. </P
><P 

><I>Wann und in welcher Reihenfolge werden gepushte Ressourcen zum Client geliefert? </I></P
><P 

>Gepushte Ressourcen werden den Client erst erreichen, nachdem die HTML Datei vollst&auml;ndig geladen wurde. Wenn alle gepushten Ressourcen gleich priorisiert werden, werden sie nachei-nander geliefert. Im Falle, dass es keine serverseitige Priorisierung gibt, ist die Reihenfolge der Auflistung im &lt;VirtualHost&gt;-Bereich sehr wichtig. Dies bedeutet, wenn im &lt;VirtualHost&gt;-Be-reich des Apache-Servers die Dateien z.B. in der Reihenfolge CSS Dateien, Webschrift und dann wieder CSS Dateien aufgelistet sind, dann werden die letzteren CSS Dateien warten, bis die Webschriften vollst&auml;ndig geladen wurden. Diese Situation muss man vermeiden. </P
><P 

>Au&szlig;erdem sollen alle kritischen Ressourcen mitgepusht werden, auch wenn es notwendig ist, um nicht-kritische Ressourcen (z.B. Webschriften oder Bilder) per &bdquo;Server Push&ldquo; zu &uuml;bergeben. In diesem Fall muss man daf&uuml;r sorgen, dass zuerst alle kritischen Dateien den Client erreichen werden. Dadurch wird vermieden, dass die Erstellung des Rendering &ndash; Baums verz&ouml;gert wird. </P
><P 

><I>Lassen sich die unterschiedlichen Typen von gepushten Ressourcen priorisieren? </I></P
><P 

>Innerhalb des Moduls &bdquo;mod_http2&ldquo; des Apache Servers wurde die Direktive der serverseitigen Priorisierung von gepushten Ressourcen implementiert. Deshalb k&ouml;nnen gepuschte Ressour-cen mit verschiedenen MIME-Typen unterschiedlich priorisiert werden. </P
><P 

>Im zuvor dargestellten Fallbeispiel wurde die serverseitige Priorisierung der gepushten Res-sourcen ausgeschaltet. Dennoch werden PRIORITY &ndash; Frames vom Client an den Server geliefert. Dies wiederspricht der Dokumentation des &bdquo;mod_http2&ldquo; Moduls (Apache Software Foundation 2016a). </P
><P 

>Es werden sp&auml;ter Tests gemacht und untersucht, wie die Priorit&auml;ten f&uuml;r unterschiedliche Typen von gepushten Ressourcen funktionieren. </P
><P 

><I>  </I></P
><P 

><I>Werden per &bdquo;Server Push&ldquo; &uuml;bergebene Dateien im Browser Cache landen?</I><I> </I></P
><P 

>Die Ergebnisse des &bdquo;Webpagetest.org&ldquo; &ndash; Tools sind unterschiedlich zu den Ergebnissen, die am lokalen PC gemacht wurden. Die Browserversionen sind die gleichen. Im Browser des &bdquo;Webpa-getest.org&ldquo; &ndash; Tools sieht man, dass beim zweiten Aufruf der Webapplikation alle Dateien be-reits im Browser Cache sind. Dies betrifft auch alle gepushten Ressourcen. Als die Webapplika-tion am lokalen PC aufgerufen wurde, wurden beim zweiten Aufruf per &bdquo;Server Push&ldquo; &uuml;berge-bene Dateien noch Mal vom Server geladen. </P
><P 

>Die Funktionsweise des &bdquo;Server Pushs&ldquo;, die oben beschrieben wurde, bezieht sich auf einen konkreten Apache Server mit der Version 2.4.20. Als Client wurde der Browser &bdquo;Mozilla Firefox&ldquo; mit der Version 47.0 ausgew&auml;hlt. Dies bedeutet, dass sich das oben beschriebene Verhalten auf eine konkrete Version der Serverimplementierung und des oben gew&auml;hlten Browsers be-zieht und sich demnach m&ouml;glicherweise unter anderen Versionen/Implementierungen anders verhalten wird. In weiteren Tests wurden F&auml;lle untersucht, bei denen andere Browser als Client gew&auml;hlt wurden. </P
><H2 

><FONT size="+1">5.3. Serverseitige Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen  Ressourcen </H2
><P 

><FONT size="+1">Oben wurde die Funktionsweise serverseitiger Priorisierungen von per &bdquo;Server Push&ldquo; &uuml;berge-benen Ressourcen beschrieben. Es ist interessant zu schauen, wie diese tats&auml;chlich funktionie-ren. Deshalb wurden zwei Tests zur &bdquo;H2PushPriority&ldquo;-Direktive durchgef&uuml;hrt und ausgewertet. </P
><H3 

><FONT size="+1">5.3.1. Test 1: Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien  und Schriften </H3
><P 

><FONT size="+1"><I>Testbedingungen</I>: untersucht wurde die Startseite der Webapplikation. Es wurden alle f&uuml;r die Seite ben&ouml;tigten CSS Dateien (10 St&uuml;ck) und f&uuml;nf nicht-kritische Schrift Dateien per &bdquo;Server Push&ldquo; &uuml;bergegeben. Die Ressourcen wurden im &lt;VirtualHost&gt; folgenderma&szlig;en aufgelistet: alle CSS Dateien, danach alle f&uuml;r die Startseite ben&ouml;tigten Schriften. </P
><P 

>Damit gepushte &bdquo;Streams&ldquo; die HTML Datei nicht verz&ouml;gern, wird der Parameter &bdquo;After&ldquo; verwen-det. In diesem experimentellen Fall wurden in der HTTP/2 &ndash; Serverkonfiguration innerhalb der &bdquo;H2PushPriority&ldquo;-Direktive f&uuml;r CSS Dateien und Schriften die gleichen Gewichte &uuml;bergegeben, um zu schauen, wie die Bandbreite zwischen den &bdquo;Streams&ldquo; aufgeteilt wird: </P
><P 

>H2PushPriority text/css after  256 </P
><P 

>H2PushPriority application/x-font-woff after  256 (Behnke 2013) </P
><P 

>H2PushPriority application/x-font-truetype  after  256 (Behnke 2013) </P
><P 

> </P
><P 

>Mit den in diesem Test eingestellten Gewichten ist zu erwarten, dass die Frames von CSS Da-teien und Schriften die verf&uuml;gbare Bandbreite gleichm&auml;&szlig;ig zwischen sich aufteilen werden. Dies </P
><P 

>bedeutet, dass sich die &bdquo;Frames&ldquo; der &bdquo;Streams&ldquo; von CSS Dateien und Schriften w&auml;hrend der Lieferung zum Client regelm&auml;&szlig;ig abwechseln sollten. </P
><P 

>Die Webapplikation wurde am lokalen PC mithilfe des Browsers &bdquo;Mozilla Firefox&ldquo; mit Version 47.0 aufgerufen. Die Reihenfolge und die Priorit&auml;ten von einzelnen Frames wurden mithilfe von &bdquo;Wireshark&ldquo; genauer untersucht. </P
><P 

><I>Testergebnisse</I><B><I>:</I> </B>aus dem Datenmittschnitt in &bdquo;Wireshark&ldquo; sieht man, dass PUSH_PROMISE &ndash; Fra-mes genau in der Reihenfolge zum Client geliefert werden, wie die dazugeh&ouml;rigen Ressourcen im &lt;VirtualHost&gt; gelistet sind. Nach diesem Moment ist zu erwarten, dass entweder der Server die Priorit&auml;ten zum Client schicken wird oder der Client mithilfe von PRIORITY &ndash; Frames unter-schiedliche Gewichte f&uuml;r die &bdquo;Streams&ldquo; der Webschriften und der CSS Dateien setzen wird. Sehr erstaunlich ist, dass alle vom Client gesendeten PRIORITY &ndash; Frames das gleiche Gewicht (Weight: 1) haben. Dies passiert wahrscheinlich, weil die Gewichte f&uuml;r CSS Dateien und Schriften in der HTTP/2 &ndash; Serverkonfigurationsdatei gleich eingestellt wurden. </P
><P 

>Nachdem fast alle PRIORITY &ndash; Frames geliefert wurden, kommt der HEADERS &ndash; Frame, gefolgt vom DATA &ndash; Frame des &bdquo;Streams&ldquo; der HTML Datei (siehe die Datei &bdquo;Mitschnitt Start-seite.pcapng&ldquo;). Danach erreicht den Client der letzte PRIORITY &ndash; Frame des letzten &bdquo;Streams&ldquo; der gepushten Ressource. </P
><P 

>Wie fr&uuml;her erw&auml;hnt wurde, werden HEADERS- und DATA &ndash; Frames von &bdquo;Streams&ldquo; der gepush-ten Ressourcen den Client in der FIFO-Reihenfolge erreichen. Es ist eher zu erwarten, dass Fra-mes der gepushten Ressourcen durchgemischt wurden, weil die Bandbreite zwischen CSS Da-teien und Schriften gleichm&auml;&szlig;ig aufgeteilt wurde. </P
><P 

>Noch zu bemerken ist, dass innerhalb des HEADERS &ndash; Frames der gepushten Dateien, die vom Server an den Client geschickt werden, steht, dass diese keine Priorit&auml;ten haben. Dies kann man innerhalb des &bdquo;Flags=Priority: false&ldquo; sehen. Dies signalisiert, dass keine Abh&auml;ngig-keiten und Gewichte f&uuml;r den aktuellen &bdquo;Stream&ldquo; gesetzt wurden (Belshe et al. 2015, 34). </P
><P 

> </P
><P 

><I>Zusammenfassung: Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien und Schriften.</I><I> </I></P
><P 

>Aus den Ergebnissen des aktuellen Tests kann man sagen, dass in diesem Fall die Priorisierun-gen der gepushten Ressourcen, die serverseitig eingestellt wurden, nicht funktioniert haben. Per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen werden letzten Endes clientseitig priorisiert. Trotz der Erwartungen, werden &bdquo;Streams&ldquo; der gepushten Ressourcen w&auml;hrend der Lieferung nicht miteinander vermischt. </P
><P 

>Alle gepushten Ressourcen erreichen den Client genau in der Reihenfolge, in der sie innerhalb des &lt;VirtualHost&gt; aufgelistet wurden. Die Einstellungen in der &bdquo;H2PushPriority&ldquo;-Direktive ha-ben in diesem Fall nichts ver&auml;ndert. Es wird im n&auml;chsten Test untersucht, ob die Priorit&auml;ten mit anderen Einstellungen besser funktionieren. </P
><P 

>Au&szlig;erdem ist es interessant zu betrachten, wie die Ressourcenreihenfolge in den Entwick-lertools des Browsers aussieht. Aus dem Ressourcenwasserfall sieht man, dass die CSS Dateien als erste den Client erreichen. Gleichzeitig sieht man, dass die per &bdquo;Server Push&ldquo; &uuml;bergebenen Schriften ganz am Ende geladen werden. Aus dem Datenmitschnitt von &bdquo;Wireshark&ldquo; ist jedoch ersichtlich, dass dies nicht der Fall ist und Schriften gleich nach den CSS Dateien ankommen. Dies k&ouml;nnte bedeuten, dass die Implementierung der Entwicklertools in &bdquo;Mozilla Firefox&ldquo; f&uuml;r die &bdquo;Server Push&ldquo;-Technologie noch nicht bereit ist. </P
><H3 

><FONT size="+1">5.3.2. Test 2: Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien und Bildern </H3
><P 

><FONT size="+1"><I>Testbedingungen:</I> untersucht wurde die Dozenten-Seite (dozentent2.html) der Webapplikation. Es wurden alle f&uuml;r die Seite ben&ouml;tigten CSS Dateien (acht St&uuml;ck) und 10 nicht-kritische kleine Bilder per &bdquo;Server Push&ldquo; &uuml;bergeben. Die Ressourcen wurden im &lt;VirtualHost&gt; folgenderma&szlig;en aufgelistet: zuerst alle CSS Dateien, danach die Bilder. </P
><P 

>Damit gepushte &bdquo;Streams&ldquo; die HTML Datei nicht verz&ouml;gern werden, wird der Parameter &bdquo;After&ldquo; verwendet. In diesem Beispiel wurden innerhalb der HTTP/2 &ndash; Serverkonfiguration f&uuml;r CSS Da-teien und Bilder unterschiedliche Gewichte &uuml;bergegeben. Um genau zu schauen, wie Priorit&auml;-ten funktionieren, wird ein simulierter Fall verwendet, in dem alle &bdquo;.jpg&ldquo; Dateien h&ouml;here Priorit&auml;t haben, als die CSS Dateien: </P
><P 

>H2PushPriority text/css               after  256 </P
><P 

>H2PushPriority image/jpeg             after 512 </P
><P 

> </P
><P 

>Mit den eingestellten Gewichten in diesem Test ist zu erwarten, dass alle &bdquo;Frames&ldquo; von &bdquo;Streams&ldquo; der *.jpg &ndash; Ressourcen als erste den Client erreichen werden. Danach sollten alle CSS Dateien dem Client zugestellt werden. </P
><P 

> </P
><P 

>Die Webapplikation wurde am lokalen PC mithilfe des Browsers &bdquo;Mozilla Firefox&ldquo; mit Version 47.0 aufgerufen. Die Lieferreihenfolge der &bdquo;Streams&ldquo; der gepushten Ressourcen und die Prio-rit&auml;ten der einzelnen &bdquo;Frames&ldquo; wurde mithilfe von &bdquo;Wireshark&ldquo; genauer untersucht. </P
><P 

><I>Testergebnisse</I><B>: </B>aus dem Datenmittschnitt von &bdquo;Wireshark&ldquo; sieht man, dass PUSH_PROMISE Fra-mes genau in der Reihenfolge zum Client geliefert werden, wie die dazugeh&ouml;rigen Dateien im &lt;VirtualHost&gt; gelistet wurden. Danach, wie im fr&uuml;heren Test, setzt der Browser die Priorit&auml;ten f&uuml;r alle vom Server ge&ouml;ffneten &bdquo;Streams&ldquo;. Alle vom Browser erzeugten PRIORITY &ndash; Frames ha-ben erstaunlicherweise das gleiche Gewicht. Nach dem 13. PRIORITY &ndash; Frame wird der HEA-DERS &ndash; Frame der HTML Datei den Client erreichen. Danach kommen die restlichen PRIO-RITY &ndash; Frames gefolgt vom DATA &ndash; Frame der HTML Datei (siehe die Datei &bdquo;Mitschnitt Dozen-ten2.pcapng&ldquo;). </P
><P 

>Interessant zu bemerken ist, dass zuerst alle CSS Dateien den Client erreichen, obwohl h&ouml;here Priorit&auml;ten in der HTTP/2 &ndash; Serverkonfigurationsdatei f&uuml;r &bdquo;.jpg&ldquo; Dateien gesetzt wurden. </P
><P 

>Bei der Lieferung stimmt die Reihenfolge der gepushten Bilder ab dem 22. &bdquo;Stream&ldquo; nicht mehr ganz. Nachdem der DATA &ndash; Frame f&uuml;r die 22. &bdquo;Stream&ldquo;-Id zugestellt wurde, werden die HEA-DERS &ndash; Frames zuerst f&uuml;r den 34. bis 38. &bdquo;Stream&ldquo; zugestellt und dann f&uuml;r den 24. bis 30 &bdquo;Stream&ldquo; an den Client geliefert (siehe die Dateien auf dem beigelegten Datentr&auml;ger). Die DATA &ndash; Frames behalten diese Reihenfolge. Leider &auml;ndert sich diese Vorgehensweise nicht sehr: CSS Dateien wurden trotzdem zuerst dem Client zugestellt. </P
><P 

>Genauso wie im vorherigen Test, wurde bemerkt, dass innerhalb des HEADERS &ndash; Frames der gepushten Dateien steht, dass diese keine Priorit&auml;ten haben. Dies kann man innerhalb des &bdquo;Flags=Priority: false&ldquo; sehen. Dies best&auml;tigt, dass serverseitige Priorisierungen nicht funktioniert haben. </P
><P 

><I>Zusammenfassung: Priorisie</I><I>rung von per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien und </I><I>Bildern.</I><B><I> </I></P
><P 

></B>Die Ergebnisse des aktuellen Tests sind zu den Ergebnissen des fr&uuml;heren Tests sehr &auml;hnlich. Priorisierungen werden clientseitig erstellt. Au&szlig;erdem haben diese das gleiche Gewicht, ob-wohl dieses serverseitig unterschiedlich eingestellt wurde. </P
><P 

>Auch dieses Beispiel hat gezeigt, dass die Einstellungen in der &bdquo;H2PushPriority&ldquo;-Direktive an der Ressourcenreihenfolge der gepushten Ressourcen nicht viel &auml;ndert. Daf&uuml;r wurde noch keine Erkl&auml;rung gefunden. Es k&ouml;nnte entweder daran liegen, dass sich das &bdquo;mod_http2&ldquo;-Modul noch im experimentalen Stadium befindet (Apache Software Foundation 2016a) und nicht im-mer funktioniert, wie in der Dokumentation steht. Oder es liegt evtl. daran, dass die vom Server erstellten Gewichte f&uuml;r &bdquo;Streams&ldquo; gepushter Ressourcen vom Browser (im aktuellen Fall Mozilla Firefox, 47.0) nicht akzeptiert werden. </P
><H2 

><FONT size="+1">5.4. Zwischenfazit: Serverseitige Priorisierung von per &bdquo;Server Push&ldquo;  &uuml;bergebenen Ressourcen </H2
><P 

><FONT size="+1">Aus den zuvor gemachen Tests kann man sagen, dass serverseitige Einstellungen in der &bdquo;H2PushPriority&ldquo;-Direktive keinen Einfluss auf die Priorisierung der gepushten Ressourcen ha-ben. Erstaunlicherweise werden Priorit&auml;ten nur clientseitig gesetzt. Dazu kommt noch, dass f&uuml;r alle &bdquo;Streams&ldquo; der gepushten Ressourcen gleiche Gewichte gesetzt werden, wenn diese unter-schiedlich serverseitig eingestellt werden. Noch zu bemerken ist, dass innerhalb des HEA-DERS &ndash; Frames der gepushten Dateien, die vom Server an den Client geschickt werden, steht, dass diese keine Priorit&auml;ten haben. </P
><P 

>Falls diese Einstellungen nicht innerhalb der HTTP/2 &ndash; Serverkonfigurationsdatei gemacht wer-den m&uuml;ssen, wurden noch Versuche gemacht, um die Einstellungen der &bdquo;H2PushPriority&ldquo;-Di-rektive innerhalb des &lt;VirtualHost&gt; zu platzieren. Dies hat aber die gleichen Ergebnisse ge-zeigt. </P
><P 

>Bisher ist noch nicht klar, welche Probleme auf dem Weg zur serverseitigen Priorisierung liegen. Dies k&ouml;nnte sowohl auf der Server- als auch auf der Clientseite liegen, wie es im Zwischenfazit der oben durchgef&uuml;hrten Tests erw&auml;hnt wurde.  </P
><P 

>Jetzt stellt sich die Frage, was diese Verhaltensweise f&uuml;r die Servereinstellungen bedeuten. Wie m&uuml;ssen Ressourcen per &bdquo;Server Push&ldquo; &uuml;bergegeben werden, wenn serverseitige Priorisierun-gen nicht funktionieren? Vermutlich gibt es nur einen Weg: falls mehrere unterschiedliche Res-sourcentypen gepusht werden, m&uuml;ssen sie im &lt;VirtualHost&gt; genauso aufgelistet sein, dass kritische Ressourcen beim Herunterladen nicht blockiert werden. D.h., wenn CSS Dateien und Schriften gepusht werden sollen, ist es sinnvoll, zuerst alle CSS Dateien aufzulisten und erst danach die Schriften. </P
><H2 

><FONT size="+1">5.5. Untersuchungen zum &bdquo;Server Push&ldquo; </H2
><P 

><FONT size="+1">Zuvor wurde die Funktionsweise mit dem Apache-Server schon kurz erw&auml;hnt und es wurden Vermutungen aufgestellt, wof&uuml;r &bdquo;Server Push&ldquo; angewendet werden kann und wie er am besten benutzt werden k&ouml;nnte. Um die Vermutungen zu pr&uuml;fen, werden in den folgenden Tests un-terschiedliche Eins&auml;tze f&uuml;r die Verwendung des &bdquo;Server Pushs&ldquo; untersucht. </P
><P 

>Zu untersuchende Parameter: </P
><DL 

><DD 

>&#61630; &bdquo;Time To First Byte&ldquo; </DD
></DL
><P 

>Zeigt an, wann das erste Byte der HTML Datei den Client erreicht. Wie im fr&uuml;heren Test zur Untersuchung des &bdquo;Server Pushes&ldquo; bemerkt wurde, passieren einige Schritte zwi-schen Client und Server, bevor die Daten der HTML Datei den Client erreichen. Dieser Parameter k&ouml;nnte sich mit zunehmender Anzahl von gepushten Ressourcen verz&ouml;gern. </P
><DL 

><DD 

>&#61630; DOM Erstellung </DD
></DL
><P 

>Zeigt, ob der &bdquo;Server Push&ldquo; Einsatz einen Einfluss auf die Erstellung des DOMs hat. Die Verz&ouml;gerung der DOM-Erstellung k&ouml;nnte einen Einfluss auf den Parameter &bdquo;Start Ren-der&ldquo; haben. </P
><DL 

><DD 

>&#61630; &bdquo;Start Render&ldquo; </DD
></DL
><P 

>Zeigt, zu welchem Zeitpunkt der Webbrowser anf&auml;ngt, etwas im Viewport zu zeichnen. </P
><DL 

><DD 

>&#61630; &bdquo;Bytes Out&ldquo; </DD
></DL
><P 

>Zeigt, wie viele Bytes vom Client gesendet werden, um Ressourcen anzufragen (Re-quests). Da sich dieser Parameter von Test zu Test innerhalb einer Testreihe (innerhalb der durchgef&uuml;hrten 27 Tests) kaum unterscheidet, wird dieser nur anhand von neun durchgef&uuml;hrten Tests gemessen. Es gibt kaum einen Unterschied zwischen den Para-metern &bdquo;Bytes Out&ldquo; unter Kabel- oder 3G-Verbindung. </P
><DL 

><DD 

>&#61630; &bdquo;domComplete&ldquo; </DD
></DL
><P 

>Zeigt, wie lange es gebraucht hat, bis alle zur Webapplikation geh&ouml;rigen Ressourcen heruntergeladen wurden. </P
><P 

>  </P
><DL 

><DD 

>&#61630;  &bdquo;Visual Progress&ldquo; </DD
></DL
><P 

>Zeigt, wie schnell die Inhalte der Webapplikation (prozentual gesehen) auf dem Viewport erscheinen. </P
><P 

>Wenn die Ergebnisse der Erstdarstellung durch den &bdquo;Server Push&ldquo; &ndash; Einsatz Vorteile bringen werden, werden die Parameter &bdquo;Start Render&ldquo; und &bdquo;domComplete&ldquo; unter einer 3G-Verbindung zus&auml;tzlich gepr&uuml;ft. Es wird davon ausgegangen, dass sich der Parameter &bdquo;Time To First Byte&ldquo; und die DOM-Erstellung durch den &bdquo;Server Push&ldquo; &ndash; Einsatz auf gleiche Weise verhalten werden, wie unter Kabel-Verbindung. Aus diesem Grund werden sie nicht noch zus&auml;tzlich unter einer 3G-Verbindung gepr&uuml;ft. </P
><P 

>Es wurden immer zwei unterschiedliche Eins&auml;tze miteinander verglichen. Fast f&uuml;r jeden Einsatz wurde die Webapplikation mithilfe des &bdquo;Webpagetest.org&ldquo; &ndash; Tools 27 Mal aufgerufen. Alle Da-ten zur Parameteruntersuchung wurden heruntergeladen. Als Ausrufepunkt der Webapplika-tion wurde der Ort Frankfurt a.M. in Deutschland gew&auml;hlt. </P
><P 

>Es werden folgende Daten aufgenommen: &bdquo;Page Data&ldquo;: Daten, die die gesamten Werte der &bdquo;Navigation Timing API&ldquo; liefern; &bdquo;Object Data&ldquo;: Daten, die die gesamten Werte der&ldquo; Resource Timing API&ldquo; liefern; &bdquo;*.har&ldquo;: Datei, die alle Informationen zum gesamten Navigationsraum lie-fert. Au&szlig;erdem wurden die Screenshots vom Viewport des Browsers aufgenommen, um pr&uuml;fen zu k&ouml;nnen, wie und in welcher Reihenfolge die Ressourcen auf dem Viewport erscheinen.  </P
><H3 

><FONT size="+1">5.5.1. Test 1: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r kritische CSS Ressourcen </H3
><P 

><FONT size="+1">Es wird nichts im Viewport angezeigt, bevor das CSSOM nicht fertig gebaut ist. Wie schon im theoretischen Teil beschrieben wurde, muss man, um die Ladezeit der Webapplikation be-schleunigen zu k&ouml;nnen, so schnell wie m&ouml;glich die notwendigen CSS Ressourcen an den Client &uuml;bergeben. Aus diesem Grund k&ouml;nnte der &bdquo;Server Push&ldquo; &ndash; Einsatz sehr praktisch sein. Dadurch wird der Client Bytes f&uuml;r Anfragen und die daf&uuml;r gebrauchte Zeit sparen. Es ist zu erwarten, dass erste Pixel im Viewport schneller gezeichnet werden, als ohne &bdquo;Server Push&ldquo; mit CSS Da-teien. M&ouml;glicherweise wird sich dadurch auch die Gesamtladezeit verk&uuml;rzen. </P
><P 

><I>Testbedingungen</I>: untersucht wurde die Startseite der Webapplikation. Im Fall der Anwendung mit &bdquo;Server Push&ldquo; wurden alle f&uuml;r die Seite ben&ouml;tigten CSS Dateien (10 St&uuml;ck) per &bdquo;Server Push&ldquo; &uuml;bergeben. CSS und JavaScript Dateien werden f&uuml;r das HTTP/2 &ndash; Protokoll aufgeteilt. <B> </P
><P 

></B>Im aktuellen Test wird gepr&uuml;ft, wie weit die wichtigsten Parameter des kritischen Ren-dering &ndash; Pfades durch den Einsatz von &bdquo;Server Push&ldquo; mit CSS Dateien beeinflusst werden. Au-&szlig;erdem wird geschaut, wie sich die Ladezeit der Webapplikation und die Darstellung im Viewport &auml;ndern werden. </P
><P 

>  </P
><P 

>&bdquo;Time To First Byte&ldquo; </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_21.jpg" ><DL 

><DD 

></B><I>Abb. 21:</I><I> </I><I>Vergleich des Parameters &bdquo;Time To First Byte&ldquo; mit und ohne &bdquo;Server Push&ldquo; mit</I><I> CSS Da-teien, jeweils mit Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2:  Ohne &bdquo;Server Push&ldquo; </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>42 ms </P
></TD
><TD  
 valign="top"
><P 

>41 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>42 ms </P
></TD
><TD  
 valign="top"
><P 

>40 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>44 ms </P
></TD
><TD  
 valign="top"
><P 

>41 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 5:</I><I> </I><I>Vergleich des Parameters &bdquo;Time To First Byte&ldquo; mit und ohne</I><I> </I><I>&bdquo;Server Push&ldquo; mit CSS Da-</I><I>teien, jeweils mit Kabel-Verbindung. </I></DD
></DL
><P 

>Aus oben dargestelltem Boxplot-Diagramm kann man erkennen, dass der Parameter &bdquo;Time To First Byte&ldquo; f&uuml;r die Anwendung mit &bdquo;Server Push&ldquo; mit CSS Dateien ein wenig sp&auml;ter ausgef&uuml;hrt wird. Der Unterschied zur Anwendung ohne &bdquo;Server Push&ldquo; betr&auml;gt im Durchschnitt 1 ms.  </P
><P 

>Wie zuvor vermutet wurde, wurde etwas Zeit in Anspruch genommen, um alle PUSH_PRO-MISE &ndash; Frames zum Client zu liefern und die &bdquo;Streams&ldquo; der gepushten Ressourcen zu priorisie-ren. Im aktuellen Fall wird eine Kabel-Verbindung benutzt und nur 10 CSS Dateien per &bdquo;Server Push&ldquo; &uuml;bergeben. Aus diesem Grund ist die Verz&ouml;gerung dieses Parameters nicht gro&szlig;. </P
><P 

>DOM Erstellung </P
><P 

>Aus Abb. 22 l&auml;sst sich schlie&szlig;en, dass die DOM Erstellung mit &bdquo;Server Push&ldquo; im Durchschnitt etwas sp&auml;ter als bei der Anwendung ohne &bdquo;Server Push&ldquo; beendet wird. Die ersten 50% der Werte der ersten Messreihe liegen zwischen 117 ms und 143 ms und der Unterschied zwischen den Medianwerten liegt bei 12 ms. </P
><P 

>Der Grund daf&uuml;r, wie zuvor bereits vermutet wurde, liegt daran, dass PUSH_PROMISE &ndash; Frames und die folgende Priorisierung etwas Zeit in Anspruch nehmen. Dies k&ouml;nnte die Erstellung des DOMs etwas bremsen. </P
><P 

><B> </P
><IMG width="601" height="236"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_22.jpg" ><DL 

><DD 

></B><I>Abb. 22:</I><I> </I><I>Vergleich der Zeit zur DOM Erstellung unter Einsatz von &bdquo;Server Push&ldquo; mit CSS Da</I><I>teien </I><I>und ohne den Einsatz von &bdquo;Server Push&ldquo;, jeweils mit Kabel</I><I>-Verbindung.  </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2:  Ohne &bdquo;Server Push&ldquo; </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>143 ms </P
></TD
><TD  
 valign="top"
><P 

>131 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>133,5 ms </P
></TD
><TD  
 valign="top"
><P 

>128 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>148,5 ms </P
></TD
><TD  
 valign="top"
><P 

>156,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 6:</I><I> </I><I>Vergleich der </I><I>Zeit zur DOM Erstellung unter Einsatz von &bdquo;Server Push&ldquo; mit CSS Dateien und ohne den Einsatz von &bdquo;Server Push&ldquo;, jeweils mit Kabel</I><I>-Verbindung.  </I></DD
></DL
><P 

>&bdquo;Start Render&ldquo; </P
><P 

>Aus Abb. 23 ist zu sehen, dass &bdquo;Server Push&ldquo; mit CSS Dateien einen gro&szlig;en Einfluss auf den &bdquo;Start Render&ldquo; &ndash; Parameter hat. Die Werte des Parameters bei der Anwendung mit &bdquo;Server Push&ldquo; werden deutlich fr&uuml;her ausgegeben als bei der Anwendung ohne &bdquo;Server Push&ldquo;. Die mitt-leren 50% der Werte der Anwendung mit &bdquo;Server Push&ldquo; befinden sich zwischen 781 ms und 897,5 ms. Der Unterschied zwischen den Medianwerten liegt bei 213 ms. </P
><P 

>Aus Abb. 24 ist ersichtlich, dass der Parameter &bdquo;Start Render&ldquo; unter Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien deutlich schneller ausgegeben wurde, als ohne &bdquo;Server Push&ldquo; &ndash; Einsatz. Der Unterschied zwischen den Medianwerten liegt bei 304 ms. </P
><P 

>Je schneller DOM und CSSOM aufgebaut werden, desto schneller wird der Render &ndash; Baum fer-tiggestellt und desto schneller wird der Browser im Viewport erste Pixel zeichnen. Obwohl der Aufbau des DOMs etwas verz&ouml;gert wird, werden im Fall der Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien keine Anfragen an CSS Ressourcen geschickt. Dadurch werden mehrere Bytes in-nerhalb einer TCP &ndash; Verbindung gespart und die Dateien erreichen den Client schneller. Im aktuellen Fall liegt der Unterschied bei 213 ms unter Kabel-Verbindung und 304 ms unter 3G-Verbindung und k&ouml;nnte damit eine gro&szlig;e Rolle bei der User Experience spielen.  </P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_23.jpg" ><DL 

><DD 

><I>Abb. 23:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; beim Einsatz von &bdquo;Server Push&ldquo; mit CSS Dateien </I><I>und </I><I>ohne Anwendung von &bdquo;Server Push&ldquo;</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2:  Ohne &bdquo;Server Push&ldquo; </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>784 ms </P
></TD
><TD  
 valign="top"
><P 

>997 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>781 ms </P
></TD
><TD  
 valign="top"
><P 

>971 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>897,5 ms </P
></TD
><TD  
 valign="top"
><P 

>1025,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 7:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; beim Einsatz von &bdquo;Server Push&ldquo; mit CSS Dateien und ohne Anwendung von &bdquo;Server Push&ldquo;, jeweils mit Kabel</I><I>-Verbindung.  </I></DD
></DL
><P 

><I> </I></P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_24.jpg" ><DL 

><DD 

><I>Abb. 24:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung von &bdquo;Server Push&ldquo; mit CSS Da-teien und ohne Anwendung von &bdquo;Server Push&ldquo;, jeweils mit einer 3G</I><I>-Verbindung. </I></DD
></DL
><P 

>  </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: Ohne &bdquo;Server Push&ldquo; </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>3076 ms </P
></TD
><TD  
 valign="top"
><P 

>3383 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>2982,5 ms </P
></TD
><TD  
 valign="top"
><P 

>3380,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>3082 ms </P
></TD
><TD  
 valign="top"
><P 

>3474 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 8:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung von &bdquo;Server Push&ldquo; mit CSS Da-teien und ohne Anwendung von &bdquo;Server Push&ldquo;, jeweils mit einer 3G</I><I>-Verbindung. </I></DD
></DL
><P 

> &bdquo;Bytes Out&ldquo; </P
><P 

>Mithilfe von &bdquo;Server Push&ldquo; &ndash; Einsatz mit CSS Dateien ist es gelungen, um im Vergleich zu den Testreihen ohne &bdquo;Server Push&ldquo; 346 Bytes pro Testreihe zu sparen. </P
><P 

>&bdquo;domComplete&ldquo; </P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_25.jpg" ><DL 

><DD 

><I>Abb. 25:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien und ohne Einsatz von &bdquo;Server Push&ldquo;, jeweils mit Kabel</I><I>-Verbindung.  </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: Ohne &bdquo;Server Push&ldquo; </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>1823 ms </P
></TD
><TD  
 valign="top"
><P 

>1843 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>1809,5 ms </P
></TD
><TD  
 valign="top"
><P 

>1822 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>1834,5 ms </P
></TD
><TD  
 valign="top"
><P 

>1852 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 9:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung von &bdquo;Server Push&ldquo; mit CSS Da-teien und ohne Einsatz von &bdquo;Server Push&ldquo;, jeweils mit Kabel</I><I>-Verbindung.  </I></DD
></DL
><P 

>Aus Abb. 25 ist zu erkennen, dass die gesamte Ladezeit der HTML Datei und allen davon ab-h&auml;ngigen Ressourcen bei der Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien im Durchschnitt etwas k&uuml;rzer ist, als ohne &bdquo;Server Push&ldquo;. Der Unterschied zwischen den Medianwerten liegt bei 20 ms. </P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_26.jpg" ><DL 

><DD 

><I>Abb. 26:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei &bdquo;Server Push&ldquo;</I><I> - Einsatz mit CSS Dateien </I><I>und ohne Anwendung von &bdquo;Server Push&ldquo;, jeweils mit 3G</I><I>-Verbindung.  </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: Ohne &bdquo;Server Push&ldquo; </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>5615 ms </P
></TD
><TD  
 valign="top"
><P 

>5939 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>5575 ms </P
></TD
><TD  
 valign="top"
><P 

>5759,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>5766 ms </P
></TD
><TD  
 valign="top"
><P 

>6013,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 10:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei &bdquo;Server Push&ldquo;</I><I> - Einsatz mit CSS Dateien </I><I>und ohne Anwendung von &bdquo;Server Push&ldquo;, jeweils mit 3G</I><I>-Verbindung. </I></DD
></DL
><P 

>Aus Abb. 26 ist zu sehen, dass alle Ressourcen mit &bdquo;Server Push&ldquo; &ndash; Einsatz unter 3G-Verbindung deutlich schneller geladen werden, als ohne &bdquo;Server Push&ldquo;. Der Unterschied zwischen den Me-dianwerten betr&auml;gt 324 ms. </P
><P 

>Man sieht, dass sowohl unter Kabel-Verbindung als auch unter 3G-Verbindung die Gesamtla-dezeit beim &bdquo;Server Push&ldquo; &ndash; Einsatz mit CSS Ressourcen schneller ist als ohne &bdquo;Server Push&ldquo;. Die Erkl&auml;rung daf&uuml;r ist, dass manche Ressourcen nicht angefragt werden m&uuml;ssen (weil sie be-reits durch den &bdquo;Server Push&ldquo; &uuml;bergeben wurden) und die Gesamtladezeit dadurch verringert wird. Unter 3G-Verbindung wird der Unterschied zwischen den Medianwerten noch st&auml;rker. </P
><P 

>&bdquo;Visual Progress&ldquo; </P
><P 

>Aus Abb. 27 ist zu ersehen, dass mithilfe von &bdquo;Server Push&ldquo; erste Pixel etwas fr&uuml;her im Browser erscheinen werden. Allerdings sieht man, dass beide Anwendungen etwa den gleichen &bdquo;Visual Progress&ldquo; haben. Aus den aufgenommenen Screenshots sieht man das gleiche. </P
><P 

><B> </P
><IMG width="468" height="328"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_27.jpg" ><DL 

><DD 

></B><I>Abb. 27:</I><I> </I><I> </I><I>&bdquo;Visual Progress&ldquo; bei Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien und bei der An-wendung ohne &bdquo;Server Push&ldquo; unter Kabel</I><I>-Verbindung. </I></DD
></DL
><H3 

><FONT size="+1">5.5.2. Zwischenfazit: lohnt sich die &Uuml;bergabe von CSS Dateien per &bdquo;Server Push&ldquo; im Vergleich zur Anwendung ohne &bdquo;Server Push&ldquo;? </H3
><P 

><FONT size="+1">Wie man anhand der Boxplot-Diagramme zum DOM-Aufbau sehen kann, wird die Erstellung des DOMs im Fall der Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien etwas verz&ouml;gert. Dies ist auch beim Parameter &bdquo;Time To First Byte&ldquo; zu beobachten. Dies passiert durch die &Uuml;bergabe der PUSH_PROMISE &ndash; Frames und weiterer Streampriorisierungen von CSS Dateien. Allerdings werden mithilfe von &bdquo;Server Push&ldquo; 346 Anfragebytes pro Testreihe gespart. Dadurch erreichen kritische CSS Dateien den Client schneller. Aufgrund dessen, dass DOM und CSSOM parallel aufgebaut werden (Grigorik 2013, 168), wird der Render &ndash; Baum fr&uuml;her zur Verf&uuml;gung gestellt. Als Folge werden die ersten Pixel im Viewport schneller erscheinen. Dieses Beispiel hat dies best&auml;tigt: im aktuellen Fall unter Kabel-Verbindung betr&auml;gt der durchschnittliche Unterschied im Vergleich zur Anwendung ohne &bdquo;Server Push&ldquo; mehr als 1/5 Sekunde. Die Gesamtladezeit aller Ressourcen (load-Event) wird auch im Fall des Einsatzes von &bdquo;Server Push&ldquo; mit CSS Dateien weniger dauern. </P
><P 

>Wenn dieser Test unter 3G-Verbindung durchgef&uuml;hrt wird, sieht man, dass sich die Ergebnisse im Vergleich zu den Ergebnissen mit Kabel-Verbindung noch verdeutlichen. Demnach kann gesagt werden, dass die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien unter mobilen Netz-werken auf jeden Fall lohnenswert ist. </P
><H3 

><FONT size="+1">5.5.3. Test 2: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r nicht kritische JavaScript Ressourcen </H3
><P 

><FONT size="+1">JavaScript Dateien werden die Erstellung des DOMs und CSSOMs verlangsamen, sofern diese nicht als &bdquo;nicht kritisch&ldquo; durch die &bdquo;defer&ldquo; oder &bdquo;async&ldquo; Attribute markiert werden. </P
><P 

>Es stellt sich die Frage, ob per &bdquo;Server Push&ldquo; &uuml;bergebene nicht-kritische (mit dem Attribut &bdquo;de-fer&ldquo; oder &bdquo;async&ldquo; versehene) JavaScript Dateien auch einen Vorteil im Vergleich zur Anwendung ohne &bdquo;Server Push&ldquo; haben werden. Wenn man allerdings die Funktionsweise des &bdquo;Server Pushs&ldquo; betrachtet, sieht man, dass &bdquo;Server Push&ldquo; alle Dateien an den Client schickt und der Browser in diesem Fall keine Chance haben wird, um die Skripte nach &bdquo;kritisch&ldquo; oder &bdquo;nicht-kritisch&ldquo; zu sortieren. Die Attribute &bdquo;async&ldquo; und &bdquo;defer&ldquo; sind nur Hinweise f&uuml;r den Browser, die von Server-Seite ignoriert werden. </P
><P 

>Aus diesem Grund kann man sagen, dass JavaScript Ressourcen nur dann per &bdquo;Server Push&ldquo; &uuml;bergeben werden sollten, wenn sie tats&auml;chlich kritisch sind. Genauso wie kritische CSS Res-sourcen. Allerdings muss man entweder die Priorisierung der gepushten Ressourcen benutzen oder die Reihenfolge der Lieferung beachten, sodass JavaScript Dateien den Aufbau des CSSOM nicht blockieren werden. </P
><H3 

><FONT size="+1">5.5.4. Test 3: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r kritische CSS Ressourcen und nicht kriti-sche Ressourcen (Schriften) </H3
><P 

><FONT size="+1">Webschriften sind f&uuml;r die Erstdarstellung der Webapplikation nicht prim&auml;r wichtig. Allerdings haben manche Webapplikationen gro&szlig;e &Uuml;berschriften mit einer besonderen Schriftart auf der Seite. Manche Browser geben den Webschriften relativ niedrige Priorisierungseinstufungen (Grigorik 2016i), deshalb werden sie als letzte von allen Ressourcen heruntergeladen. Dies be-deutet, dass sie auch ganz am Ende der Ladezeit der aufgerufenen Seite erscheinen. Es ist auch m&ouml;glich, dass sie zuerst in Form einer Standard-Webschrift angezeigt werden. Erst nachdem die Original-Schriften heruntergeladen wurden, wird die Standard-Webschrift ersetzt (Grigorik 2016i). Dies k&ouml;nnte aus Benutzersicht einen negativen Ersteindruck machen. Die Idee des &bdquo;Ser-ver Push&ldquo; &ndash; Einsatzes f&uuml;r die Webschriften besteht darin, dass diese so schnell wie m&ouml;glich auf dem Viewport erscheinen, wenn sie f&uuml;r den ersten Eindruck wichtig sind. Sie werden vermutlich gleich geladen, ohne dass zuerst Standard-Webschriften angezeigt werden. </P
><P 

><I>Testbedingungen</I>: untersucht wurde die Startseite der Webapplikation. Im Fall der Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien und Schriften wurden alle f&uuml;r die Seite ben&ouml;tigten CSS Da-teien (10 St&uuml;ck) und f&uuml;nf Webschriften per &bdquo;Server Push&ldquo; &uuml;bergeben. Im zweiten Fall werden nur 10 CSS Dateien per &bdquo;Server Push&ldquo; &uuml;bergeben. Nicht alle Webschriften sind f&uuml;r den Erstein-druck wichtig. Es werden in diesem experimentellen Fall nun alle Schriften (f&uuml;nf Dateien) &uuml;ber-geben, um zu schauen, wie gro&szlig; der Einfluss auf den kritischen Rendering &ndash; Pfad in diesem Fall sein k&ouml;nnte. CSS Dateien werden f&uuml;r das HTTP/2 &ndash; Protokoll aufgeteilt. <B> </P
><P 

></B>Im aktuellen Test wird gepr&uuml;ft, wie weit die wichtigsten Parameter des kritischen Ren-dering &ndash; Pfades durch den Einsatz von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften beeinflusst werden. Au&szlig;erdem wird geschaut, wie sich die Ladezeit der Webapplikation und die Darstel-lung im Viewport &auml;ndern werden. </P
><P 

>  </P
><P 

>&bdquo;Time To First Byte&ldquo; </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_28.jpg" ><DL 

><DD 

></B><I>Abb. 28:</I><I> </I><I>Vergleich des Parameters &bdquo;Time To First Byte&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; </I><I>f&uuml;r CSS Dateien und Schriften und 2. be</I><I>i der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien und Schriften </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 : &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>44 ms </P
></TD
><TD  
 valign="top"
><P 

>43ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>43 ms </P
></TD
><TD  
 valign="top"
><P 

>42 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>47 ms </P
></TD
><TD  
 valign="top"
><P 

>44 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 11:</I><I> </I><I>Vergleich des Parameters &bdquo;Time To First Byte&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><P 

>Aus Abb. 28 ist zu sehen, dass der Unterschied zwischen den Medianwerten 1 ms betr&auml;gt. Weil das obere Quartil der ersten Messreihe im Vergleich zur zweiten Messreihe um 3 ms erh&ouml;ht ist, kann man sagen, dass zus&auml;tzliche Ressourcen, die durch &bdquo;Server Push&ldquo; &uuml;bergeben werden, den Parameter &bdquo;Time To First Byte&ldquo; im Durchschnitt etwas verz&ouml;gern werden. </P
><P 

>In diesem Fall ist der Unterschied zwischen der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften und der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien nicht gro&szlig;, weil nur f&uuml;nf Schriften zus&auml;tzlich per &bdquo;Server Push&ldquo; &uuml;bergeben werden. Allerdings hat diese Verz&ouml;ge-rung die zuvor beschriebenen Vermutungen best&auml;tigt. </P
><P 

>  </P
><P 

>DOM Erstellung </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_29.jpg" ><DL 

><DD 

></B><I>Abb. 29:</I><I> </I><I>Vergleich der f&uuml;r die Erstellung des DOMs 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r </I><I>CSS Dateien und Schriften und 2</I><I>. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien und Schriften </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>143 ms </P
></TD
><TD  
 valign="top"
><P 

>133,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>134 ms </P
></TD
><TD  
 valign="top"
><P 

>143 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>203 ms </P
></TD
><TD  
 valign="top"
><P 

>148,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 12:</I><I> </I><I>Vergleich der f&uuml;r die Erstellung des DOMs 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><P 

>Aus Abb. 29 ist zu erkennen, dass die DOM-Erstellung bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften etwas verz&ouml;gert wird. Es gibt keinen Unterschied zwischen den Medianwerten. Aber man sieht, dass das untere Quartil der ersten Messreihe bei 203 ms liegt. Deshalb kann man sagen, dass die DOM-Erstellung in etwa der H&auml;lfte aller F&auml;lle sp&auml;ter fertig ist. </P
><P 

>Diese Unterschiede liegen daran, wie zuvor vermutet wurde, dass noch f&uuml;nf PUSH_PRO-MISE &ndash; Frames an den Client geliefert und diese Dateien noch priorisiert werden mussten.  Nun ist es interessant zu beobachten, wie sehr dem Parameter &bdquo;Start Render&ldquo; bei der &Uuml;bergabe zus&auml;tzlicher Ressourcen per &bdquo;Server Push&ldquo; geschadet wird. </P
><P 

>&bdquo;Start Render&ldquo; </P
><P 

>Aus Abb. 30 ist interessant zu bemerken, dass die beiden Boxplot-Diagramme &auml;hnlich zueinan-der sind. Trotz der Verz&ouml;gerung bei der DOM-Erstellung, wurde der Render &ndash; Baum bei An-</P
><P 

>wendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften genauso schnell wie bei der Anwen-dung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien erstellt. Es gibt fast keinen Unterschied zwischen den Medianwerten. </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_30.jpg" ><DL 

><DD 

></B><I>Abb. 30:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien und Schriften </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>784,5 ms </P
></TD
><TD  
 valign="top"
><P 

>784 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>780,5 ms </P
></TD
><TD  
 valign="top"
><P 

>781 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>883,5 ms </P
></TD
><TD  
 valign="top"
><P 

>897,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 13:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r</I><I> CSS </I><I>Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><P 

>Die Ergebnisse der Untersuchung unter 3G-Verbindung sind &auml;hnlich. Aus Abb. 31 ist zu erken-nen, dass die Spannweiten der beiden Messreihen vergleichbar sind. Nur wird der Median bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften 85 ms fr&uuml;her ausgegeben. </P
><P 

>Aus diesem Beispiel, sowohl unter Kabel- als auch unter 3G-Verbindung, sieht man, dass durch die &Uuml;bergabe von f&uuml;nf zus&auml;tzlichen Schriftdateien, die zusammen mit allen CSS Dateien ge-pusht werden, der Parameter &bdquo;Start Render&ldquo; nicht gest&ouml;rt wird. Falls mobile Netzwerkverbin-dungen verwendet werden, wird die Anwendung mit gepushten CSS Dateien und Schriften durchschnittlich schneller auf dem Viewport angezeigt.<I> </I></P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_31.jpg" ><DL 

><DD 

><I>Abb. 31:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit 3G-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien und Schriften </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>2991 ms </P
></TD
><TD  
 valign="top"
><P 

>3076 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>2980,5 ms </P
></TD
><TD  
 valign="top"
><P 

>2982,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>3082 ms </P
></TD
><TD  
 valign="top"
><P 

>3082 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 14:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CS</I><I>S </I><I>Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit 3G-Verbindung. </I></DD
></DL
><P 

>&bdquo;Bytes Out&ldquo; </P
><P 

>Mithilfe von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften ist es gelungen, um im Vergleich zu den Testreihen mit &bdquo;Server Push&ldquo; &ndash; Einsatz nur f&uuml;r CSS Dateien noch 280 Bytes pro Testreihe zu sparen. </P
><P 

>&bdquo;domComplete&ldquo; </P
><P 

>In Abb. 32 ist zu sehen, dass der Parameter &bdquo;domComplete&ldquo; bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften sp&auml;ter ausgegeben wird. Der Unterschied zwischen den Medianwerten liegt bei 50 ms.  </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_32.jpg" ><DL 

><DD 

></B><I>Abb. 32:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien und Schriften </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>1873 ms </P
></TD
><TD  
 valign="top"
><P 

>1823 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>1854 ms </P
></TD
><TD  
 valign="top"
><P 

>1809,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>1891 ms </P
></TD
><TD  
 valign="top"
><P 

>1834,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 15:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r</I><I> </I><I>CSS Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_33.jpg" ><DL 

><DD 

></B><I>Abb. 33:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r </I><I>CSS Dateien und Schriften und 2. bei der Anwendung </I><I>von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit 3G-Verbindung. </I></DD
></DL
><P 

>  </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien und Schriften </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: &bdquo;Server Push&ldquo; mit CSS Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>5800 ms </P
></TD
><TD  
 valign="top"
><P 

>5615 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>5722,5 ms </P
></TD
><TD  
 valign="top"
><P 

>5575 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>6005 ms </P
></TD
><TD  
 valign="top"
><P 

>5766 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 16:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit 3G-Verbindung. </I></DD
></DL
><P 

>Aus Abb. 33 sieht man, dass der Parameter &bdquo;domComplete&ldquo; bei der Anwendung von Server Push f&uuml;r CSS Dateien schneller ausgegeben wird. Der Unterschied zwischen den Medianwerten liegt bei 185 ms.<B> </P
><P 

></B>Es ist nun interessant, die aktuellen Ergebnisse mit den Ergebnissen des vorangegangenen Tests zu vergleichen, in welchem die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien mit der Anwendung ohne &bdquo;Server Push&ldquo; verglichen wurde (Test 1). In Test 1 konnte man sagen, dass der &bdquo;domComplete&ldquo; Parameter bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien im Mittel schneller ausgegeben wurde. </P
><P 

>Obwohl durch &bdquo;Server Push&ldquo; f&uuml;r mehr Dateien 280 Anfragebytes gespart werden, bremst im aktuellen Fall der Zusatz von f&uuml;nf Schriftdateien den &bdquo;domComplete&ldquo; Parameter. Der Unter-schied zwischen den Medianwerten dieser Parameter hat sich unter 3G-Verbindungen noch vergr&ouml;&szlig;ert. Dies l&auml;sst sich nicht sofort erkl&auml;ren und wird in weiteren Tests gepr&uuml;ft. </P
><P 

>&bdquo;Visual Progress&ldquo; </P
><P 

>Aus Abb. 34 sieht man, dass die ersten Pixel bei beiden Anwendungen fast gleichzeitig erschei-nen. Bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften wird aber sp&auml;ter der Hauptanteil (ca. 90%) des Gesamtinhaltes an den Client geliefert.  </P
><P 

>Um zu schauen, welche Inhalte tats&auml;chlich geliefert werden, muss man einen Blick in die Screenshots werfen. Es ist zu bemerken, dass in der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften die Schriften etwa 600 ms fr&uuml;her den Client erreichen und schon mit den ersten Pixeln angezeigt werden. Deshalb wurde das Ziel bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften erreicht. Allerdings ist auch zu sehen, dass die Logos in der zwei-ten Anwendung den Client fr&uuml;her erreichen. Deshalb wirkt es visuell so, als ob die Anwendung nur mit gepushten CSS Dateien schneller ist. Der Grund daf&uuml;r ist, dass das Herunterladen von Schriften viel Zeit braucht. Da gepushte Dateien gleich nach den HTML und CSS Dateien her-untergeladen werden, werden sie das Laden aller anderen Ressourcen auf der Seite bremsen.  </P
><P 

><B> </P
><IMG width="476" height="332"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_34.jpg" ><DL 

><DD 

></B><I>Abb. 34:</I><I> </I><I> </I><I>&bdquo;Visual Progress&ldquo; 1. bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Sch</I><I>riften </I><I>und 2. bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Kabel-Verbindung. </I></DD
></DL
><H3 

><FONT size="+1">5.5.5. Zwischenfazit: lohnt sich die &Uuml;bergabe von CSS Dateien und Schriften per &bdquo;Server Push&ldquo; im Vergleich zur Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien? </H3
><P 

><FONT size="+1">Denkbar sind Beispiele von Webapplikationen, bei welchen die Schriften eine gro&szlig;e Rolle bei der Erstdarstellung spielen und daher so schnell wie m&ouml;glich angezeigt werden m&uuml;ssen. Die &bdquo;Server Push&ldquo; &ndash; Anwendung kann daf&uuml;r geeignet sein. Im aktuellen Fall, wenn alle CSS Dateien mit &uuml;bergeben werden, kann sich der Einsatz von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften lohnen. Der Parameter &bdquo;Time To First Byte&ldquo; wird etwas verz&ouml;gert, weil noch f&uuml;nf zus&auml;tzliche PUSH_PROMISE &ndash; Frames mit&uuml;bergeben und deren &bdquo;Streams&ldquo; priorisiert werden. Die DOM-Er-stellung wird ebenfalls dadurch etwas verz&ouml;gert. </P
><P 

>Gleichzeitig haben diese Verz&ouml;gerungen den Parameter &bdquo;Start Render&ldquo; nicht verlangsamt und in beiden Anwendungen wurde der Parameter fast gleichzeitig angezeigt. Dies bedeutet, dass sich im aktuellen Fall die &Uuml;bergabe von zus&auml;tzlichen Schriftdateien lohnt, weil diese deutlich schneller auf dem Viewport erscheinen werden. Dies zeigt sich auch unter mobilen Netzwerken. Allerdings muss man beachten, dass gepushte Dateien alle anderen Ressourcen auf der Seite bremsen werden. Deshalb kann man sagen, dass der &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r Schriften sich dann lohnt, wenn nicht zu viele Schriften per &bdquo;Server Push&ldquo; &uuml;bergegeben werden. </P
><P 

>Obwohl im Test bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Schriften im Ver-gleich zur Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien noch mehr Anfragebytes gespart werden, wird die Zeit zum Laden aller Ressourcen verlangsamt. Im Durchschnitt liegt diese Verz&ouml;gerung bei 50 ms bei Kabel-Verbindung und bei fast 200 ms unter 3G-Verbindung. </P
><H3 

><FONT size="+1">5.5.6. Test 4: &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r kritische CSS Ressourcen und nicht  kritische Ressourcen (Bilder) </H3
><P 

><FONT size="+1">Bilder sind genauso wie Schriften f&uuml;r die Erstdarstellung auf der Seite nicht wichtig. Wenn diese Ressourcen per &bdquo;Server Push&ldquo; &uuml;bergeben werden, m&uuml;ssen alle anderen Ressourcen auf der Seite darauf warten, bis diese heruntergeladen werden. Allerdings k&ouml;nnte es auch Beispiele geben, in denen der sichtbare Teil der Internetseite fast nur aus Bildern besteht. In diesem Fall ist es interessant zu untersuchen, ob die Bilder mithilfe von &bdquo;Server Push&ldquo; schneller im Viewport erscheinen k&ouml;nnen. Zus&auml;tzlich ist es interessant zu schauen, wie sehr die Gesamtladezeit ver-k&uuml;rzt werden kann, wenn mehrere Bytes f&uuml;r Requests gespart werden. </P
><P 

><I>Testbedingungen:</I><B> </B>untersucht wurde die Dozenten-Seite der Webapplikation. Im Fall der An-wendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder, wurden alle f&uuml;r die Seite ben&ouml;tigten CSS Dateien (acht St&uuml;ck) und 43 kleine Bilder per &bdquo;Server Push&ldquo; &uuml;bergeben. Im Fall der Anwen-dung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien wurden acht CSS Dateien per &bdquo;Server Push&ldquo; &uuml;ber-geben.<B> </P
><P 

></B>Im aktuellen Test wird gepr&uuml;ft, wie weit die wichtigsten Parameter des kritischen Ren-dering &ndash; Pfades durch den Einsatz von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder beeinflusst werden. Au&szlig;erdem wird untersucht, wie sich die Ladezeit der Webapplikation und die Darstel-lung im Viewport &auml;ndern werden. </P
><P 

>&bdquo;Time To First Byte&ldquo; </P
><P 

>Wenn man beide Boxplot-Diagramme aus Abb. 35 miteinander vergleicht, sieht man, dass der Parameter &bdquo;Time To First Byte&ldquo; f&uuml;r die erste Messreihe etwas sp&auml;ter ausgegeben wird: die un-teren 75% aller Werte aus der zweiten Messreihe liegen niedriger, als die ersten Werte aus der ersten Messreihe. Der Unterschied zwischen den Medianwerten liegt bei 6 ms. </P
><P 

>Der Grund f&uuml;r diese Verz&ouml;gerung wurde bereits bei der Funktionsweise des &bdquo;Server Pushs&ldquo; beschrieben und in diesem Fall best&auml;tigt: je mehr Dateien per &bdquo;Server Push&ldquo; &uuml;bergegeben wer-den, desto mehr wird der Parameter &bdquo;Time To First Byte&ldquo; verz&ouml;gert. Im Test mit der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder, werden insgesamt 51 Dateien per &bdquo;Server Push&ldquo; &uuml;bertragen.<B> </P
><P 

></B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_35.jpg" ><DL 

><DD 

><I>Abb. 35:</I><I> </I><I>Vergleich des Parameters &bdquo;Time To First Byte&ldquo; f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r </I><I>CSS Dateien und Bilder mit der Anwe</I><I>ndung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien, jeweils mit </I><I>Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; mit CSS Da-teien und Bildern </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; mit CSS Da-teien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>50 ms </P
></TD
><TD  
 valign="top"
><P 

>44 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>50 ms </P
></TD
><TD  
 valign="top"
><P 

>44 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>52,5 ms </P
></TD
><TD  
 valign="top"
><P 

>48 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 17:</I><I> </I><I>Vergleich des Param</I><I>eters &bdquo;Time To First Byte&ldquo; f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder mit der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien, jeweils mit </I><I>Kabel-Verbindung. </I></DD
></DL
><P 

>DOM Erstellung </P
><P 

>Wenn man beide Boxplot-Diagramme aus Abb. 36 betrachtet, sieht man, dass die Werte f&uuml;r die erste Messreihe sp&auml;ter ausgegeben werden, als f&uuml;r die zweite Messreihe. Die Ausgabe der Werte der ersten Messreihe beginnt erst dann, wenn schon ca. 75% aller Daten der zweiten Messreihe ausgegeben sind. Der Unterschied zwischen den Medianwerten betr&auml;gt 18 ms.  </P
><P 

>Der Grund ist der Gleiche, wie in den fr&uuml;heren Tests: bevor die HTML Datei zu Ende geparst wird, werden alle PUSH_PROMISE &ndash; Frames den Client erreichen und die dazugeh&ouml;rigen &bdquo;Streams&ldquo; werden priorisiert. Dies bremst die Erstellung des DOMs. </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_36.jpg" ><DL 

><DD 

></B><I>Abb. 36:</I><I> </I><I>Vergleich der ben&ouml;tigten Zeiten f&uuml;r die Erstellung des DOMs f&uuml;r 1. die Anwendung von </I><I>&bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder und 2. f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r </I><I>CSS Dateien, jeweils mit Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; mit CSS Da-teien und Bildern </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; mit CSS Da-teien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>186 ms </P
></TD
><TD  
 valign="top"
><P 

>168 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>179,5 ms </P
></TD
><TD  
 valign="top"
><P 

>163 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>193 ms </P
></TD
><TD  
 valign="top"
><P 

>175 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 18:</I><I> </I><I>Vergleich der ben&ouml;tigten Zeiten f&uuml;r die Erstellung des DOMs f&uuml;r 1. die Anwendung von </I><I>&bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder und 2. f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r </I><I>CSS Dateien, jeweils mit Kabel-Verbindung. </I></DD
></DL
><P 

> &bdquo;Start Render&ldquo; </P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_37.jpg" ><DL 

><DD 

><I>Abb. 37:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS </I><I>Dateien und Bilder mit der Anwendung v</I><I>on &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien, jeweils mit Kabel</I><I>-Verbindung.  </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; f&uuml;r CSS Da-teien und Bildern </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; f&uuml;r CSS Da-teien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>1083 ms </P
></TD
><TD  
 valign="top"
><P 

>960 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>1075  ms </P
></TD
><TD  
 valign="top"
><P 

>952,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>1085 ms </P
></TD
><TD  
 valign="top"
><P 

>982,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 19:</I><I> </I><I>Vergleich des </I><I>Parameters &bdquo;Start Render&ldquo; f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder mit der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r C</I><I>SS Dateien, jeweils mit Kabel-Verbindung. </I></DD
></DL
><P 

>Wenn man beide Boxplot-Diagramme aus Abb. 37 miteinander vergleicht, sieht man, dass die Werte der ersten Messreihe deutlich sp&auml;ter ausgegeben werden. Der Unterschied zwischen den Medianwerten liegt bei 123 ms. </P
><P 

>Bei dem Parameter &bdquo;Start Render&ldquo; sind 123 ms Verz&ouml;gerung schon kritisch. In beiden F&auml;llen werden alle CSS Dateien per &bdquo;Server Push&ldquo; &uuml;bergeben, damit das CSSOM so schnell wie m&ouml;g-lich gebaut wird. Die gro&szlig;e Verz&ouml;gerung des &bdquo;Start Render&ldquo; in der ersten Messreihe kann an der Verz&ouml;gerung der DOM-Erstellung liegen: das DOM wird nicht erstellt, bevor nicht alle PUSH_PROMISE &ndash; Frames den Client erreicht haben und alle dazugeh&ouml;rigen &bdquo;Streams&ldquo; vom Client priorisiert wurden. Je mehr Dateien per &bdquo;Server Push&ldquo; &uuml;bergegeben werden, desto mehr wird also die DOM-Erstellung verz&ouml;gert und desto wahrscheinlicher ist es, dass der Ren-der &ndash; Baum sp&auml;ter gebaut wird. </P
><P 

>&bdquo;Bytes Out&ldquo; </P
><P 

>Mithilfe von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder ist es gelungen, im Vergleich zu den Testreihen mit &bdquo;Server Push nur f&uuml;r CSS Dateien 1490 Bytes pro Testreihe zu sparen. </P
><P 

>&bdquo;domComplete&ldquo; </P
><P 

>Aus Abb. 38 ist zu erkennen, dass alle Werte f&uuml;r die erste Messreihe schon fertig ausgegeben sind, bevor der untere Whisker f&uuml;r den zweiten Test angezeigt wird. Der Unterschied zwischen den Medianwerten betr&auml;gt 52 ms. Diese Verhaltensweise liegt vermutlich daran, dass im aktu-ellen Fall mehrere Bytes f&uuml;r Requests gespart werden. Dadurch wird die Gesamtladezeit f&uuml;r alle Ressourcen verk&uuml;rzt. </P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_38.jpg" ><DL 

><DD 

><I>Abb. 38:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bildern mit der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Ka-bel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; mit CSS Da-teien und Bildern </P
></TD
><TD  
 valign="top"
><P 

>&bdquo;Server Push&ldquo; mit CSS Da-teien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>1295 ms </P
></TD
><TD  
 valign="top"
><P 

>1347 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil </P
></TD
><TD  
 valign="top"
><P 

>1284  ms </P
></TD
><TD  
 valign="top"
><P 

>1338,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>1307 ms </P
></TD
><TD  
 valign="top"
><P 

>1355,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 20:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; f&uuml;r die Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bildern mit der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien</I><I>, jeweils mit Ka-bel-Verbindung. </I></DD
></DL
><P 

> &bdquo;Visual Progress&ldquo; </P
><P 

>Aus Abb. 39 sieht man leider nur den &bdquo;Visual Progress&ldquo; der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien, weil die Werte dieser Anwendung die Werte der anderen Anwendung &uuml;ber-lappen. Man sieht, dass beide Anwendungen gleichm&auml;&szlig;ig die Inhalte an den Client liefern. In zwei von drei Tests erscheinen bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien erste Inhalte im Browser fr&uuml;her. Die gleichen Ergebnisse sieht man aus den aufgenommenen Screenshots. </P
><P 

><B> </P
><IMG width="469" height="329"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_39.jpg" ><DL 

><DD 

></B><I>Abb. 39:</I><I> </I><I> </I><I>&bdquo;Visual Progress&ldquo; bei Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder und bei der Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien unter Kab</I><I>el-Verbindung. </I></DD
></DL
><H3 

><FONT size="+1">5.5.7. Zwischenfazit: lohnt sich die &Uuml;bergabe von CSS Dateien und Bildern per &bdquo;Server Push&ldquo; im Vergleich zur Anwendung von &bdquo;Server Push&ldquo; nur f&uuml;r CSS Dateien? </H3
><P 

><FONT size="+1">Wenn man den Parameter &bdquo;Time To First Byte&ldquo; und die Zeit f&uuml;r die DOM-Erstellung in beiden Anwendungen vergleicht, sieht man, dass diese im Fall der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder deutlich sp&auml;ter ausgegeben werden. Dadurch, dass das DOM sp&auml;ter aufgebaut wird, wird auch der Render &ndash; Baum sp&auml;ter fertig gestellt und die Erstdarstellung im Viewport wird dementsprechend verz&ouml;gert.  </P
><P 

>Deshalb kann gesagt werden, dass nicht eine unendliche Anzahl von Ressourcen per &bdquo;Server Push&ldquo; &uuml;bergeben werden sollte. Auch wenn die Erstellung des CSSOMs nicht gebremst wird, kann es passieren, dass durch viele PUSH_PROMISE &ndash; Frames und die Priorisierungen der da-zugeh&ouml;rigen &bdquo;Streams&ldquo; der DOM-Aufbau l&auml;nger brauchen wird. </P
><P 

>Im aktuellen Test wurden bei der Anwendung von &bdquo;Server Push&ldquo; f&uuml;r CSS Dateien und Bilder etwa 1490 Anfragebytes pro Testreihe gespart. Deshalb wird weniger Zeit f&uuml;r die Gesamtlade-zeit gebraucht. Die Ressourcen werden dadurch schneller geladen. </P
><H2 

><FONT size="+1">5.6. Zwischenfazit: &bdquo;Server Push&ldquo; Anwendung allgemein </H2
><P 

><FONT size="+1"><I>Welche Ressourcentypen sollen gepusht werden? Wie gro&szlig; sind die Vorteile davon? </I></P
><P 

>Nachdem der Test mit per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien gute Ergebnisse gezeigt hat, wird empfohlen, alle f&uuml;r die zu ladende Seite relevanten CSS Dateien per &bdquo;Server Push&ldquo; zu &uuml;bergeben. Dadurch werden mehrere Anfragebytes gespart und gepushte Ressourcen werden </P
><P 

>den Client schneller erreichen. Da DOM und CSSOM unabh&auml;ngig voneinander gebaut werden (Grigorik 2013, 168), wird CSSOM im Vergleich zur Anwendung ohne &bdquo;Server Push&ldquo; fr&uuml;her auf-gebaut. Deshalb wird der Parameter &bdquo;Start Render&ldquo; bei der Anwendung von &bdquo;Server Push&ldquo; mit CSS Dateien schneller angezeigt. Dies kann eine gro&szlig;e Rolle bei der User Experience spielen. </P
><P 

>Au&szlig;erdem wird normalerweise mit zunehmender Anzahl von gepushten Ressourcen die Ge-samtladezeit verk&uuml;rzt, weil Anfragebytes gespart werden. </P
><P 

>Der &bdquo;Server Push&ldquo; &ndash; Einsatz kann auch f&uuml;r die Erstdarstellung nicht-kritischer Dateien Vorteile bringen. Falls sich auf der Seite der Webapplikation bedeutsame Schriften befinden, die gleich auf dem Viewport angezeigt werden sollen, k&ouml;nnen diese auch per &bdquo;Server Push&ldquo; &uuml;bergegeben werden. Dadurch werden diese gleichzeitig oder kurz nach dem Erscheinen von ersten Pixeln angezeigt. Das gleiche gilt f&uuml;r z.B. ein Logo oder ein bedeutsames Bild auf der Seite. Wenn auch alle f&uuml;r die Erstdarstellung kritische Dateien per &bdquo;Server Push&ldquo; mit&uuml;bergegeben wurden, k&ouml;nnen alle Typen (nach MIME-Typ) von Ressourcen mitgepusht werden. </P
><P 

>Allerdings muss man beachten, dass mit jeder gepushten Ressource die DOM-Erstellung ver-z&ouml;gert wird und alle anderen Ressourcen auf der Seite auf den Moment warten werden, bis alle gepushten Ressourcen heruntergeladen wurden.<I> </I></P
><P 

><I>Welche Ressourcentypen sollen nicht gepusht werden? Wo bestehen die Nachteile? </I></P
><P 

>Nach den durchgef&uuml;hrten Tests kann man sagen, dass fast alle f&uuml;r die Erstdarstellung kritische und nicht-kritische Ressourcentypen gepusht werden k&ouml;nnen. Dies betrifft auch Bilder und Schriften. Lediglich nicht kritische JavaScript Dateien sind eine Ausnahme. Attribute wie &bdquo;async&ldquo; oder &bdquo;defer&ldquo; sind nur Hinweise f&uuml;r den Browser, die der Server nicht versteht. Aus diesem Grund werden alle JavaScript Dateien, die gepusht werden, nach der HTML Datei geladen und gleich ausgef&uuml;hrt. Wenn diese nicht-kritisch sind, werden erste Bytes im Viewport erst viel sp&auml;ter an-gezeigt, weil JavaScript Dateien gleich ausgef&uuml;hrt werden (Grigorik 2016f). </P
><P 

>Alle oben beschriebenen Ergebnisse beziehen sich auf eine konkrete Version der serverseitigen Implementation des HTTP/2 &ndash; Protokolls und eine konkrete Version des Browsers. Unter ande-ren Bedingungen k&ouml;nnen sich oben beschriebene Ergebnisse &auml;ndern. </P
><H2 

><FONT size="+1">5.7. Vergleich des HTTP/1.1 mit dem HTTP/2 &ndash; Protokoll </H2
><P 

><FONT size="+1">In diesem Unterkapitel werden mehrere Tests durchgef&uuml;hrt, in denen untersucht wird, welches der Protokolle, HTTP/1.1 oder HTTP/2, bessere Ergebnisse f&uuml;r den kritischen Rendering &ndash; Pfad liefert. Um das HTTP/2 &ndash; Protokoll benutzen zu k&ouml;nnen, muss eine verschl&uuml;sselte Verbindung aufgebaut werden (Browser akzeptieren das HTTP/2 &ndash; Protokoll nur unter verschl&uuml;sselten Ver-bindungen (NGINX, Inc. 2015, 3)). Deshalb wird im HTTP/2 &ndash; Protokoll zus&auml;tzlich zur TCP - Ver-bindung zum Server noch eine TLS &ndash; Verbindung aufgebaut. Es muss allerdings nur eine Ver-bindung pro Domain aufgebaut werden.  </P
><P 

>Wenn die Webapplikation mithilfe des HTTP/1.1 &ndash; Protokolls unter einer verschl&uuml;sselten Ver-bindung untersucht wird, werden alle Parameter des kritischen Rendering &ndash; Pfades verz&ouml;gert. Der Grund liegt an den zahlreichen TCP &ndash; Verbindungen zwischen Client und Server. Wenn die Verbindung verschl&uuml;sselt sein soll, werden alle TCP &ndash; Verbindungen (mind. 6 TCP &ndash; Verbindun-gen) eine zus&auml;tzliche TLS &ndash; Verschl&uuml;sselung haben. Um diese Verbindungen herzustellen, brau-chen Client und Server mehr Zeit. </P
><P 

>Um diese Unterschiede zu zeigen, wurde noch ein kleiner Test gemacht. Da in jeder Testreihe die Zeit f&uuml;r den Verbindungsaufbau zum Server ungef&auml;hr gleich ist, wurden von neun Tests die Medianwerte f&uuml;r DNS-, TCP- und TLS- Verbindungen unter Kabel- und 3G- Verbindungen er-mittelt und verglichen. Verglichen wurde die Zeit zum Verbindungsaufbau unter unverschl&uuml;s-seltem HTTP/1.1 &ndash; Protokoll mit der Zeit f&uuml;r HTTP/1.1 mit TLS - Verschl&uuml;sselung. Untersucht wurde die Startseite der Webapplikation. Alle Ressourcen wurden f&uuml;r das HTTP/1.1 &ndash; Protokoll aufgeteilt. </P
><P 

>TCP, DNS, TLS </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

> </P
></TD
><TD  
 valign="top"
><P 

>DNS </P
></TD
><TD  
 valign="top"
><P 

>TCP </P
></TD
><TD  
 valign="top"
><P 

>TLS </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1, Unverschl&uuml;sselt </P
></TD
><TD  
 valign="top"
><P 

>30 </P
></TD
><TD  
 valign="top"
><P 

>228 </P
></TD
><TD  
 valign="top"
><P 

>0 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1, mit TLS - Verschl&uuml;sselung </P
></TD
><TD  
 valign="top"
><P 

>61 </P
></TD
><TD  
 valign="top"
><P 

>296 </P
></TD
><TD  
 valign="top"
><P 

>353 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Summe der Netzwerkverbindungszeit </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1, Unverschl&uuml;sselt </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1, mit TLS - Verschl&uuml;sselung </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>258 </P
></TD
><TD  
 valign="top"
><P 

>710 </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 21:</I><I> </I><I>Vergleich von HTTP/1.1 unverschl&uuml;sselt und HTTP/1.1 verschl&uuml;sselt f&uuml;r die Startseite un-ter Kabel-Verbindung </I></DD
></DL
><P 

>TCP, DNS, TLS </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

> </P
></TD
><TD  
 valign="top"
><P 

>DNS </P
></TD
><TD  
 valign="top"
><P 

>TCP </P
></TD
><TD  
 valign="top"
><P 

>TLS </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1, Unverschl&uuml;sselt </P
></TD
><TD  
 valign="top"
><P 

>310 </P
></TD
><TD  
 valign="top"
><P 

>2511 </P
></TD
><TD  
 valign="top"
><P 

>0 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1, mit TLS - Verschl&uuml;sselung </P
></TD
><TD  
 valign="top"
><P 

>618 </P
></TD
><TD  
 valign="top"
><P 

>3793 </P
></TD
><TD  
 valign="top"
><P 

>4529 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Summe der Netzwerkverbindungszeit </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1, Unverschl&uuml;sselt </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1, mit TLS - Verschl&uuml;sselung </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>2821 </P
></TD
><TD  
 valign="top"
><P 

>8940 </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 22:</I><I> </I><I>Vergleich von HTTP/1.1 unverschl&uuml;sselt und HTTP/1.1 verschl&uuml;sselt f&uuml;r die Startseite un-ter 3G-Verbindung </I></DD
></DL
><P 

>Aus Tabelle 21 und Tabelle 22 ist zu sehen, dass die Unterschiede im Verbindungsaufbau zwi-schen dem verschl&uuml;sselten und dem unverschl&uuml;sselten HTTP/1.1 &ndash; Protokoll sehr gro&szlig; sind. Je schlechter die Netzwerkgeschwindigkeit und je h&ouml;her die Latenz ist, desto gr&ouml;&szlig;er werden diese Unterschiede. Die lange Netzwerkverbindungszeit f&uuml;r HTTP/1.1 mit TLS - Verschl&uuml;sselung unter </P
><P 

>3G-Verbindung liegt daran, dass bis zu 10 TCP &ndash; Verbindungen innerhalb einer Sitzung aufge-baut werden. Aus diesem Grund wird es zus&auml;tzliche Schwierigkeiten geben, um die Parameter des kritischen Rendering &ndash; Pfades unter verschl&uuml;sselten Verbindungen innerhalb des HTTP/1.1 &ndash; Protokolls zu untersuchen. Deshalb werden Parameterunterschiede zwischen dem HTTP/1.1- (ohne TLS - Verschl&uuml;sselung) und HTTP/2 &ndash;  Protokoll (mit TLS - Verschl&uuml;sselung) gemessen. </P
><P 

>In den Tests dieses Unterkapitels wird der &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r das HTTP/2 &ndash; Protokoll nicht verwendet. Deshalb wird der Parameter &bdquo;Time To First Byte&ldquo;, &bdquo;Bytes Out&ldquo; und die Zeit f&uuml;r die DOM-Erstellung nicht mehr gemessen. Interessant zu vergleichen sind folgende Parameter: </P
><DL 

><DD 

>&#61630; Verbindungsaufbau: DNS, TCP, TLS. </DD
><DD 

>&#61630; &bdquo;Start Render&ldquo;. </DD
></DL
><P 

>An welchem Zeitpunkt f&auml;ngt der Webbrowser an, etwas im Viewport zu zeichnen? </P
><DL 

><DD 

>&#61630; &bdquo;domComplete&ldquo;. </DD
><DD 

>&#61630; &bdquo;Visual Progress&ldquo;. </DD
></DL
><P 

>Um zu schauen, wie schnell die Inhalte der Webapplikation (prozentual gesehen) auf dem Viewport erscheinen. </P
><P 

>In diesem Unterkapitel werden zwei Tests durchgef&uuml;hrt, einmal f&uuml;r die Startseite und einmal f&uuml;r die Dozenten-Seite, jeweils unter Kabel-Verbindung und unter 3G-Verbindung. Die Webapplikation wird separat sowohl f&uuml;r das HTTP/1.1 &ndash; Protokoll als auch f&uuml;r das HTTP/2 &ndash; Protokoll optimiert. F&uuml;r das HTTP/1.1 &ndash; Protokoll werden die Ressourcen f&uuml;r die Startseite zusammengefasst, sodass f&uuml;nf CSS Dateien und f&uuml;nf JavaScript Dateien entstanden sind. F&uuml;r das HTTP/2 &ndash; Protokoll werden die gleichen Ressourcen auf mehrere Dateien aufge-teilt, so dass 10 CSS Dateien und 15 JavaScript Dateien entstehen. Das gleiche wurde f&uuml;r die Dozenten-Seite gemacht. Dar&uuml;ber hinaus werden alle Bilder f&uuml;r das HTTP/1.1 &ndash; Protokoll in einem Sprite zusammengefasst und unter dem HTTP/2 &ndash; Protokoll wird dieses auf einzelne kleine Bilder aufgeteilt. </P
><P 

>W&auml;hrend der Testauswertung ist ein gro&szlig;er Unterschied zwischen der Verarbeitungsart der Ressourcen unter dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll aufgefallen. Dies wurde bei den Testergebnissen aus dem &bdquo;Webpagetest.org&ldquo; &ndash; Tool registriert. W&auml;hrend der Aufbau der Webapplikation f&uuml;r beide Protokolle &auml;hnlich ist (au&szlig;er, dass die Ressourcen anders aufgeteilt sind), unterscheidet sich die Reihenfolge der geladenen Ressourcen.  </P
><P 

>Der Aufbau der Webapplikation in den zu untersuchenden Tests ist immer der folgende: zuerst befinden sich im Head-Bereich des HTML-Dokuments alle CSS Dateien, danach befinden sich im Body-Bereich der gesamte Content mit allen Bildern und bevor sich der Body-Tag schlie&szlig;t, stehen alle JavaScript Dateien. Aus dem Ressourcenwasserfall im &bdquo;Webpagetest.org&ldquo; &ndash; Tool sieht man, dass die Ressourcen unter dem HTTP/1 &ndash; Protokoll in folgender Reihenfolge gela-den werden: HTML Datei, danach alle CSS Dateien, danach alle JavaScript Dateien und zuletzt werden die Bilder und Schriften geladen. Au&szlig;erdem muss man beachten, dass alle Ressourcen </P
><P 

>auf einzelne TCP &ndash; Verbindungen aufgeteilt sind. Innerhalb jeder TCP &ndash; Verbindung kann man oben beschriebene Reihenfolge beobachten. Dies kann man mithilfe des &bdquo;Webpage-test.org&ldquo; &ndash; Tools in &bdquo;Connect View&ldquo; beobachten. </P
><P 

>Wenn die Webapplikation unter dem HTTP/2 &ndash; Protokoll l&auml;uft, &auml;ndert sich die Reihenfolge der geladenen Dateien. Aus dem Ressourcenwasserfall und dem &bdquo;Connect View&ldquo; des &bdquo;Webpage-test.org&ldquo; &ndash; Tools sieht man, dass alle Ressourcen in der folgenden Reihenfolge geladen werden: HTML Datei, danach alle CSS Dateien, danach werden alle Bilder und zu Letzt die JavaScript Dateien und Schriften geladen. Diese Situation sieht etwas anders aus, wenn die Bilder durch CSS Dateien geladen werden. Dann werden alle JavaScript Dateien vor den Bildern aus der CSS Datei geladen. </P
><P 

>Diese Unterschiede in der Reihenfolge der geladenen Ressourcen unter dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll lassen sich nicht einfach erkl&auml;ren. Deshalb wurde die Webapplikation mit der gleichen Browserversion wie im &bdquo;Webpagetest.org&ldquo; &ndash; Tool am lokalen PC aufgerufen und mithilfe von &bdquo;Wireshark&ldquo; zus&auml;tzlich untersucht.  </P
><P 

>Wenn man den &bdquo;Wireshark&ldquo; Datenmitschnitt auf dem lokalen PC betrachtet, sieht man, dass die Ressourcen unter dem HTTP/2 &ndash; Protokoll eine andere Ladereihenfolge haben: zuerst wird die HTML Datei aufgerufen, danach werden die CSS Dateien geladen, schlie&szlig;lich die JavaScript Dateien heruntergeladen und am Ende kommen Bilder und Schriften. </P
><P 

>Es ist zu beachten, dass die Ladereihenfolge der Ressourcen sich je nach Browser und Brow-serversion unterscheiden kann. Das genaue Verhalten der Ladereihenfolge von Ressourcen ist nicht dokumentiert und nicht spezifiziert (Mifsud 2016). </P
><P 

><I>Testbedingungen f&uuml;r das HTTP/1.1- und das HTTP/2 </I><I>&ndash;</I><I> Protokoll </I></P
><P 

>Nachdem die oben beschriebenen Unterschiede bemerkt wurden, wurden die Tests f&uuml;r jedes Protokoll noch zus&auml;tzlich angepasst. Die Anpassungen betreffen die JavaScript Dateien. Unter dem HTTP/1.1 &ndash; Protokoll werden alle JavaScript Dateien erst nach den CSS Dateien vom Client angefragt. Um die DOM-Erstellung nicht zu verz&ouml;gern kann man entweder das Attribut &bdquo;async&ldquo; oder &bdquo;defer&ldquo; benutzen. Wenn man das Attribut &bdquo;defer&ldquo; verwendet, besteht die Gefahr, dass der gesamte Content (inkl. aller Bilder) darauf warten wird, bis alle Skripte ausgef&uuml;hrt werden. Dies passiert, da die mit dem Attribut &bdquo;defer&ldquo; markierten Skripte nach dem Parameter &bdquo;domInterac-tive&ldquo; (gleich nach dem DOM-Aufbau) ausgef&uuml;hrt werden. F&uuml;r weniger wichtige JavaScript Da-teien ist es keine gute L&ouml;sung unter dem HTTP/1.1 - Protokoll. </P
><P 

>Wenn jedoch das Attribut &bdquo;async&ldquo; f&uuml;r alle JavaScript Dateien angewendet wird, besteht die Gefahr, dass Skripte in unterschiedlicher Reihenfolge (soweit sie geladen werden) ausgef&uuml;hrt werden. Dann ist zu erwarten, dass fr&uuml;her geladene kleinere JavaScript Dateien fr&uuml;her ausge-f&uuml;hrt werden, als gr&ouml;&szlig;ere Dateien. Dadurch kann es zu JavaScript-Fehlern kommen, da die Skripte oftmals voneinander abh&auml;ngig sind. </P
><P 

>Um f&uuml;r das HTTP/1.1 &ndash; Protokoll ein Balance zu finden, wurde entschieden, das Attribut &bdquo;async&ldquo; f&uuml;r alle von anderen abh&auml;ngigen Skripte zu verwenden. Die sofort notwendigen JavaScript Da-teien wurden ohne Attribute leer gelassen. In den aktuellen Tests betrifft dies nur zwei Ja-vaScript Dateien: &bdquo;jquery.min.js&ldquo; und &bdquo;jssor.slider.mini.js&ldquo;. Alle anderen werden mit dem Attribut &bdquo;async&ldquo; markiert. </P
><P 

>F&uuml;r den kritischen Rendering - Pfad ist es immer wichtig, die DOM- und CSSOM-Erstellung nicht zu verz&ouml;gern. Wie unter dem HTTP/2 &ndash; Protokoll zuvor bemerkt wurde, werden die Skripte erstaunlicherweise erst nach den Bildern geladen. Wenn man f&uuml;r manche Skripte, wie unter dem HTTP/1.1 &ndash; Protokoll das Attribut &bdquo;async&ldquo; verwendet, wird die DOM-Erstellung wegen der nicht mit dem Attribut &bdquo;async&ldquo; markierten Skripte verz&ouml;gert. Deshalb wurde entschieden, unter dem HTTP/2 &ndash; Protokoll das Attribut &bdquo;defer&ldquo; f&uuml;r alle Skripte anzuwenden. </P
><H3 

><FONT size="+1">5.7.1. Test 1: Untersuchung der Startseite der Webapplikation unter dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll. </H3
><P 

><FONT size="+1">Da in jedem Test die Zeit f&uuml;r den Verbindungsaufbau zum Server ungef&auml;hr gleich ist, wurden f&uuml;r neun Tests die Medianwerte f&uuml;r DNS-, TCP- und TLS- Verbindungen ermittelt und unter Kabel- und 3G- Verbindungen verglichen. Verglichen wurde die Zeit zum Verbindungsaufbau unter dem HTTP/1.1 &ndash; Protokoll ohne Verschl&uuml;sselung und unter dem HTTP/2 &ndash; Protokoll. </P
><P 

>TCP, DNS, TLS </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

> </P
></TD
><TD  
 valign="top"
><P 

>DNS </P
></TD
><TD  
 valign="top"
><P 

>TCP </P
></TD
><TD  
 valign="top"
><P 

>TLS </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 </P
></TD
><TD  
 valign="top"
><P 

>59 </P
></TD
><TD  
 valign="top"
><P 

>84 </P
></TD
><TD  
 valign="top"
><P 

>98 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1 </P
></TD
><TD  
 valign="top"
><P 

>30 </P
></TD
><TD  
 valign="top"
><P 

>228 </P
></TD
><TD  
 valign="top"
><P 

>0 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Summe der Netzwerkverbindungszeit </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>241 </P
></TD
><TD  
 valign="top"
><P 

>258 </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 23:</I><I> </I><I>Vergleich von HTTP/1.1 unverschl&uuml;sselt und HTTP/2 </I><I>&ndash;</I><I> verschl&uuml;sselt f&uuml;r die Startseite un-ter Kabel-Verbindung </I></DD
></DL
><P 

>TCP, DNS, TLS </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

> </P
></TD
><TD  
 valign="top"
><P 

>DNS </P
></TD
><TD  
 valign="top"
><P 

>TCP </P
></TD
><TD  
 valign="top"
><P 

>TLS </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 </P
></TD
><TD  
 valign="top"
><P 

>621 </P
></TD
><TD  
 valign="top"
><P 

>957 </P
></TD
><TD  
 valign="top"
><P 

>654 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1 </P
></TD
><TD  
 valign="top"
><P 

>310 </P
></TD
><TD  
 valign="top"
><P 

>2511 </P
></TD
><TD  
 valign="top"
><P 

>0 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Summe der Netzwerkverbindungszeit </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>2232 </P
></TD
><TD  
 valign="top"
><P 

>2821 </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 24:</I><I> </I><I>Vergleich von HTTP/1.1 unverschl&uuml;sselt und HTTP/2 </I><I>&ndash;</I><I> verschl&uuml;sselt f&uuml;r die Startseite un-ter 3G-Verbindung </I></DD
></DL
><P 

>Aus Tab. 23 und Tab. 24 ist zu erkennen, dass sich die Zeit f&uuml;r den Verbindungsaufbau zum Server zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll wesentlich nur im Fall der 3G-Verbindung unterscheidet. Der Unterschied liegt bei etwa 600 ms. Man darf nicht vergessen, dass unter dem HTTP/1.1 &ndash; Protokoll mind. sechs TCP &ndash; Verbindungen ge&ouml;ffnet werden. Des-halb ist zu erwarten, dass die Anwendung unter dem HTTP/1.1 &ndash; Protokoll mit 3G-Verbindung langsamer als unter dem HTTP/2 &ndash; Protokoll geladen wird.<B> </P
><P 

></B>&bdquo;Start Render&ldquo; </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_40.jpg" ><DL 

><DD 

></B><I>Abb. 40:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; unter dem HTTP/1.1</I><I>- und dem HTTP/2 </I><I>&ndash;</I><I> Pro-tokoll, jeweils unter Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>997 ms </P
></TD
><TD  
 valign="top"
><P 

>1033 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>971 ms </P
></TD
><TD  
 valign="top"
><P 

>974 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>1025,5 ms </P
></TD
><TD  
 valign="top"
><P 

>1094,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 25:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; unter dem HTTP/1.1</I><I>- und dem HTTP/2 </I><I>&ndash;</I><I> Pro-tokoll, jeweils unter Kabel-Verbindung. </I></DD
></DL
><P 

>Aus Abb. 40 geht hervor, dass der Parameter &bdquo;Start Render&ldquo; bei der Anwendung des HTTP/2 &ndash; Protokolls unter Kabel-Verbindung etwas fr&uuml;her als bei der Anwendung des HTTP/1.1 &ndash; Protokolls ausgegeben wird: der Median der ersten Messreihe wird 36 ms fr&uuml;her ausgegeben. Die ersten 75% der Werte der ersten Messreihe werden ausgegeben, bevor 50% der Werte der zweiten Messreihe angezeigt werden. Das Maximum der ersten Messreihe wird auch fr&uuml;her angezeigt. Dies bedeutet, dass bei der Anwendung des HTTP/2 &ndash; Protokolls erste Pixel auf dem Viewport ein wenig fr&uuml;her erscheinen. </P
><P 

>Aus Abb. 41 ist zu sehen, dass der Parameter &bdquo;Start Render&ldquo; bei Anwendung des HTTP/2 &ndash; Pro-tokolls unter 3G-Verbindung im Vergleich zur Anwendung des HTTP/1.1 &ndash; Protokolls deutlich sp&auml;ter ausgegeben wird. Der Unterschied zwischen den Medianwerten betr&auml;gt 833 ms. </P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_41.jpg" ><DL 

><DD 

><I>Abb. 41:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; unter dem HTTP/1.1</I><I>- und dem HTTP/2 </I><I>&ndash;</I><I> Pro-tokoll, jeweils unter 3G-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>3383 ms </P
></TD
><TD  
 valign="top"
><P 

>2550 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>3380,5 ms </P
></TD
><TD  
 valign="top"
><P 

>2540 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>3474 ms </P
></TD
><TD  
 valign="top"
><P 

>2574 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 26:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; unter dem HTTP/1.1</I><I>- und dem HTTP/2 </I><I>&ndash;</I><I> Pro-tokoll, jeweils unter 3G-Verbindung. </I></DD
></DL
><P 

>Wenn man die Ergebnisse unter Kabel-Verbindung mit denen unter 3G-Verbindung vergleicht, sieht man, dass der Unterschied zwischen den Medianwerten einen sehr gro&szlig;en Sprung auf 833 ms gemacht hat. Es gibt jedoch mehrere Faktoren, die gegen das aktuelle Testergebnis unter 3G-Verbindung sprechen: </P
><DL 

><DD 

>&#61630; Aufbau von sechs (oder mehr) unverschl&uuml;sselten TCP - Verbindungen (f&uuml;r das HTTP/1.1 - Protokoll) unter mobilen Netzwerken braucht etwa 600 ms mehr Zeit als f&uuml;r eine verschl&uuml;sselte TCP &ndash; Verbindung  (f&uuml;r das HTTP/2 &ndash; Protokoll) (siehe Vergleiche zur TCP, DNS, TLS unter 3G-Verbindung). </DD
><DD 

>&#61630; Besonders unter schlechteren Netzwerk-Verbindungen wurde mehr Zeit gebraucht, um gr&ouml;&szlig;ere Dateien herunterzuladen. Dies liegt an der Funktion des TCP &ndash; Protokolls &bdquo;Slow &ndash; Start&ldquo; (siehe Unterkapitel &bdquo;3.1 HTTP/1.1 &ndash; Optimierungstechniken, Stand bis-her&ldquo;).<FONT color="#FF0000"> </DD
><DD 

><FONT color="#000000">&#61630; Das HTTP/2 &ndash; Protokoll verwendet den &bdquo;Header Kompression&ldquo; Mechanismus, um die Kopfzeilen w&auml;hrend der &Uuml;bertragung zu komprimieren. </DD
></DL
><P 

>Unter Kabel-Verbindung wurden die Werte mit der Anwendung unter dem HTTP/2 &ndash; Protokoll sogar fr&uuml;her ausgegeben. Um die Antwort auf die Frage zu finden, aus welchem Grund die Webapplikation unter dem HTTP/2 &ndash; Protokoll und einer 3G-Verbindung durchschnittlich mehr als 800 ms sp&auml;ter angezeigt wird, wird auf die genaue Funktion der aktuellen Implementierung </P
><P 

>des HTTP/2 &ndash; Protokolls im Zwischenfazit geschaut. Da im aktuellen Fall der Parameter &bdquo;Start Render&ldquo; betrachtet wurde, spielt scheinbar die Aufteilung der CSS Dateien eine gro&szlig;e Rolle. </P
><P 

>&bdquo;domComplete&ldquo; </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_42.jpg" ><DL 

><DD 

></B><I>Abb. 42:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls, jeweils unter Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>1843 ms </P
></TD
><TD  
 valign="top"
><P 

>1630 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>1822 ms </P
></TD
><TD  
 valign="top"
><P 

>1617,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>1852 ms </P
></TD
><TD  
 valign="top"
><P 

>1642 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 27:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung des </I><I>HTTP/1.1- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls, jeweils unter Kabel-Verbindung. </I></DD
></DL
><P 

>Aus Abb. 42 sieht man, dass der Parameter &bdquo;domComplete&ldquo; bei der Anwendung des HTTP/2 &ndash; Protokolls deutlich sp&auml;ter ausgegeben wird. Der Unterschied zwischen den Median-werten liegt bei 213 ms. </P
><P 

> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_43.jpg" ><DL 

><DD 

><I>Abb. 43:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls, jeweils unter 3G-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>5939 ms </P
></TD
><TD  
 valign="top"
><P 

>4123 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>5759 ms </P
></TD
><TD  
 valign="top"
><P 

>4079 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>6013 ms </P
></TD
><TD  
 valign="top"
><P 

>4368 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 28:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls, jeweils unter 3G-Verbindung. </I></DD
></DL
><P 

>Aus Abb. 43 ist zu sehen, dass die Werte unter dem HTTP/2 &ndash; Protokoll deutlich sp&auml;ter ausge-geben werden, als unter dem HTTP/1.1 &ndash; Protokoll. Der Unterschied zwischen den Medianwer-ten liegt bei 1816 ms. Im Vergleich zur Kabel-Verbindung hat sich dieser Unterschied um<FONT color="#FF0000"> <FONT color="#000000">mehr als das Achtfache erh&ouml;ht. </P
><P 

>In beiden Tests unter unterschiedlichen Verbindungen sieht man, dass der Parameter &bdquo;dom-Complete&ldquo; f&uuml;r die Anwendung unter dem HTTP/2 &ndash; Protokoll im Vergleich zur Anwendung unter dem HTTP/1.1 &ndash; Protokoll deutlich sp&auml;ter ausgegeben wird. Es ist eher zu erwarten, dass der Parameter &bdquo;domComplete&ldquo; in beiden Verbindungen unter dem HTTP/2 &ndash; Protokoll viel fr&uuml;-her als unter dem HTTP/1.1 &ndash; Protokoll ausgegeben wird. M&ouml;gliche Faktoren wurden in der Auswertung des Parameters &bdquo;Start Render&ldquo; aufgelistet. Die Erwartungen haben sich beim Pa-rameter &bdquo;domComplete&ldquo; nicht erf&uuml;llt. </P
><P 

> &bdquo;Visual Progress&ldquo; </P
><P 

><B> </P
><IMG width="422" height="324"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_44.jpg" ><DL 

><DD 

></B><I>Abb. 44:</I><I> </I><I> </I><I>&bdquo;Visual Progress&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter Kabel-Verbindung. </I></DD
></DL
><P 

>Aus oben dargestellter Grafik sieht man, dass die Webapplikation unter beiden Protokollen etwa gleichzeitig erste Inhalte auf dem Browser anzeigt. Man sieht aber, dass die meisten In-</P
><P 

>halte (bei etwa 80%) unter dem HTTP/1.1 &ndash; Protokoll schneller geladen werden. Dies liegt da-ran, dass die Dateien unter dem HTTP/2 &ndash; Protokoll eine andere Ressourcenreihenfolge haben und JavaScript Dateien mit dazugeh&ouml;rigen Bildern aus dem Slider sp&auml;ter nachgefragt werden. Der Unterschied liegt bei etwa einer halben Sekunde. </P
><P 

>Aus den Screenshots sieht man zus&auml;tzlich, dass unter dem HTTP/2 &ndash; Protokoll zuerst alle Bilder auf der Seite geladen werden, bevor der Slider mit den dazugeh&ouml;rigen Bildern im Browser erscheinen wird. Die Ressourcenreihenfolge wurde beim Ressourcenwasserfall best&auml;tigt. </P
><P 

>Aus Abb. 45 l&auml;sst sich schlie&szlig;en, dass erste Inhalte unter der HTTP/2 &ndash; Verbindung fast eine Sekunde sp&auml;ter angezeigt werden. Die JavaScript Dateien werden wie im fr&uuml;heren Test sp&auml;ter nachgeladen. Aus den Screenshots sieht man zus&auml;tzlich, dass der Unterschied beim fertig ge-ladenen Slider zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll bei etwa 2,5 Sekunden liegt. </P
><P 

>Aus den aufgenommenen Screenshots ist auch zu sehen, dass bei der Anwendung unter dem HTTP/2 &ndash; Protokoll alle Ressourcen deutlich sp&auml;ter nachgeladen werden. </P
><P 

> </P
><IMG width="458" height="334"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_45.jpg" ><DL 

><DD 

><I>Abb. 45:</I><I> </I><I>&bdquo;Visual Progress&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls, jeweils unter 3G-Verbindung. </I></DD
></DL
><H3 

><FONT size="+1">5.7.2. Zwischenfazit: wie gro&szlig; sind die Unterschiede der untersuchten Parameter des kritischen Rendering &ndash; Pfades zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll in Bezug auf die Startseite der Webapplikation? </H3
><P 

><FONT size="+1">Aus den Ergebnissen des aktuellen Tests kann man sagen, dass die Gesamtladezeit f&uuml;r alle Ressourcen unter dem HTTP/2 &ndash; Protokoll im Vergleich zum HTTP/1.1 &ndash; Protokoll deutlich l&auml;n-ger dauert. Umso gr&ouml;&szlig;er wird dieser Unterschied, je gr&ouml;&szlig;er die Latenz ist. Dies ist besonders </P
><P 

>verwunderlich, weil die Zeit f&uuml;r den Verbindungsaufbau zum Server unter dem HTTP/2 &ndash; Pro-tokoll unter 3G-Verbindung 600 ms weniger dauert. </P
><P 

>Der Parameter &bdquo;Start Render&ldquo; wird unter dem HTTP/2 &ndash; Protokoll unter Kabel-Verbindung ein wenig fr&uuml;her angezeigt. Aber mit zunehmender Latenz &auml;ndern sich die Ergebnisse rasant. Unter der 3G-Verbindung wird dieser Parameter unter dem HTTP/2 &ndash; Protokoll im Durchschnitt schon 800 ms sp&auml;ter angezeigt als unter dem HTTP/1.1 &ndash; Protokoll. Diese Unterschiede sind f&uuml;r das User Experience sehr kritisch (Rigor, Inc. 2016). </P
><P 

>Warum das HTTP/2 &ndash; Protokoll schlechtere Ergebnisse als das HTTP/1.1 &ndash; Protokoll liefert, ist auf den ersten Blick nicht klar. Um die Erkl&auml;rung f&uuml;r dieses Verhalten zu finden, muss man genauer schauen, wie die Kommunikation unter dem HTTP/2 &ndash; Protokoll zwischen dem Client und dem Server abl&auml;uft. Bevor die Schlussfolgerungen zu diesem Test gemacht werden, ist es sinnvoll nach den Ergebnissen der untersuchten Parameter f&uuml;r die Dozenten-Seite zu schauen. Bei der Dozenten-Seite ist die &bdquo;klassische&ldquo; Aufteilung von allen Ressourcen zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll noch mehr zu sehen: f&uuml;r das HTTP/2 &ndash; Protokoll werden nicht nur CSS und JavaScript Dateien klein gehalten, sondern auch alle Bilder werden explizit aufgeteilt. Wenn der Grund der Parameterverz&ouml;gerung unter dem HTTP/2 &ndash; Protokoll auf der gr&ouml;&szlig;eren Anzahl von Ressourcen liegt, ist zu erwarten, dass die Medianwerte der zu untersu-chenden Parameter sich noch st&auml;rker unterscheiden werden. </P
><H3 

><FONT size="+1">5.7.3. Test 2: Untersuchung der Dozenten-Seite unter den Protokollen HTTP/1.1- und HTTP/2. </H3
><P 

><FONT size="+1">Da in jedem Test die Zeit f&uuml;r den Verbindungsaufbau zum Server ungef&auml;hr gleich ist, wurden anhand von neun Tests die Medianwerte f&uuml;r DNS-, TCP- und TLS- Verbindungen ermittelt und unter Kabel- und 3G- Verbindung verglichen. Verglichen wurde die Zeit zum Verbindungsauf-bau unter dem HTTP/1.1 &ndash; Protokoll ohne Verschl&uuml;sselung und unter dem HTTP/2 &ndash; Protokoll. </P
><P 

>TCP, DNS, TLS </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

> </P
></TD
><TD  
 valign="top"
><P 

>DNS </P
></TD
><TD  
 valign="top"
><P 

>TCP </P
></TD
><TD  
 valign="top"
><P 

>TLS </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>60 ms </P
></TD
><TD  
 valign="top"
><P 

>78 ms </P
></TD
><TD  
 valign="top"
><P 

>97 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1 - Protokoll </P
></TD
><TD  
 valign="top"
><P 

>30 ms </P
></TD
><TD  
 valign="top"
><P 

>255 ms </P
></TD
><TD  
 valign="top"
><P 

>0 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Summe der Netzwerkverbindungszeit </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>235 ms </P
></TD
><TD  
 valign="top"
><P 

>285 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 29:</I><I> </I><I>Vergleich von HTTP/1.1 unverschl&uuml;sselt und HTTP/2 </I><I>&ndash;</I><I> verschl&uuml;sselt f&uuml;r die Dozenten-Seite unter Kabel-Verbindung </I></DD
></DL
><P 

>  </P
><P 

>TCP, DNS, TLS </P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

> </P
></TD
><TD  
 valign="top"
><P 

>DNS </P
></TD
><TD  
 valign="top"
><P 

>TCP </P
></TD
><TD  
 valign="top"
><P 

>TLS </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>627 ms </P
></TD
><TD  
 valign="top"
><P 

>958 ms </P
></TD
><TD  
 valign="top"
><P 

>653 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/1.1 - Protokoll </P
></TD
><TD  
 valign="top"
><P 

>309 ms </P
></TD
><TD  
 valign="top"
><P 

>1907 ms </P
></TD
><TD  
 valign="top"
><P 

>0 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Summe der Netzwerkverbindungszeit </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>2238 </P
></TD
><TD  
 valign="top"
><P 

>2216 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 30:</I><I> </I><I>Vergleich von HTTP/1.1 unverschl&uuml;sselt und HTTP/2 </I><I>&ndash;</I><I> verschl&uuml;sselt f&uuml;r die Dozenten-Seite unter 3G-Verbindung </I></DD
></DL
><P 

>Aus Tab. 29 und Tab. 30 ist zu erkennen, dass die Zeit f&uuml;r den Verbindungsaufbau zum Server zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll sich sowohl unter Kabel- als auch unter 3G-Verbindung nur ein wenig unterscheidet. Der Unterschied bei der Kabel-Verbindung liegt bei 50 ms und bei 3G-Verbindung bei 22 ms. Es ist interessant zu sehen, wie sich im aktuellen Test die zu untersuchenden Parameter unterscheiden werden. Falls die Webapplikation unter dem HTTP/2 &ndash; Protokoll langsamer als unter dem HTTP/1.1 &ndash; Protokoll geladen wird, wird der Grund nicht an der Netzwerkverbindungszeit liegen. </P
><P 

> &bdquo;Start Render&ldquo; </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_46.jpg" ><DL 

><DD 

></B><I>Abb. 46:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>974 ms </P
></TD
><TD  
 valign="top"
><P 

>683 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>948 ms </P
></TD
><TD  
 valign="top"
><P 

>682 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>996 ms </P
></TD
><TD  
 valign="top"
><P 

>692 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 31:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter Kabel-Verbindung. </I></DD
></DL
><P 

>Aus der Abb. 46 ist zu sehen, dass die Parameterwerte unter dem HTTP/2 &ndash; Protokoll deutlich sp&auml;ter als unter dem HTTP/1.1 &ndash; Protokoll ausgegeben werden. Der Unterschied zwischen den Medianwerten liegt bei 291 ms. </P
><P 

> </P
><P 

>Wenn der Parameter &bdquo;Start Render&ldquo; verz&ouml;gert ist, bedeutet es, dass die kritischen Dateien (im aktuellen Fall nur CSS Dateien) sp&auml;ter zum Client geliefert werden. Diese Ergebnisse kann man nicht einfach erkl&auml;ren, ohne den Transport der Pakete und die Lieferreihenfolge der einzelnen Frames genauer zu untersuchen. </P
><P 

> </P
><P 

>Aus Abb. 47 ist zu sehen, dass der Unterschied zwischen den Medianwerten bei etwa 1453 ms liegt. F&uuml;r die User Experience, besonders unter mobilen Netzwerken, ist dieser Unterschied mit fast 1,5 Sekunden sehr gro&szlig; (Rigor, Inc. 2016). Wenn man die Medianwerte des Tests zur Start-seite mit dem aktuellen Test vergleicht, ist sofort zu sehen, dass im aktuellen Test die Unter-schiede zwischen den Medianwerten des HTTP/1.1- und des HTTP/2 &ndash; Protokolls deutlich gr&ouml;-&szlig;er geworden sind. </P
><P 

>Der Grund f&uuml;r diese Ergebnisse ist immer noch nicht klar. Es kann jedoch vermutet werden, dass die Verz&ouml;gerung gr&ouml;&szlig;er wird, je mehr Ressourcen vom Server angefragt werden. Im ak-tuellen Test werden f&uuml;r das HTTP/1.1 &ndash; Protokoll drei CSS Dateien vorbereitet und f&uuml;r das HTTP/2 &ndash; Protokoll acht CSS Dateien. </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_47.jpg" ><DL 

><DD 

></B><I>Abb. 47:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter 3G-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>3437 ms </P
></TD
><TD  
 valign="top"
><P 

>1984 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>3417 ms </P
></TD
><TD  
 valign="top"
><P 

>1981,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>3442,5 ms </P
></TD
><TD  
 valign="top"
><P 

>2083 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 32:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter 3G-Verbindung. </I></DD
></DL
><P 

>&bdquo;domComplete&ldquo; </P
><P 

>Aus Abb. 48 sieht man, dass die Werte des Parameters &bdquo;domComplete&ldquo; unter dem HTTP/2 &ndash; Protokoll deutlich sp&auml;ter angezeigt werden. Der Unterschied zwischen den Median-werten liegt bei 190 ms.  </P
><P 

>Aus Abb. 49 sieht man, dass die Werte der ersten Messreihe deutlich sp&auml;ter ausgegeben wer-den. Der Unterschied zwischen den Medianwerten betr&auml;gt 2325 ms. </P
><P 

>Man sieht immer wieder, dass der Unterschied zwischen der Gesamtladezeit des HTTP/1.1- und des HTTP/2 &ndash; Protokolls gr&ouml;&szlig;er ist, je mehr Ressourcen unter der HTTP/2 &ndash; Verbindung &uuml;ber-tragen werden. Man darf allerdings nicht vergessen, dass die Zeit, die f&uuml;r den Verbindungsauf-bau zum Server ben&ouml;tigt wurde, unter 3G-Verbindung beim HTTP/1.1 &ndash; Protokoll im aktuellen Fall niedriger als beim HTTP/2 &ndash; Protokoll ist. </P
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_48.jpg" ><DL 

><DD 

></B><I>Abb. 48:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter Kabel-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>1416 ms </P
></TD
><TD  
 valign="top"
><P 

>1226 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>1379 ms </P
></TD
><TD  
 valign="top"
><P 

>1211,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>1455 ms </P
></TD
><TD  
 valign="top"
><P 

>1235,5 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 33:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter Kabel-Verbindung. </I></DD
></DL
><P 

><B> </P
><IMG width="605" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_49.jpg" ><DL 

><DD 

></B><I>Abb. 49:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter 3G-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2 &ndash; Protokoll </P
></TD
><TD  
 valign="top"
><P 

>HTTP/1.1 &ndash; Protokoll </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>6313 ms </P
></TD
><TD  
 valign="top"
><P 

>3988 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>6300 ms </P
></TD
><TD  
 valign="top"
><P 

>3958,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>6382,5 ms </P
></TD
><TD  
 valign="top"
><DL 

><DL 

><DL 

><DL 

><DL 

><DD 

>4005  </DD
></DL
></DL
></DL
></DL
></DL
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 34:</I><I> </I><I>Vergleich des Parameters &bdquo;domComplete&ldquo; </I><I>bei Anwendung des HTTP/1.1- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter 3G-Verbindung. </I></DD
></DL
><P 

> &bdquo;Visual Progress&ldquo; </P
><P 

> </P
><IMG width="449" height="313"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_50.jpg" ><DL 

><DD 

><I>Abb. 50:</I><I> </I><I>&bdquo;Visual Progress&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls auf die Dozenten-Seite unter Kabel-Verbindung. </I></DD
></DL
><P 

>Aus oben dargestellter Grafik sieht man, dass die ersten Inhalte der Webapplikation unter dem HTTP/1.1 &ndash; Protokoll 200 ms bis 300 ms fr&uuml;her angezeigt werden. Der Gro&szlig;teil der Inhalte wird beim HTTP/2 &ndash; Protokoll dagegen fr&uuml;her angezeigt. </P
><P 

>Aus den aufgenommenen Screenshots sieht man, wie schnell die Ressourcen auf dem Viewport erscheinen. Erste Pixel mit &Uuml;berschrift und Logo werden unter dem HTTP/1.1 &ndash; Protokoll etwas fr&uuml;her angezeigt. Unter dem HTTP/2 &ndash; Protokoll werden dagegen fast alle Ressourcen auf ein-mal angezeigt. D.h., dass unter dem HTTP/1 &ndash; Protokoll erste Pixel fr&uuml;her erscheinen, da die Ressourcen unter dem HTTP/2 &ndash; Protokoll l&auml;nger zum Herunterladen brauchen, jedoch unter dem HTTP/2 &ndash; Protokoll der Hauptteil des Inhaltes fr&uuml;her erscheint. </P
><P 

>Aus Abb. 51 geht hervor, dass erste Pixel der Webapplikation unter dem HTTP/2 &ndash; Protokoll etwa 1,5 Sekunden sp&auml;ter angezeigt werden, als beim HTTP/1.1 &ndash; Protokoll. Au&szlig;erdem sieht man, dass die Ressourcen beim HTTP/2 &ndash; Protokoll nacheinander &bdquo;portionsweise&ldquo; nachgeladen werden, w&auml;hrend fast alle Inhalte beim HTTP/1.1 - Protokoll den Client fr&uuml;her erreichen. </P
><P 

>Aus den Screenshots sieht man noch deutlicher, wie die Ressourcen unter dem HTTP/2 &ndash; Pro-tokoll nachgeladen werden. Erste Bilder beim HTTP/2 &ndash; Protokoll werden sp&auml;ter als das kom-plette Bild beim HTTP/1.1 &ndash; Protokoll angezeigt. Die Ressourcen werden beim HTTP/2 &ndash; Pro-tokoll deutlich l&auml;nger geladen. </P
><P 

> </P
><IMG width="508" height="361"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_51.jpg" ><DL 

><DD 

><I>Abb. 51:</I><I> </I><I>&bdquo;Visual Progress&ldquo; bei Anwendung des HTTP/1.1</I><I>- und des HTTP/2 </I><I>&ndash;</I><I> Protokolls auf die Dozenten-Seite unter 3G-Verbindung. </I></DD
></DL
><H3 

><FONT size="+1">5.7.4. Zwischenfazit: wie gro&szlig; sind die Unterschiede der Parameter des kritischen Rendering - Pfades zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll in Bezug auf die Dozenten-Seite der Webapplikation? </H3
><P 

><FONT size="+1">Der aktuelle Test hat gro&szlig;e Unterschiede in den untersuchten Parametern zwischen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll gezeigt. Wenn man die Testergebnisse des Tests der Startseite mit den Ergebnissen des aktuellen Tests vergleicht, sieht man, dass die Gesamtlade-zeit unter dem HTTP/2 &ndash; Protokoll gr&ouml;&szlig;er ist, je mehr Ressourcen geladen werden. Diese Situ-ation verst&auml;rkt sich deutlich unter der 3G-Verbindung. Gleichzeitig passiert dies unter fr&uuml;her genannten Bedingungen: </P
><DL 

><DD 

>&#61630; Gr&ouml;&szlig;ere Dateien k&ouml;nnten mehr Zeit zum Herunterladen brauchen. Dies liegt an der &bdquo;Slow Start&ldquo; &ndash; Funktion des TCP &ndash; Protokolls (siehe Unterkapitel &bdquo;3.1 HTTP/1.1 &ndash; Opti-mierungstechniken, Stand bisher&ldquo;). Deshalb ist es sehr verwunderlich, dass kleinere Dateien unter dem HTTP/2 &ndash; Protokoll bei 3G-Verbindung viel mehr Zeit zum Herun-terladen brauchen, als gr&ouml;&szlig;ere Dateien unter dem HTTP/1.1 &ndash; Protokoll. <FONT color="#FF0000"> </DD
><DD 

><FONT color="#000000">&#61630; Das HTTP/2 &ndash; Protokoll verwendet die &bdquo;Header Kompression&ldquo; &ndash; Technologie, die daf&uuml;r sorgt, dass nur wenige Bytes innerhalb der Sitzung transportiert werden. </DD
></DL
><P 

>Um die Antwort auf die Frage zu finden, warum die Webapplikation unter dem HTTP/2 &ndash; Pro-tokoll deutlich langsamer l&auml;dt als unter dem HTTP/1.1 &ndash; Protokoll, sollte man den genauen Austausch der Frames zwischen Client und Server beobachten. Deshalb wird im n&auml;chsten Test untersucht, wie gro&szlig; die Parameterunterschiede sind, wenn man wenige gro&szlig;e Dateien oder mehrere kleine Dateien verwendet. </P
><H2 

><FONT size="+1">5.8. Spielt die Ressourcenaufteilung eine Rolle f&uuml;r das HTTP/2 &ndash; Protokoll? </H2
><P 

><FONT size="+1">Die Aufteilung der Ressourcen kann sowohl ein Performance- als auch ein Entwicklungskrite-rium sein. Dies gilt f&uuml;r jede Webapplikation: je kleiner die Ressourcen gehalten werden, desto einfacher und &uuml;bersichtlicher ist es, um die Webapplikation zu entwickeln. Dies betrifft vor al-lem die Ma&szlig;nahmen, die speziell f&uuml;r die Frontend Performance &ndash; Optimierung gemacht wur-den, z.B. Zusammenf&uuml;gen von kritischen Ressourcen und Bildern unter dem HTTP/1.1 &ndash; Proto-koll. Au&szlig;erdem ist es praktischer, um kleinere Dateien zu cachen, falls die &Auml;nderungen nur in einem Teil der Webapplikation stattgefunden haben. Noch ein wichtiges Kriterium ist, dass gr&ouml;&szlig;ere Dateien unter hoher Latenz, die in Mobilen Netzwerken besteht, langsamer herunter-geladen werden (siehe Unterkapitel &bdquo;3.1. HTTP/1.1 &ndash; Optimierungstechniken, Stand bisher&ldquo;). </P
><P 

>Wie die Theorie besagt, m&uuml;ssen die f&uuml;r das HTTP/1.1 &ndash; Protokoll unternommenen Ma&szlig;nahmen zur Ressourcenzusammenfassung unter dem HTTP/2 &ndash; Protokoll nicht wiederholt werden (NGINX, Inc. 2015, 13) (siehe Unterkapitel &bdquo;3.4. M&ouml;gliche Optimierungstechniken f&uuml;r das HTTP/2 &ndash; Protokoll&ldquo;). Die Tests, in denen die Parameter des kritischen Rendering &ndash; Pfades zwi-schen dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll verglichen wurden, haben gezeigt, dass das HTTP/1.1 &ndash; Protokoll bessere Ergebnisse liefert. Es ist allerdings interessant zu pr&uuml;fen, wie die </P
><P 

>&Uuml;bergabe von kleineren Dateien die Parameter des kritischen Rendering &ndash; Pfades unter dem HTTP/2 &ndash; Protokoll verz&ouml;gern wird. Um die Unterschiede in den Parametern genauer sehen zu k&ouml;nnen, wird die Webapplikation nur unter 3G-Verbindung aufgerufen. </P
><P 

>In diesem Test sind besonders die Parameter &bdquo;Start Render&ldquo;, &bdquo;domComplete&ldquo;  und &bdquo;Visual Pro-gress&ldquo; interessant. Da im aktuellen Test die Anwendung von &bdquo;Server Push&ldquo; nicht benutzt wird, sind die Untersuchung des Parameters &bdquo;Time To First Byte&ldquo;, &bdquo;Bytes Out&ldquo; und die DOM-Erstel-lung nicht relevant. </P
><P 

><I>Testbedingungen</I>:<B> </B>untersucht wird die Dozenten-Seite der Webapplikation unter dem HTTP/2 &ndash; Protokoll. Im Fall der Anwendung mit vielen kleinen Dateien werden acht CSS Da-teien, 43 Bilder und 12 JavaScript Dateien verwendet. Im Fall der Anwendung mit wenig gro&szlig;en Dateien werden drei CSS Dateien, zwei JavaScript Dateien und ein gro&szlig;es Sprite-Bild benutzt. In beiden F&auml;llen haben die Dateien die gleichen Inhalte. </P
><P 

>&bdquo;Start Render&ldquo; </P
><P 

>Aus Abb. 52 ist zu erkennen, dass der Parameter &bdquo;Start Render&ldquo; f&uuml;r die Anwendung mit vielen kleineren Dateien sp&auml;ter ausgegeben wird. Der Unterschied zwischen den Medianwerten liegt bei 18 ms. Da sich die erste H&auml;lfte der Box der ersten Messreihe und die zweite H&auml;lfte der Box der zweiten Messreihe &uuml;berlappen, kann man sagen, dass der Parameter &bdquo;Start Render&ldquo; f&uuml;r die Anwendung mit vielen kleineren Dateien im Durchschnitt etwas sp&auml;ter ausgegeben wird. </P
><P 

><B> </P
><IMG width="586" height="230"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_52.jpg" ><DL 

><DD 

></B><I>Abb. 52:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung von vielen aufgeteilten Dateien </I><I>und wenigen gro&szlig;en Dateien unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll bei 3G-Verbindung. </I></DD
></DL
><P 

> <I> </I></P
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: viele kleinere Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: wenige gr&ouml;&szlig;ere Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>3437 ms </P
></TD
><TD  
 valign="top"
><P 

>3419 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>3417 ms </P
></TD
><TD  
 valign="top"
><P 

>3383,5 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>3442,5 ms </P
></TD
><TD  
 valign="top"
><P 

>3429 ms </P
></TD
></TR
></TABLE
><DL 

><DD 

><I>Tab. 35:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung von vielen aufgeteilten Dateien </I><I>und wenigen gro&szlig;en Dateien unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll bei 3G-Verbindung. </I></DD
></DL
><P 

>Diese Unterschiede sind im Durchschnitt nicht so gro&szlig;. Trotzdem wiedersprechen diese Ergeb-nisse den Erwartungen. Die Schlussfolgerungen zu diesen Ergebnissen werden im Zwischenfa-zit beschrieben. </P
><P 

>&bdquo;domComplete&ldquo; </P
><P 

>Aus Abb. 53 l&auml;sst sich schlie&szlig;en, dass die Anwendung mit vielen aufgeteilten Dateien deutlich mehr Zeit f&uuml;r das Herunterladen aller Ressourcen braucht. Der Unterschied zwischen den Me-dianwerten liegt bei 1676 ms. Diese Ergebnisse sind nicht sofort erkl&auml;rbar und die Vermutun-gen werden im Zwischenfazit beschrieben. </P
><P 

><B> </P
><IMG width="604" height="238"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_53.jpg" ><DL 

><DD 

></B><I>Abb. 53:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung von vielen aufgeteilten Dateien </I><I>und wenigen gro&szlig;en Dateien unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll bei 3G-Verbindung. </I></DD
></DL
><TABLE 
 border=0 cellspacing=0 cellpadding=2
><TR  

><TD  
 valign="top"
><P 

>Parameter </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: viele kleinere Dateien </P
></TD
><TD  
 valign="top"
><P 

>HTTP/2: wenige gr&ouml;&szlig;ere Dateien </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Median </P
></TD
><TD  
 valign="top"
><P 

>6300 ms </P
></TD
><TD  
 valign="top"
><P 

>4624 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Unteres Quartil  </P
></TD
><TD  
 valign="top"
><P 

>6382,5 ms </P
></TD
><TD  
 valign="top"
><P 

>4609 ms </P
></TD
></TR
><TR  

><TD  
 valign="top"
><P 

>Oberes Quartil </P
></TD
><TD  
 valign="top"
><P 

>6313 ms </P
></TD
><TD  
 valign="top"
><P 

>4633 ms </P
></TD
></TR
></TABLE
><P 

> </P
><DL 

><DD 

><I>Tab. 36:</I><I> </I><I>Vergleich des Parameters &bdquo;Start Render&ldquo; bei Anwendung von vielen aufgeteilten Dateien </I><I>und wenigen gro&szlig;en Dateien unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll bei 3G-Verbindung. </I></DD
></DL
><P 

>  </P
><P 

> &bdquo;Visual Progress&ldquo; </P
><P 

> </P
><IMG width="502" height="343"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_54.jpg" ><DL 

><DD 

><I>Abb. 54:</I><I> </I><I>&bdquo;Visual Progress&ldquo; bei Anwendung von vielen aufgeteilten Dateien und wenigen gro&szlig;en </I><I>Dateien unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll bei 3G-Verbindung. </I></DD
></DL
><P 

>Aus der oben dargestellten Grafik sieht man, dass in beiden Anwendungen die ersten Pixel fast gleichzeitig auf dem Viewport angezeigt wurden. Einen gr&ouml;&szlig;eren Unterschied sieht man, beim Ladefortschritt der Inhalte der Webapplikation. Bei der Anwendung mit vielen kleinen Dateien werden die Inhalte stetig nacheinander geladen. Im Gegenteil werden die Inhalte bei der An-wendung mit wenigen gro&szlig;en Dateien in einem gro&szlig;en Sprung geladen. Dies liegt an dem einen gro&szlig;en Bild. </P
><P 

>Aus den aufgenommenen Screenshots kann man sehen, wie die Ressourcen geladen werden. In dem Moment, in dem das gro&szlig;e Bild der Anwendung mit wenigen gro&szlig;en Dateien angezeigt wird, ist schon etwa die H&auml;lfte der kleineren Bilder der zweiten Anwendung erschienen. F&uuml;r das User Experience ist in diesem Fall die Anwendung mit vielen aufgeteilten Ressourcen besser, da die Nutzer schon etwa 400 ms fr&uuml;her erste Bilder auf der Seite sehen k&ouml;nnen. </P
><P 

>Das verwunderliche ist, dass die Anwendung mit vielen kleineren Dateien deutlich mehr Zeit braucht, um alle Ressourcen herunterzuladen. Aus den Screenshots sieht man, dass der Unter-schied bei 1,6 Sekunden liegt. </P
><H3 

><FONT size="+1">5.8.1. Zwischenfazit: Best&auml;tigt sich die &Uuml;berlegung, nach der aufgeteilte kleinere Dateien f&uuml;r das HTTP/2 &ndash; Protokoll besser sind? </H3
><P 

><FONT size="+1">Im Laufe des Tests wurde festgestellt, dass die Anwendung mit vielen kleinen Dateien unter mobilen Netzwerken mehr Zeit zum Laden braucht als die Anwendung mit wenigen gro&szlig;en </P
><P 

>Dateien. Dies sieht man auch bei den Unterschieden zwischen dem Parameter &bdquo;Start Render&ldquo;. Was k&ouml;nnte der Grund daf&uuml;r sein? </P
><P 

>Die Antwort auf die Frage, warum kleinere Dateien unter dem HTTP/2 &ndash; Protokoll bei hoher Latenz l&auml;nger zum Herunterladen brauchen, als gr&ouml;&szlig;ere Dateien, l&auml;sst sich nicht einfach finden. Deshalb wird die Dozenten-Seite unter gleichen Bedingungen noch am lokalen PC mithilfe vom Browser &bdquo;Mozilla Firefox&ldquo;, Version 47.0 aufgerufen und einzelne TCP &ndash; Pakete in &bdquo;Wireshark&ldquo; genauer untersucht. Im Browser &bdquo;Mozilla Firefox&ldquo; gibt es keine &bdquo;Throttling&ldquo;-Funktion oder kein Add-on, mithilfe dessen man die Verbindung simulieren kann und die Latenz steuern kann. Deshalb wird unter Kabel-Verbindung geschaut, wie die Pakete dem Client zugestellt werden. </P
><P 

>Mit der Aufnahme von &bdquo;Wireshark&ldquo; kann man genauer sehen, wie die Kommunikation zwischen dem Client und dem Server stattfindet. Zuerst werden die Ressourcen mithilfe von HEA-DERS &ndash; Frames vom Client angefragt. Abb.55 veranschaulicht den Kommunikationsprozess zwischen dem Client und dem Server unter dem HTTP/2 &ndash; Protokoll. Es werden mehrere Res-sourcen nacheinander angefragt. Danach schickt der Server die Antworten an den Client. Dies passiert in folgender Reihenfolge: zuerst kommt der HEADERS &ndash; Frame, gefolgt vom DATA &ndash; Frame der als erstes vom Client angefragten Datei. Danach erreicht die n&auml;chste Res-source den Client. Deshalb kann man sagen, dass die Ressourcen den Client in der FIFO (First In-First Out) &ndash; Reihenfolge erreichen. Nachdem die zuerst angefragten Dateien den Client er-reichen, wird die n&auml;chste &bdquo;Ressourcenportion&ldquo; vom Server angefragt. Dies bedeutet, dass meh-rere angefragte Dateien gleichzeitig am Server bearbeitet werden. Manchmal werden mehrere HEADERS- oder DATA &ndash; Frames nacheinander geliefert. </P
><P 

> </P
><IMG width="330" height="290"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_55.jpg" ><DL 

><DD 

><I>Abb. 55:</I><I> </I><I>Schematische Darstellung des Kommunikationsprozesses zwischen dem Client (Mozilla Firefox 47.0) und dem Server (Apache 2.4.20) unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll </I></DD
></DL
><P 

><I>  </I></P
><P 

><I>Woran k&ouml;nnte es liegen, dass unter dem HTTP/1.1 </I><I>&ndash;</I><I> Protokoll die Dateien schneller geladen wer-</I><I>den, als unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll? </I></P
><P 

>Im aktuellen Test wurde festgestellt, dass f&uuml;r den Parameter &bdquo;Start Render&ldquo; unter dem HTTP/2 &ndash; Protokoll die Webapplikation mit aufgeteilten Dateien etwas besser ist, weil kleinere Bilder schneller im Browser erscheinen. Allerdings sind die Parameter &bdquo;Start Render&ldquo; und &bdquo;dom-Complete&ldquo; bei Anwendung von aufgeteilten Dateien langsamer. Auch in einem Test zuvor wurde festgestellt, dass die Webapplikation mit aufgeteilten Ressourcen unter dem HTTP/2 &ndash; Protokoll sp&auml;ter im Browser angezeigt wird, als unter dem HTTP/1.1 &ndash; Protokoll mit zusammengefassten Dateien.  </P
><P 

>Es ist interessant, die Ergebnisse des aktuellen Tests mit den Ergebnissen des Tests zuvor (&bdquo;Un-tersuchung der Dozenten-Seite unter dem HTTP/1.1- und HTTP/2 &ndash; Protokoll, unter 3G-Ver-bindung&ldquo;) zu vergleichen. Wenn man die aufgenommenen Screenshots dieser Tests miteinan-der vergleicht, ist zu sehen, dass alle Dateien, egal ob sie aufgeteilt oder zusammengefasst sind, unter dem HTTP/2 &ndash; Protokoll l&auml;nger zum Laden brauchen als unter dem HTTP/1.1 &ndash; Pro-tokoll. Dazu kommt noch, dass der Parameter &bdquo;Start Render&ldquo; unter dem HTTP/2 &ndash; Protokoll auch in beiden F&auml;llen sp&auml;ter ausgegeben wird. Dies bedeutet, dass nicht nur eine gr&ouml;&szlig;ere An-zahl an Ressourcen, die durch genau eine TCP &ndash; Verbindung l&auml;uft, eine entscheidende Rolle an der Parameterverz&ouml;gerung spielt. </P
><P 

>Es gibt noch eine Vermutung, warum die Webapplikation unter dem HTTP/2 &ndash; Protokoll lang-samer ist, als beim HTTP/1.1 &ndash; Protokoll. Es sieht so aus, als ob die Multiplexierung von &bdquo;Fra-mes&ldquo; nicht perfekt funktioniert. Zuerst kommt eine &bdquo;Portion&ldquo; von HEADERS - Frames zum Ser-ver, der nachher in der Reihenfolge &bdquo;First In-First Out&ldquo; die Ressourcen zur&uuml;ck liefert (siehe Abb. 107). Au&szlig;erdem ist selten zu sehen, dass zwischen HEADERS &ndash; Frame und DATA &ndash; Frame eines &bdquo;Streams&ldquo; noch die &bdquo;Frames&ldquo; von einem anderen &bdquo;Stream&ldquo; reinkommen. Dadurch sieht man, dass die &bdquo;Frames&ldquo; nicht wirklich durchmischt sind. Es w&auml;re wahrscheinlich besser, wenn die Requests und Responses von unterschiedlichen &bdquo;Streams&ldquo; besser durchmischt werden, da-mit der Server nicht lange auf Anfragen warten muss und diese dann gleichzeitig bearbeiten muss (siehe Abb. 55). </P
><P 

>Ein weiterer Grund k&ouml;nnte sein, dass trotz der Verbindungsaufbauzeit zum Server, sechs oder mehr Verbindungen die Ressourcen schneller an den Client liefern k&ouml;nnen, als nur eine TCP &ndash; Verbindung unter dem HTTP/2 &ndash; Protokoll. </P
><P 

>Es bleibt aber schwierig, eine genaue Aussage dar&uuml;ber zu machen. Auf der Dokumentations-seite des Apache-Moduls, das das HTTP/2 &ndash; Protokoll implementiert, steht, dass sich dieses Modul im experimentellen Stadium befindet (Apache Software Foundation 2016a). Daher ist schwer zu sagen, wie genau der Browser die Responses bearbeitet. Die Frage, warum die Webapplikation unter dem verschl&uuml;sselten HTTP/2 &ndash; Protokoll mehr Zeit braucht, um erste </P
><P 

>Pixel anzuzeigen und die Ressourcen herunterzuladen, als unter dem unverschl&uuml;sselten HTTP/1.1 &ndash; Protokoll, bleibt noch offen. </P
><H2 

><FONT size="+1">5.9. Wie funktioniert das HTTP/2 &ndash; Protokoll in anderen Browsern? </H2
><P 

><FONT size="+1">Bisher wurden alle Tests mit dem Client &bdquo;Mozilla Firefox&ldquo; (Version 47.0) gemacht. Es ist interes-sant, zu beobachten, wie andere Browser die HTTP/2 &ndash; Implementierung bearbeiten. Laut den &bdquo;StatCounter Global Stats&ldquo; Statistiken (siehe Anhang 9.2) , gibt es im Wesentlichen drei Browser weltweit, die zwischen August 2015 und Juli 2016 auf Desktop-PCs benutzt werden: &bdquo;Chrome&ldquo; mit fast 60% Nutzeranteil, &bdquo;Firefox&ldquo; mit fast 16% und &bdquo;Internet Explorer&ldquo; (Version 11) mit 10,5% (Anhang 9.2) (StatCounter 2016). Deshalb wird das HTTP/2 &ndash; Protokoll unter den Browsern &bdquo;Chrome&ldquo; (Version 52.0) und &bdquo;Internet Explorer&ldquo; (Version 11) getestet. Au&szlig;erdem wird ge-schaut, wie diese Browser per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen bearbeiten. </P
><P 

>Um zu vergleichen, wie schnell diese Browser die Webapplikation unter dem HTTP/2 &ndash; Protokoll auf dem Viewport anzeigen, wird der Parameter &bdquo;Visual Progress&ldquo; f&uuml;r jeden Browser betrachtet. Danach werden die Ergebnisse der Implementierung des HTTP/2 &ndash; Protokolls bei diesen Brow-sern verglichen. </P
><H3 

><FONT size="+1">5.9.1. Test 1: Gibt es deutliche Unterschiede in der Bearbeitungsart des neuen Pro-tokolls zwischen den drei popul&auml;rsten Desktop-Browsern? </H3
><P 

><FONT size="+1"><I>Testbedingungen:</I> als Testseite dient die Dozenten-Seite der Webapplikation. Die Webapplika-tion wurde jeweils neun Mal mit den drei Browsern mithilfe von &bdquo;Webpagetest.org&ldquo; aufgerufen.  </P
><P 

>Zum Vergleich wird der Medianwert verwendet (von &bdquo;Webpagetest.org&ldquo; ausgew&auml;hlter Wert, der sich an dem Parameter &bdquo;Start Render&ldquo; orientiert). </P
><P 

>Aus Abb. 56 ist zu sehen, dass der Parameter &bdquo;Visual Progress&ldquo; unter &bdquo;Mozilla Firefox&ldquo; und &bdquo;Microsoft IE&ldquo; &auml;hnlich ist. Nun kann man sagen, dass in &bdquo;Microsoft IE&ldquo; die Webapplikation etwas fr&uuml;her angezeigt wird und die meisten Inhalte (bei fast 100%) den Client etwas fr&uuml;her erreichen werden. Gleichzeitig sieht man, dass die Inhalte unter &bdquo;Google Chrome&ldquo; deutlich sp&auml;ter ange-zeigt werden. Interessant zu bemerken ist, dass bis 4,4 Sekunden nur etwa 20% des Inhalts angezeigt wird. Um diese Ergebnisse besser verstehen zu k&ouml;nnen, wird geschaut, wie diese Browser das HTTP/2 &ndash; Protokoll verarbeiten. </P
><P 

> </P
><IMG width="510" height="354"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_56.jpg" ><DL 

><DD 

><I>Abb. 56:</I><I> </I><I>&bdquo;Visual Progress&ldquo; in Mozilla Firefox v.47.0, Microsoft IE11 und Google Chrome v.52.0 </I><I>unter dem HTTP/2 </I><I>&ndash;</I><I> Protokoll und Kabel-Verbindung. </I></DD
></DL
><P 

>Wenn man den Ressourcenwasserfall unter &bdquo;Microsoft IE11&ldquo; anschaut, sieht man, dass das HTTP/2 &ndash; Protokoll als HTTP/1.1 &ndash; Protokoll mit TLS &ndash; Verschl&uuml;sselung interpretiert wird. Dies bedeutet, dass der Client (&bdquo;Microsoft IE11&ldquo;) das HTTP/2 &ndash; Protokoll nicht versteht und die Kom-munikation beim HTTP/1.1 - Protokoll geblieben ist. Zur Pr&uuml;fung wurde die Webapplikation mit dem gleichen Browser am lokalen PC aufgerufen. Die Ergebnisse waren die gleichen. &bdquo;Microsoft IE&ldquo;  blieb beim HTTP/1.1 &ndash; Protokoll mit TLS &ndash; Verschl&uuml;sselung. </P
><P 

>Die Kommunikation zwischen dem Server und dem Browser &bdquo;Google Chrome&ldquo; l&auml;uft jedoch als HTTP/2 &ndash; Protokoll. Der Browser &bdquo;Google Chrome&ldquo; akzeptiert das HTTP/2 &ndash; Protokoll. Es ist allerdings sehr verwunderlich, dass der Unterschied der Ladezeit der Webapplikation zwischen &bdquo;Mozilla Firefox&ldquo; und &bdquo;Google Chrome&ldquo; sehr gro&szlig; ist. Wenn man den Ressourcenwasserfall bei &bdquo;Google Chrome&ldquo; betrachtet, ist auff&auml;llig, dass die Ressourcen, wie beim HTTP/1.1 &ndash; Protokoll, nacheinander geladen werden. Aus dem &bdquo;Connection View&ldquo; (im &bdquo;Webpagetest.org&ldquo; - Tool) ist zu sehen, dass es innerhalb einer TCP &ndash; Verbindung viele leere Stellen gibt, an denen der Server keine Inhalte liefert (Abb. 57). </P
><P 

> </P
><IMG width="559" height="175"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_57.jpg" ><DL 

><DD 

><I>Abb. 57:</I><I> </I><I>&bdquo;Connection View&ldquo; f&uuml;r die Startseite beim &bdquo;Google Chrome&ldquo;</I><I>-Client </I></DD
></DL
><P 

>Es ist nicht klar, was die Client-Seite an den leeren Stellen macht. Wenn man den Ressourcen-wasserfall mit dem &bdquo;Connection View&ldquo; vergleicht, ist zu beobachten, dass, nachdem eine &bdquo;Por-tion&ldquo; von Ressourcen geladen wird, mehrere hundert Millisekunden nichts passiert. Danach wird die n&auml;chste &bdquo;Portion&ldquo; Ressourcen vom Client angefragt und geliefert. </P
><P 

>Der Frame-Austausch zwischen dem Client &bdquo;Google Chrome&ldquo; mit Version 52.0 und dem Server unter dem HTTP/2 &ndash; Protokoll soll genauer betrachtet werden. Daf&uuml;r wird die Webapplikation am lokalen PC aufgerufen und mithilfe von &bdquo;Wireshark&ldquo; genauer untersucht. </P
><P 

>Anhand der Mitschnitte sieht man, dass die Ressourcen nacheinander aufgerufen und an den Client geliefert werden. Dieser Datenmitschnitt ist sehr &auml;hnlich zum Datenmitschnitt aus dem Browser &bdquo;Mozilla Firefox&ldquo;. Es ist allerdings zu bemerken, dass die Frames-Multiplexierung im Browser &bdquo;Google Chrome&ldquo; scheinbar etwas besser funktioniert. </P
><P 

>Nach dem Aufruf der Webapplikation am lokalen PC durch den Browser &bdquo;Google Chrome&ldquo; wurde die &bdquo;.har&ldquo; Datei gespeichert. Wenn man diese Datei in einem &bdquo;Har Viewer&ldquo; ansieht (Hem-ming 2016), (Duran 2016), sieht man den gesamten Ressourcenwasserfall. Hier sieht man eine ganz andere Ressourcenauslieferung als im &bdquo;Webpagetest.org&ldquo; &ndash; Tool. Alle Ressourcen werden einigerma&szlig;en gleichzeitig angefragt, ohne dass leere Stellen beobachtet werden k&ouml;nnen. Dies zeigt, dass sich die Funktionsweise des Browsers &bdquo;Google Chrome&ldquo; am lokalen PC und im &bdquo;Webpagetest.org&ldquo; &ndash; Tool stark unterscheiden.  </P
><P 

>In diesem Fall ist es interessant, die Ressourcenwasserf&auml;lle aus &bdquo;Google Chrome&ldquo; und &bdquo;Mozilla Firefox&ldquo;, die am lokalen PC aufgenommen wurden, miteinander zu vergleichen. Dies kann man mithilfe eines &bdquo;Har-Viewer&ldquo; machen (Hemming 2016), (Duran 2016). Es ist zu sehen, dass Res-sourcen, welche durch &bdquo;Mozilla Firefox&ldquo; aufgerufen wurden, etwas schneller geladen werden. </P
><H3 

><FONT size="+1">5.9.2. Zwischenfazit: Gibt es deutliche Unterschiede in der Bearbeitungsart des neuen Protokolls zwischen den drei popul&auml;rsten Desktop-Browsern? </H3
><P 

><FONT size="+1">Aus den oben dargestellten Ergebnissen kann man sagen, dass jeder Browser auf seine eigene Weise das HTTP/2 &ndash; Protokoll bearbeitet. Es wurde festgestellt, dass der Client &bdquo;Microsoft IE11&ldquo; das HTTP/2 &ndash; Protokoll nicht versteht. Neuere Versionen dieses Browsers k&ouml;nnen die existie-rende HTTP/2 &ndash; Implementierung evtl. anders interpretieren. </P
><P 

>Die zweite Feststellung war die, dass der Browser &bdquo;Google Chrome&ldquo; das HTTP/2 &ndash; Protokoll ganz anders bearbeitet, als der Browser &bdquo;Mozilla Firefox&ldquo;. Allerdings unterscheiden sich die Ergebnisse des &bdquo;Webpagetest.org&ldquo; &ndash; Tool von denen am lokalen PC. Aber in beiden F&auml;llen sieht man, dass die Webapplikation, die durch &bdquo;Mozilla Firefox&ldquo; aufgerufen wurde, schneller geladen wurde. Es ist schwer zu sagen, auf welche Art die Browser die Ressourcen bearbeiten.  Es wird aber wohl noch etwas Zeit brauchen, bis alle Browser das HTTP/2 &ndash; Protokoll richtig interpretieren werden. </P
><H3 

><FONT size="+1">5.9.3. Test2: Wie wird der Browser &bdquo;Google Chrome&ldquo; per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen interpretieren? </H3
><P 

><FONT size="+1">Im Unterkapitel &bdquo;Wie funktioniert Server Push?&ldquo; wurde die Funktionsweise des &bdquo;Server Pushs&ldquo; erkl&auml;rt und alle dazugeh&ouml;rigen Tests wurden mithilfe des Browsers &bdquo;Mozilla Firefox&ldquo; gemacht. Im zuvor gemachten Test wurde festgestellt, dass der Browser &bdquo;Microsoft IE11&ldquo; das HTTP/2 &ndash; Protokoll nicht bearbeiten kann. Aus diesen Gr&uuml;nden wurde im aktuellen Test nur geschaut, wie &bdquo;Google Chrome&ldquo; gepushte Ressourcen bearbeitet. </P
><P 

><I>Testbedingungen</I><B>: </B>die Dozenten-Seite der Webapplikation wird untersucht. Es wurden 10 CSS Dateien per &bdquo;Server Push&ldquo; &uuml;bergeben. Die Webapplikation wurde neun Mal unter &bdquo;Mozilla Fire-fox&ldquo; und &bdquo;Google Chrome&ldquo; mithilfe von &bdquo;Webpagetest.org&ldquo; aufgerufen. Zus&auml;tzliche Untersu-chungen unter &bdquo;Mozilla Firefox&ldquo; dienen dazu, um die Ergebnisse mit &bdquo;Google Chrome&ldquo; verglei-chen zu k&ouml;nnen. </P
><P 

>Zum Vergleich dient ein von &bdquo;Webpagestest.org&ldquo; ermittelter Medianwert. </P
><P 

>Aus Abb. 58 sieht man, dass die Unterschiede zwischen der Zeit der Erstdarstellung und der Darstellung der meisten Inhalte auf dem Viewport zwischen beiden Browsern sehr gro&szlig; ist. Der Unterschied zwischen der Zeit der Erstdarstellung betr&auml;gt etwa 3,5 Sekunden. Aus dem Res-sourcenwasserfall sieht man aber, dass &bdquo;Server Push&ldquo; innerhalb des Browsers &bdquo;Google Chrome&ldquo; akzeptiert wird und die Ressourcen wie erwartet den Client erreichen. </P
><P 

> </P
><IMG width="502" height="355"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_58.jpg" ><DL 

><DD 

><I>Abb. 58:</I><I> </I><I>&bdquo;Visual Progress&ldquo; in &bdquo;Mozilla Firefox&ldquo; v.47.0, und &bdquo;Google Chrome&ldquo; v.52.0 unter dem </I><I>HTTP/2 </I><I>&ndash;</I><I> </I><I>Protokoll mit per &bdquo;Server Push&ldquo; &uuml;bergebenen CSS Dateien bei Kabel</I><I>-Verbindung. </I></DD
></DL
><P 

>Der vorangegangene Test hat gezeigt, dass die Ressourcen unter dem HTTP/2 &ndash; Protokoll mit-hilfe des Browsers &bdquo;Google Chrome&ldquo; deutlich l&auml;nger geladen werden als unter dem Browser &bdquo;Mozilla Firefox&ldquo;. Es wurde bemerkt, dass gro&szlig;e Unterschiede nur anhand der Daten des &bdquo;Web-pagetest.org&ldquo; &ndash; Tools erkannt werden k&ouml;nnen. Aus diesem Grund wird die Webapplikation am lokalen PC mithilfe von &bdquo;Wireshark&ldquo; zus&auml;tzlich untersucht. </P
><P 

>Es wird der Browser &bdquo;Google Chrome&ldquo; v. 52.0 verwendet. W&auml;hrend die Ressourcennachladung mithilfe der Entwicklertools im Browser untersucht worden ist, wurde bemerkt, dass gepushte CSS Dateien noch einmal nachgefragt werden. Dies sieht man aus dem Ressourcenwasserfall. Dies passiert, nachdem alle Bilder und JavaScript Dateien fertig geladen wurden. Dies kann nur bedeuten, dass alle per &bdquo;Server Push&ldquo; &uuml;bergebenen Ressourcen von der verwendeten Browser-version nicht vollst&auml;ndig akzeptiert wurden und deshalb noch einmal nachgefragt werden. </P
><P 

>Die gleiche Vorgehensweise sieht man im Datenmittschnitt von &bdquo;Wireshark&ldquo;. Wenn man in &bdquo;Wireshark&ldquo; den Filter auf eine der gepushten CSS Dateien anwendet: <I>&bdquo;http2.header.value == &quot;/css/style.css&quot;&ldquo;</I>, sieht man, dass diese zuerst mit einem PUSH_PROMISE &ndash; Frame angek&uuml;ndigt wird (siehe das Beispiel auf dem beigelegten Datentr&auml;ger unter &bdquo;Unterschiedliche Brow-ser\HTTP2 Server Push_CSS\Google Chrome\Aus dem Arbeits-PC\Server Push Chrome .pcapng&ldquo;). Wenn man den dazugeh&ouml;rigen &bdquo;Stream&ldquo; mit dem Filter <I>&bdquo;http2.Streamid == 2&ldquo; </I>ver-folgt, sieht man, dass diese Datei dem Client zugestellt wird. Danach wird diese Datei jedoch nochmal am Server angefragt und dem Client zugestellt. Man kann nur einen Unterschied zwi-</P
><P 

>schen der Gr&ouml;&szlig;e des TCP &ndash; Paketes erkennen, in dem HEADERS- und DATA &ndash; Frames zusam-men &uuml;bertragen wurden. Wenn die Daten dieser Datei durch &bdquo;Server Push&ldquo; zugestellt wurden, betr&auml;gt die Gr&ouml;&szlig;e des TCP &ndash; Paketes 292 Bytes. Wenn die Datei vom Browser angefragt wird, hat das TCP &ndash; Paket vom Server eine andere Gr&ouml;&szlig;e von HEADERS- und DATA &ndash; Frames, n&auml;mlich 1506 Bytes. </P
><P 

>Daher kann man sagen, dass die vom Server zuerst gelieferten Daten nicht vollst&auml;ndig am Cli-ent ankommen. Deshalb fr&auml;gt der Client diese Dateien noch Mal an. </P
><H3 

><FONT size="+1">5.9.4. Zwischenfazit: Wie wurden per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen auf der Client-Seite durch den Browser &bdquo;Google Chrome&ldquo; bearbeitet? </H3
><P 

><FONT size="+1">In einem zuvor durchgef&uuml;hrten Test wurde festgestellt, dass das HTTP/2 &ndash; Protokoll unter &bdquo;Google Chrome&ldquo; anders bearbeitet wird, als bei &bdquo;Mozilla Firefox&ldquo;. Im aktuellen Test wurde besonders darauf geachtet, wie der Browser per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen bear-beitet. Man sieht wieder, dass, obwohl die Browserversionen beim &bdquo;Webpagetest.org&ldquo; &ndash; Tool und am lokalen PC die gleichen sind, sie ganz unterschiedliche Ergebnisse zeigen. Aus den Ergebnissen des &bdquo;Webpagetest.org&ldquo; &ndash; Tools ist zu bemerken, dass der &bdquo;Server Push&ldquo; - Einsatz wie gew&ouml;hnlich funktioniert. Anders sehen die Ergebnisse aus, die am lokalen PC aufgenom-men wurden. Bei der Untersuchung am lokalen PC wurde festgestellt, dass per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen den Client nicht vollst&auml;ndig erreichen. Deshalb wurden gepushte Res-sourcen noch Mal am Server angefragt und dem Client geliefert. </P
><P 

>Diese Ergebnisse sind schwer zu erkl&auml;ren. Vermutlich braucht es noch etwas Zeit, bis die Im-plementierung des neuen Protokolls von den verschiedenen Browsern richtig interpretiert wird. </P
><H2 

><FONT size="+1">5.10. Angetroffene Schwierigkeiten w&auml;hrend der Testdurchf&uuml;hrung und der Testevaluation </H2
><P 

><FONT size="+1">W&auml;hrend der Testdurchf&uuml;hrung und Testauswertung wurden mehrere Schwierigkeiten getrof-fen. Diese werden hier kurz zusammengefasst. </P
><P 

><I>Funktionsweisen der Browser des &bdquo;Webpagetest.org&ldquo;</I><I> </I><I>&ndash;</I><I> Tool und des lokalen PCs unterscheiden </I><I>sich sehr. </I></P
><P 

>F&uuml;r die Durchf&uuml;hrung der Tests wurde vor allem das online-Tool von &bdquo;Webpagetest.org&ldquo; be-nutzt. Es wurde die Funktionsweise des HTTP/2 &ndash; Protokolls gepr&uuml;ft. Wenn die Webapplikation zur Pr&uuml;fung am lokalen PC aufgerufen wurde, wurde festgestellt, dass die Reihenfolge der Res-sourcen sich von der Reihenfolge der Ressourcen aus dem &bdquo;Webpagetest.org&ldquo; &ndash; Tool unter-scheidet, obwohl die Webapplikation unter gleichen Browserversionen (&bdquo;Mozilla Firefox&ldquo; mit Version 47.0) aufgerufen wurde. Solches Verhalten ist auch beim Browser &bdquo;Google Chrome&ldquo; mit Version 52.0 zu treffen. Wenn der Slider und die dazugeh&ouml;rigen Bilder sp&auml;ter aufgerufen wer-den, werden die Inhalte sp&auml;ter auf dem Viewport angezeigt. Deshalb wird die Webapplikation sp&auml;ter den Parameter &bdquo;Visual Progress&ldquo; 100% erreichen. </P
><P 

>Es wurde gepr&uuml;ft, ob per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen beim zweiten Aufruf der Webapplikation im Browser-Cache landen. Als diese Vorgehensweise am lokalen PC mithilfe des Browsers &bdquo;Mozilla Firefox&ldquo; gepr&uuml;ft wurde, wurde festgestellt, dass alle gepushten Ressour-cen vom Server nochmal aufgerufen werden, w&auml;hrend die anderen Ressourcen im Browser-Cache gelandet sind. Andersrum werden im &bdquo;Webpagetest.org&ldquo; &ndash; Tool beim zweiten Aufruf der Webapplikation keine Dateien mehr geladen. </P
><P 

><I>Fehlende Implementierungen, Bespiele und Evaluationen des HTTP/2 </I><I>&ndash;</I><I> Protokolls unter dem </I><I>Apache Server. </I></P
><P 

>Zu der Zeit, als die Tests durchgef&uuml;hrt wurden, gab es keine offenen Implementierungen und Beispiele zur Anwendung des HTTP/2 &ndash; Protokolls unter dem Apache Server. Es wurden nur wenige ganz konkrete Implementierungen gefunden, die vor allem bei der Anwendung ande-rer Server (&bdquo;Nghttp2&ldquo;, &bdquo;NGINX&ldquo; oder &bdquo;H2O&ldquo;) gemacht wurden.  </P
><P 

>Einer der wenigen Leitf&auml;den f&uuml;r die Serverkonfiguration des verwendeten Servers war die offi-zielle Dokumentation des Apache-Moduls &bdquo;mod_http2&ldquo; ab Version 2.4.17. (Apache Software Foundation 2016a). Leider hat die Anwendung der Einstellungen, die f&uuml;r die Priorisierung der per &bdquo;Server Push&ldquo; &uuml;bergebenen Ressourcen zust&auml;ndig sind, nichts ver&auml;ndert (siehe den Teil: &bdquo;Serverseitige Priorisierung von per &bdquo;Server Push&ldquo; &uuml;bergebenen Ressourcen&ldquo;). Die einzige M&ouml;glichkeit, um die Bandbreite zwischen gepushten Ressourcen zu kontrollieren, ist die Rei-henfolge, in der die Ressourcen im &lt;VirtualHost&gt; per &bdquo;Header&ldquo; aufgelistet sind. </P
><P 

><I>Empfehlungen zu den clientseitigen Performance </I><I>&ndash;</I><I> Optimierungstechniken f&uuml;r das </I><I>HTTP/2 </I><I>&ndash;</I><I> Protokoll stimmen nicht immer mit den praktischen Ergebnissen &uuml;berein. </I></P
><P 

>Die Funktionsweise des HTTP/2 &ndash; Protokolls und m&ouml;gliche Optimierungstechniken unter die-sem Protokoll wurden oftmals allgemein gefasst und nur in der Theorie beschrieben. In der Praxis funktioniert jeder Server auf eigene Art und deshalb kann nicht immer genau gesagt werden, welche Optimierungstechniken sich auf jeden Fall gut eignen. Die gesamte Funktions-weise h&auml;ngt auch von einem konkreten Browser ab und kann sich je nach Version unterschei-den. Z.B. wurde in einem oben durchgef&uuml;hrten Test festgestellt, dass, im Gegensatz zu den theoretischen Erkenntnissen, die Webapplikation langsamer wird, je mehr kleine Dateien unter dem HTTP/2 &ndash; Protokoll vom Server heruntergeladen werden. </P
><P 

><I>Nicht alle der popul&auml;rsten Browser k&ouml;nnen das neue Protokoll korrekt interpretieren. </I></P
><P 

>Wie zuvor durch Tests festgestellt wurde, wird das HTTP/2 &ndash; Protokoll in den popul&auml;rsten Brow-sern sehr unterschiedlich verarbeitet. Der Browser &bdquo;Microsoft IE11&ldquo; interpretiert das neue Pro-tokoll als HTTP/1.1 &ndash; Protokoll mit TLS &ndash; Verschl&uuml;sselung. In den Tests, in denen das HTTP/2 &ndash; Protokoll unter dem Browser &bdquo;Google Chrome&ldquo; getestet wurde, wurde festgestellt, dass es sehr unterschiedlich interpretiert wurde. Die Testergebnisse aus dem &bdquo;Webpagetest.org&ldquo; &ndash; Tool zei-gen, dass das HTTP/2 &ndash; Protokoll nicht richtig verarbeitet wird: es gibt viele Stellen, an denen </P
><P 

>nichts zwischen dem Browser und dem Server gemacht wird. Wenn die Funktionsweise des HTTP/2 &ndash; Protokolls am lokalen PC mit der gleichen Browserversion getestet wurde, wurde festgestellt, dass die Ressourcen im Vergleich zum Browser &bdquo;Mozilla Firefox&ldquo; mehr Zeit brau-chen, um geliefert zu werden. </P
><P 

>Beim &bdquo;Server Push&ldquo;-Test im Browser &bdquo;Google Chrome&ldquo; (Version 52.0), wurde festgestellt, dass diese Funktion von diesem Browser nicht richtig bearbeitet wird. Die Testergebnisse am lokalen PC zeigen, dass alle gepushten Dateien zus&auml;tzlich vom Client angefragt werden, obwohl diese schon nach der HTML Datei an den Client geliefert wurden. Dem Datenmitschnitt aus &bdquo;Wire-shark&ldquo; nach zu urteilen, werden per &bdquo;Server Push&ldquo; &uuml;bergebene Dateien nicht vollst&auml;ndig gelie-fert. Im Browser &bdquo;Mozilla Firefox&ldquo; ist diese Vorgehensweise nicht zu beobachten. </P
><P 

><I>&bdquo;Wireshark&ldquo; versteckt manche &bdquo;Frames&ldquo;, die sich inner</I><I>halb eines TCP </I><I>&ndash;</I><I> Paketes befinden. </I></P
><P 

>Mithilfe von &bdquo;Wireshark&ldquo; kann man alle Frames des HTTP/2 &ndash; Protokolls genauer untersuchen. Der Filter &bdquo;http2&ldquo; zeigt die gesamte Kommunikation zwischen Client und Server (siehe Abb. 59). In der letzten Spalte des oberen Bereichs (&bdquo;Info&ldquo;) sieht man, welche Frames in einem TCP &ndash; Pa-ket zusammengefasst wurden. Allerdings kann man manchmal Situationen treffen, in denen nicht alle &uuml;bertragenen &bdquo;Frames&ldquo; in dieser Spalte angezeigt werden. Abb. 59 veranschaulicht, dass zuerst HEADERS- und DATA &ndash; Frames des 20. &ldquo;Streams&ldquo; vom Server geliefert werden. Im gleichen TCP &ndash; Paket wird aber nachher noch ein HEADERS &ndash; Frame des 22.-&ldquo;Streams&ldquo; geliefert. Dieser ist aber nicht in der Spalte &bdquo;Info&ldquo; mit den anderen &bdquo;Frames&ldquo; zu sehen. Deshalb ist es manchmal etwas schwierig, um einzelne &bdquo;Frames&ldquo; zu verfolgen. Aber mithilfe von Filtern kann man immer nach einzelnen &bdquo;Streams&ldquo; und dazugeh&ouml;rigen &bdquo;Frames&ldquo; suchen. </P
><P 

> </P
><IMG width="553" height="267"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_59.jpg" ><DL 

><DD 

><I>Abb. 59:</I><I> </I><I>Screenshot aus &bdquo;Wireshark&ldquo;: Datenmitschnitt des HTTP/2 &ndash;</I><I>Protokolls.  </I></DD
></DL
><H1 

><FONT size="+1">6. Fazit und Ausblick </H1
><P 

><FONT size="+1">Abschlie&szlig;end sollen noch einmal die wichtigsten Schritte, Aussagen und Schlussfolgerungen zusammengefasst werden. </P
><P 

>Innerhalb dieser Masterarbeit wurden haupts&auml;chlich drei Ziele verfolgt: </P
><DL 

><DD 

>&#61630; Untersuchung der Ladezeit der Webapplikation mithilfe der Funktion des HTTP/2 &ndash; Pro-tokolls &bdquo;Server Push&ldquo; unter unterschiedlichen Eins&auml;tzen. Besonders geachtet wurde da-bei auf clientseitige Frontend Performance &ndash; Optimierungstechniken. </DD
><DD 

>&#61630; Allgemeine Untersuchung der Ladezeit der Webapplikation unter dem HTTP/1.1- und dem HTTP/2 &ndash; Protokoll, wenn die Webapplikation gesondert f&uuml;r jede Version des HTTP &ndash; Protokolls optimiert wurde. </DD
><DD 

>&#61630; Auseinandersetzung mit der Konfiguration des Webservers f&uuml;r das HTTP/2 &ndash; Protokoll im Hinblick auf den &bdquo;Server Push&ldquo; und mit den wichtigsten Schritten und Parametern des Ladezeitprozesses.  </DD
></DL
><P 

>Alle Schritte zum Erreichen der gestellten Ziele wurden abgeschlossen. Im theoretischen Teil dieser Masterarbeit hat sich herausgestellt, dass im Vergleich zum HTTP/1.1 &ndash; Protokoll das HTTP/2 &ndash; Protokoll die Inhalte der Webapplikationen schneller, effizienter und ohne zus&auml;tzli-che Latenz &uuml;bertragen soll. Es wurden bestimmte clientseitige Techniken zur Perfor-mance &ndash; Optimierung f&uuml;r beide Protokolle definiert. </P
><P 

>Nach diesem Schritt wurden bestimmte Parameter des kritischen Rendering &ndash; Pfades ausge-w&auml;hlt und mit Tools zur Messung der Performance (&bdquo;Webpagetest.org&ldquo;) und zur Netzwerkana-lyse (&bdquo;Wireshark&ldquo;) untersucht. </P
><P 

>Es gab drei wesentliche Eins&auml;tze f&uuml;r die Testausf&uuml;hrung. Zuerst wurde untersucht, wie unter dem HTTP/2 &ndash; Protokoll die Funktion &bdquo;Server Push&ldquo; funktioniert. Gepushte Ressourcen errei-chen den Client genau in der Reihenfolge, wie diese auf den serverseitigen Einstellungen auf-gelistet sind. Allerdings wurde festgestellt, dass per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen nicht priorisiert werden, auch wenn Priorisierungen f&uuml;r einzelne Ressourcentypen serverseitig eingestellt wurden. Deshalb kann festgestellt werden, dass innerhalb der ausgew&auml;hlten server- und clientseitigen Bedingungen die Eigenschaft der Priorisierungen von gepushten Ressourcen funktionsunf&auml;hig ist.  </P
><P 

>Au&szlig;erdem wurde gepr&uuml;ft, ob gepushte Ressourcen nach dem ersten Aufruf im Browser Cache landen werden. Es wurde festgestellt, wenn die Ressourcen vom lokalen PC aufgerufen werden, werden diese bei den weiteren Aufrufen immer wieder geladen (siehe Unterkapitel &bdquo;Wie funk-tioniert &rsquo;Server Push&rsquo;? &ldquo;). Dies bedeutet, dass das Browsercaching f&uuml;r gepushte Ressourcen nicht funktioniert. Dies wiederspricht den theoretischen Erkenntnissen (siehe Unterkapitel &bdquo;3.3 Vorstellung des HTTP/2 &ndash; Protokolls&ldquo;). Allerdings unterscheiden sich die Ergebnisse aus </P
><P 

>dem &bdquo;Webpagetest.org&ldquo; &ndash; Tool, in dem beim zweiten Aufruf per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen im Browser Cache landen. </P
><P 

>Danach wurde der &bdquo;Server Push&ldquo; in Bezug auf den kritischen Rendering &ndash; Pfad untersucht. Es wurde besonders auf fr&uuml;her gew&auml;hlte Metriken w&auml;hrend der Ladezeit geachtet und es wurden Einsatzm&ouml;glichkeiten gesucht, die f&uuml;r den kritischen Rendering &ndash; Pfad vorteilhaft sind. Es wurde festgestellt, dass sich der &bdquo;Server Push&ldquo; &ndash; Einsatz f&uuml;r alle f&uuml;r die Erstdarstellung kritische Ressourcen gut eignet. Auch wenn nicht &ndash; kritische, aber aus der Nutzersicht wichtige Ressour-cen (Webschriften oder Bilder) gepusht werden, k&ouml;nnen auch gute Ergebnisse entstehen. Al-lerdings muss aufgepasst werden, dass die nicht &ndash; kritischen Ressourcen keine wichtigen CSS Dateien blockieren werden und dass nicht zu viele Ressourcen gepusht werden (siehe Unter-kapitel &bdquo;5.5 Untersuchungen zum &lsquo;Server Push&rsquo; &ldquo;). Sonst kehrt das &bdquo;Header-Of-Line Blo-cking&ldquo; &ndash; Problem zur&uuml;ck. Die Ausnahmen sind unkritische JavaScript &ndash; Dateien, die zus&auml;tzlich wegen deren sofortigen Ausf&uuml;hrung alle anderen Ressourcen blockieren werden.<FONT color="#FF0000"> </P
><P 

><FONT color="#000000">Danach wurde die allgemeine Ladezeit der Webapplikation unter dem unverschl&uuml;sselten HTTP/1.1- und dem HTTP/2 &ndash; Protokoll verglichen. Obwohl die Zeit zur Netzwerkverbindung unter dem HTTP/2 &ndash; Protokoll kleiner oder fast gleich als unter dem HTTP/1.1 &ndash; Protokoll war, wurde die Ladezeit unter der neueren Version des HTTP &ndash; Protokolls deutlich langsamer. Unter mobilen Netzwerken waren die Unterschiede besonders gro&szlig;. In der Einleitung dieser Master-arbeit wurde erw&auml;hnt, dass etwa 80-90% der gesamten Geschwindigkeit der Webapplikation am Frontend liegt (Rigor, Inc. 2016). Wie die Testergebnisse gezeigt haben, gen&uuml;gen f&uuml;r die Erstellung einer perfomanten Webapplikationen die clientseitigen Performance &ndash; Optimie-rungstechniken f&uuml;r das HTTP/2 &ndash; Protokoll nicht. Um performante Webapplikationen unter dem neuen Protokoll zu erreichen, muss noch das TCP &ndash; Protokoll beachtet werden, weil nur eine TCP &ndash; Verbindung zwischen Client und Server existiert. Dazu m&uuml;ssen der Traffic, die Rei-henfolge von TCP &ndash; Paketen und deren Inhalte genau beobachtet werden.<FONT color="#FF0000"> </P
><P 

><FONT color="#000000">In einem weiteren Test wurde untersucht, ob die Aufteilung der Ressourcen unter dem HTTP/2 &ndash; Protokoll eine Rolle spielt. Im theoretischen Kapitel wurde festgestellt, dass dank der Multiplexierung von Requests und Responses innerhalb der bestehenden TCP &ndash; Verbindung die Ressourcen nicht zusammengefasst werden m&uuml;ssen, wie es f&uuml;r das HTTP/1.1 &ndash; Protokoll gemacht wird (Grigorik 2013, 243), (NGINX, Inc. 2015, 5). Allerdings wurde dabei festgestellt, sollten Ressourcen nicht zusammengefasst werden, wird die Ladezeit der Webapplikation deutlich verlangsamt. Dies wiederspricht den theoretischen Erkenntnissen (siehe Unterkapitel &bdquo;3.4 M&ouml;gliche Optimierungstechniken f&uuml;r das HTTP/2 &ndash; Protokoll&ldquo;). <FONT color="#FF0000"> </P
><P 

><FONT color="#000000">Im n&auml;chsten Test wurde untersucht, wie das neue Protokoll in unterschiedlichen Browsern funk-tioniert. Es wurden die drei meist verwendeten Browser genommen: &bdquo;Mozilla Firefox&ldquo;, &bdquo;Google Chrome&ldquo; und &bdquo;Microsoft IE 11&ldquo;. Tests wurden sowohl am lokalen PC als auch mit dem &bdquo;Web-</P
><P 

>pagetest.org&ldquo; &ndash; Tool gemacht. Es hat sich herausgestellt, dass sich die Testergebnisse stark un-terscheiden. Im Browser &bdquo;Google Chrome&ldquo; innerhalb des &bdquo;Webpagetest.org&ldquo; &ndash; Tools wurde die Webapplikation im Vergleich zum Browser &bdquo;Mozilla Firefox&ldquo; sehr langsam geladen. Die Gr&uuml;nde daf&uuml;r bleiben ungekl&auml;rt. Wenn die Ladezeit zwischen diesen Webbrowsern am lokalen PC ver-glichen wurde, wurde festgestellt, dass unter dem Browser &bdquo;Mozilla Firefox&ldquo; die Webapplikation schneller geladen wird. Im Browser &bdquo;Microsoft IE 11&ldquo; wird die Kommunikation zwischen dem Client und dem Server immer unter dem HTTP/1 &ndash; Protokoll laufen. </P
><P 

>Im letzten Test wurde geschaut, wie der Browser &bdquo;Google Chrome&ldquo; per &bdquo;Server Push&ldquo; &uuml;berge-bene Ressourcen bearbeitet. Tests wurden sowohl am lokalen PC als auch mit dem &bdquo;Webpa-getest.org&ldquo; &ndash; Tool gemacht. Es hat sich herausgestellt, dass sowohl im Browser &bdquo;Google Chrome&ldquo; als auch im Browser &bdquo;Mozilla Firefox&ldquo; innerhalb des &bdquo;Webpagetest.org&ldquo; &ndash; Tools ge-pushte Ressourcen akzeptiert werden. Wenn die Webapplikation am lokalen PC im Browser &bdquo;Google Chrome&ldquo; aufgerufen wurde, wurde festgestellt, dass per &bdquo;Server Push&ldquo; &uuml;bergebene Ressourcen nicht vollst&auml;ndig den Client erreichen und neu angefragt und geladen wurden. Dies spricht daf&uuml;r, dass der &bdquo;Server Push&ldquo; des gew&auml;hlten Servers im Browser &bdquo;Google Chrome&ldquo; nicht vollst&auml;ndig funktioniert. </P
><P 

>Man muss beachten, dass oben genannte Aussagen und Testergebnisse sich auf eine konkrete Testumgebung (Apache Server der Version 2.4.20 und drei Browser mit konkreten Versionen) beziehen. Mit jedem Release sowohl des Webservers als auch des Browsers k&ouml;nnen sich oben genannte Ergebnisse &auml;ndern. </P
><P 

>Obwohl das offizielle Datum der Ver&ouml;ffentlichung des HTTP/2 &ndash; Protokolls schon &uuml;ber ein Jahr zur&uuml;ck liegt, ist zu beobachten, dass bisher nicht viele Tests und Experimente durchgef&uuml;hrt und &ouml;ffentlich gemacht wurden. Zum aktuellen Stand dieses Protokolls kann man sagen, dass es sowohl server- als auch clientseitig nicht perfekt funktioniert und manche der erzielten Ergeb-nisse unerwartet waren und teilweise unerkl&auml;rt geblieben sind. Deshalb konnten im Rahmen dieser Masterarbeit nicht alle am Anfang definierten Tests komplett durchgef&uuml;hrt werden, da manche Funktionen nicht korrekt implementiert waren. Au&szlig;erdem unterscheidet sich das Ver-halten des neuen Protokolls zwischen unterschiedlichen Browsern sehr. </P
><P 

>F&uuml;r die zuk&uuml;nftige Entwicklung des HTTP/2 &ndash; Protokolls ist es auf jeden Fall empfehlenswert, das neue Protokoll unter anderen Bedingungen (andere Server und unterschiedliche Browser) immer weiter zu testen. </P
><P 

>Die Verfasserin dieser Masterarbeit schl&auml;gt vor, bei weiteren Untersuchungen zu optimalen Bedingungen f&uuml;r clientseitige Techniken zur Performance &ndash; Optimierung auf allgemeine Aus-sagen zu verzichten und stattdessen f&uuml;r die spezifische Umgebung individuelle Tests durchzu-f&uuml;hren. Denn innerhalb dieser Masterarbeit konnte z.B. gezeigt werden, dass nicht zusammen-gefasste Ressourcen langsamer heruntergeladen werden, obwohl dies laut den allgemeinen Aussagen nicht zu erwarten gewesen w&auml;re.  </P
><H1 

><FONT size="+1">7. Literaturverzeichnis </H1
><P 

><FONT size="+1">Apache Software Foundation 2016a </P
><P 

>Apache Software Foundation, Apache Module mod_http2. &lt;<A href="https://httpd.apache.org/docs/2.4/mod/mod_http2.html">
<FONT color="#0462C1">https://httpd.apache.org/docs/2.4/mod/mod_http2.html</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

><FONT color="#0462C1"> </P
><P 

><FONT color="#000000">Apache Software Foundation 2016b  </P
><P 

>Changes with Apache. &lt;<A href="https://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x/CHANGES">
<FONT color="#0462C1">https://svn.apache.org/re-pos/asf/httpd/httpd/branches/2.4.x/CHANGES</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Apple 2016 </P
><P 

>Apple, Web Development Tools. 2016. &lt;<A href="https://developer.apple.com/safari/tools/">
<FONT color="#0462C1">https://developer.apple.com/safari/tools/</A>
<FONT color="#000000">&gt; (24. Sep-tember 2016). </P
><P 

> </P
><P 

>Behnke 2013 </P
><P 

>M. Behnke, Mime Types for Fonts and Media. 2013. &lt;<A href="https://gist.github.com/localpcguy/6002288">
<FONT color="#0462C1">https://gist.github.com/lo-calpcguy/6002288</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Belshe et al. 2015  </P
><P 

>M. Belshe/R. Peon/ M. Thomson, Hypertext Transfer Protocol Version 2 (HTTP/2). 2015. &lt;<A href="https://tools.ietf.org/pdf/rfc7540.pdf">
<FONT color="#0462C1">https://tools.ietf.org/pdf/rfc7540.pdf</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>CloudFlare 2016  </P
><P 

>CloudFlare, Tools for debugging, testing and using HTTP/2. 2016. &lt;<A href="https://blog.cloudflare.com/tools-for-debugging-testing-and-using-http-2/">
<FONT color="#0462C1">https://blog.cloud-flare.com/tools-for-debugging-testing-and-using-http-2/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>DeNA Co., Ltd. 2015 </P
><P 

>DeNA Co., Ltd., H2O. 2015. &lt;<A href="https://h2o.examp1e.net/">
<FONT color="#0462C1">https://h2o.examp1e.net/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Duran 2016 </P
><P 

>E. Duran, chromeHAR. 2016. &lt;<A href="https://ericduran.github.io/chromeHAR/">
<FONT color="#0462C1">https://ericduran.github.io/chromeHAR/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Duca/Glazkov 2016 </P
><P 

>N. Duca/D. Glazkov, Platform Success Model Explainer. 2016. &lt;<A href="https://docs.google.com/document/d/1bYMyE6NdiAupuwl7pWQfB-vOZBPSsXCv57hljLDMV8E/edit#heading=h.116kzlmx4qct">
<FONT color="#0462C1">https://docs.google.com/doc-ument/d/1bYMyE6NdiAupuwl7pWQfB-vOZBPSsXCv57hljLDMV8E/edit#head-ing=h.116kzlmx4qct</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>  </P
><P 

>DistroWatch 2016  </P
><P 

>DistroWatch, DistroWatch Page Hit Ranking. 2016. &lt;<A href="https://distrowatch.com/dwres.php?resource=popularity">
<FONT color="#0462C1">https://distrowatch.com/dwres.php?re-source=popularity</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Equation Research 2011 </P
><P 

>Equation Research, What users want from mobile. 2011. &lt;<A href="http://www.slideshare.net/RFONNIER/what-users-want-from-mobile-equation-research-july-2011">
<FONT color="#0462C1">http://www.slideshare.net/RFON-NIER/what-users-want-from-mobile-equation-research-july-2011</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Eissing 2015 </P
><P 

>S. Eissing, how to h2 in apache. 2016. &lt;<A href="https://icing.github.io/mod_h2/howto.html">
<FONT color="#0462C1">https://icing.github.io/mod_h2/howto.html</A>
<FONT color="#000000">&gt; (24. Sep-tember 2016). </P
><P 

> </P
><P 

>Fractal 2016 </P
><P 

>Fractal, Gulpjs. 2016. &lt;<A href="http://gulpjs.com/">
<FONT color="#0462C1">http://gulpjs.com/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Fielding et al. 1999 </P
><P 

>R. Fielding/J. Gettys/J. Mogul/H. Frystyk/L. Masinter/P. Leach/T. Berners-Lee, Hypertext Trans-fer Protocol - HTTP/1.1. 1999. &lt;<A href="https://www.ietf.org/rfc/rfc2616.txt">
<FONT color="#0462C1">https://www.ietf.org/rfc/rfc2616.txt</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Garbee 2016  </P
><P 

>J. Garbee, Understanding Resource Timing. 2016. &lt;<A href="https://developers.google.com/web/tools/chrome-devtools/profile/network-performance/understanding-resource-timing">
<FONT color="#0462C1">https://develop-ers.google.com/web/tools/chrome-devtools/profile/network-performance/understanding-resource-timing</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Grigorik 2012 </P
><P 

>I. Grigorik, Deciphering the Critical Rendering Path. 2012. &lt;<A href="http://calendar.perfplanet.com/2012/deciphering-the-critical-rendering-path/">
<FONT color="#0462C1">http://calen-dar.perfplanet.com/2012/deciphering-the-critical-rendering-path/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Grigorik 2013 </P
><P 

>I. Grigorik, High Performance Browser Networking. Sebastopol 2003. </P
><P 

> </P
><P 

>Grigorik 2015 </P
><P 

>I. Grigorik, HTTP/2. A New Excerption from High Performance Browser Networking. Sebasto-pol, 2015. </P
><P 

> </P
><P 

>Grigorik 2016a  </P
><P 

>I. Grigorik, Measuring the critical rendering path with Navigation Timing. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp?hl=en">
<FONT color="#0462C1">https://de-velopers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

>Grigorik 2016b </P
><P 

>I. Grigorik, Bildoptimierung. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/image-optimization#checkliste-zur-bildoptimierung">
<FONT color="#0462C1">https://developers.google.com/web/fundamentals/per-formance/optimizing-content-efficiency/image-optimization</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Grigorik 2016c </P
><P 

>I. Grigorik, Constructing the Object Model. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=en">
<FONT color="#0462C1">https://developers.google.com/web/fun-damentals/performance/critical-rendering-path/constructing-the-object-model?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Grigorik 2016d </P
><P 

>I. Grigorik, Render-tree construction, layout, and paint. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=en">
<FONT color="#0462C1">https://develop-ers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-con-struction?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Grigorik 2016e </P
><P 

>I. Grigorik, Render blocking CSS. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-blocking-css?hl=en">
<FONT color="#0462C1">https://developers.google.com/web/fundamen-tals/performance/critical-rendering-path/render-blocking-css?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

>  </P
><P 

>Grigorik 2016f  </P
><P 

>I. Grigorik, Adding interactivity with JavaScript. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript?hl=en">
<FONT color="#0462C1">https://develop-ers.google.com/web/fundamentals/performance/critical-rendering-path/adding-interactivity-with-javascript?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016).<FONT color="#0462C1"> </P
><P 

><FONT color="#000000"> </P
><P 

>Grigorik 2016g  </P
><P 

>I. Grigorik, Critical rendering path. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/?hl=en">
<FONT color="#0462C1">https://developers.google.com/web/fundamen-tals/performance/critical-rendering-path/?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Grigorik 2016h  </P
><P 

>I. Grigorik, Analyzing critical rendering path performance. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp?hl=en">
<FONT color="#0462C1">https://develop-ers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Grigorik 2016i </P
><P 

>I. Grigorik, Web font optimization. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/optimizing-content-efficiency/webfont-optimization?hl=en#optimizing-loading-and-rendering">
<FONT color="#0462C1">https://developers.google.com/web/fundamen-tals/performance/optimizing-content-efficiency/webfont-optimization?hl=en#optimizing-loading-and-rendering</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>  </P
><P 

>Grunt Development Team 2016 </P
><P 

>Grunt Development Team, Grunt. 2016. &lt;<A href="http://gruntjs.com/">
<FONT color="#0462C1">http://gruntjs.com/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Holtkamp 2001 </P
><P 

>H. Holtkamp, TCP/IP im Detail. 2001. &lt;<A href="http://www.rvs.uni-bielefeld.de/~heiko/tcpip/tcpip_html_alt/kap_2_4.html">
<FONT color="#0462C1">http://www.rvs.uni-biele-feld.de/~heiko/tcpip/tcpip_html_alt/kap_2_4.html</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Hemming 2016 </P
><P 

>T. Hemming, HTTP Archive Viewer. 2016. &lt;<A href="https://chrome.google.com/webstore/detail/http-archive-viewer/ebbdbdmhegaoooipfnjikefdpeoaidml?hl=de">
<FONT color="#0462C1">https://chrome.google.com/webstore/detail/http-archive-viewer/ebbdbdmhegaoooipfnjikefdpeoaidml?hl=de</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Ishizawa 2015 </P
><P 

>M. Ishizawa, Understanding HTTP/2 prioritization. 2015. &lt;<A href="https://speakerdeck.com/summerwind/2-prioritization">
<FONT color="#0462C1">https://speakerdeck.com/summer-wind/2-prioritization</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

> </P
><P 

>Jayaprakash 2016 </P
><P 

>A. Jayaprakash, Are you ready for HTTP/2 Server Push. 2016?! &lt;<A href="https://blogs.akamai.com/2016/04/are-you-ready-for-http2-server-push.html">
<FONT color="#0462C1">https://blogs.aka-mai.com/2016/04/are-you-ready-for-http2-server-push.html</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Krasnov 2016 </P
><P 

>V. Krasnov, Announcing Support for HTTP/2 Server Push. 2016. &lt;<A href="https://blog.cloudflare.com/announcing-support-for-http-2-server-push-2/">
<FONT color="#0462C1">https://blog.cloud-flare.com/announcing-support-for-http-2-server-push-2/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Kuhn/Raith 2013 </P
><P 

>D. Kuhn, M. Raith, Performante Webanwendungen. Client- und serverseitige Techniken zur Performance-Optimierung. Heidelberg 2013. </P
><P 

> </P
><P 

>Lewis 2016 </P
><P 

>P. Lewis, Rendering performance. 2016. &lt;<A href="https://developers.google.com/web/fundamentals/performance/rendering/?hl=en">
<FONT color="#0462C1">https://developers.google.com/web/fundamen-tals/performance/rendering/?hl=en</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Lighttpd 2016 </P
><P 

>Lighttpd. 2016. &lt;<A href="https://www.lighttpd.net/">
<FONT color="#0462C1">https://www.lighttpd.net/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>McLachlan 2013 </P
><P 

>P. McLachlan, On Mobile, Data URIs are 6x Slower than Source Linking (New Research). 2013. &lt;<A href="http://www.mobify.com/blog/data-uris-are-slow-on-mobile/">
<FONT color="#0462C1">http://www.mobify.com/blog/data-uris-are-slow-on-mobile/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Medienmaster.de 2016  </P
><P 

>Medienmaster.de, Medienmaster.de. 2016. &lt;<A href="http://www.medienmaster.de/">
<FONT color="#0462C1">http://www.medienmaster.de/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Microsoft 2016 </P
><P 

>Microsoft, Analysieren des Netzwerkdatenverkehrs einer Webseite. 2016. &lt;<A href="https://msdn.microsoft.com/de-de/library/dn255004(v=vs.85).aspx">
<FONT color="#0462C1">https://msdn.microsoft.com/de-de/library/dn255004(v=vs.85).aspx</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Mishunov 2015 </P
><P 

>D. Mishunov, Why Performance Matters, Part 1: The Perception Of Time. 2015. &lt;<A href="https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/">
<FONT color="#0462C1">https://www.smashingmagazine.com/2015/09/why-performance-matters-the-perception-of-time/</A>
<FONT color="#000000">&gt; (24. September 2016).<FONT color="#0462C1"> </P
><P 

><FONT color="#000000"> </P
><P 

>Mifsud 2016 </P
><P 

>M. Mifsud, Real&ndash;world HTTP/2: 400gb of images per day. 2016. &lt;<A href="https://99designs.de/tech-blog/blog/2016/07/14/real-world-http-2-400gb-of-images-per-day/">
<FONT color="#0462C1">https://99designs.de/tech-blog/blog/2016/07/14/real-world-http-2-400gb-of-images-per-day/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016a </P
><P 

>Mozilla Developer Network and individual contributors, &lt;script&gt;. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script">
<FONT color="#0462C1">https://devel-oper.mozilla.org/en-US/docs/Web/HTML/Element/script</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016b  </P
><P 

>Mozilla Developer Network and individual contributors, Navigation Timing API. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API">
<FONT color="#0462C1">https://developer.mozilla.org/en-US/docs/Web/API/Navigation_timing_API</A>
<FONT color="#000000">&gt; (24. Septem-ber 2016). </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016c </P
><P 

>Mozilla Developer Network and individual contributors, PerformanceTiming. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming">
<FONT color="#0462C1">https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016d </P
><P 

>Mozilla Developer Network and individual contributors, Document.readyState. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState">
<FONT color="#0462C1">https://developer.mozilla.org/en-US/docs/Web/API/Document/readyState</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

> </P
><P 

> </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016e  </P
><P 

>Mozilla Developer Network and individual contributors, DOMContentLoaded. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded">
<FONT color="#0462C1">https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded</A>
<FONT color="#000000">&gt; (24. Septem-ber 2016). </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016f  </P
><P 

>Mozilla Developer Network and individual contributors, load. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Web/Events/load">
<FONT color="#0462C1">https://devel-oper.mozilla.org/en-US/docs/Web/Events/load</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016g   </P
><P 

>Mozilla Developer Network and individual contributors, What are browser developer tools. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_are_browser_developer_tools">
<FONT color="#0462C1">https://developer.mozilla.org/en-US/docs/Learn/Common_ques-tions/What_are_browser_developer_tools</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016h </P
><P 

>Mozilla Developer Network and individual contributors, Using the Resource Timing API. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API/Using_the_Resource_Timing_API">
<FONT color="#0462C1">https://developer.mozilla.org/en-US/docs/Web/API/Resource_Timing_API/Using_the_Re-source_Timing_API</A>
<FONT color="#000000">&gt; </P
><P 

> </P
><P 

>Mozilla Developer Network and individual contributors 2016i </P
><P 

>Mozilla Developer Network and individual contributors, Network Monitor. 2016. &lt;<A href="https://developer.mozilla.org/en-US/docs/Tools/Network_Monitor">
<FONT color="#0462C1">https://de-veloper.mozilla.org/en-US/docs/Tools/Network_Monitor</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>NGINX, Inc. 2015 </P
><P 

>NGINX, HTTP/2 for Web Application Developers. 2015. &lt;<A href="https://assets.wp.nginx.com/wp-content/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf">
<FONT color="#0462C1">https://assets.wp.nginx.com/wp-con-tent/uploads/2015/09/NGINX_HTTP2_White_Paper_v4.pdf</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>NGINX, Inc. 2016 </P
><P 

>NGINX, NGINX. 2016. &lt;<A href="https://nginx.org/en/">
<FONT color="#0462C1">https://nginx.org/en/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

>OpenSignal 2016a  </P
><P 

>OpenSignal, Telekom Netzabdeckungskarten. 2016. &lt;<A href="http://opensignal.com/networks/deutschland/telekom-Berichterstattung">
<FONT color="#0462C1">http://opensignal.com/net-works/deutschland/telekom-Berichterstattung</A>
<FONT color="#000000">&gt; (24. September 2016).<FONT color="#0462C1"> </P
><P 

> </P
><P 

><FONT color="#000000">OpenSignal 2016b  </P
><P 

>OpenSignal, Vodafone Netzabdeckungskarten. 2016. &lt;<A href="http://opensignal.com/networks/deutschland/vodafone-Berichterstattung">
<FONT color="#0462C1">http://opensignal.com/net-works/deutschland/vodafone-Berichterstattung</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

><FONT color="#0462C1"> </P
><P 

><FONT color="#000000">  </P
><P 

>OpenSignal 2016c  </P
><P 

>OpenSignal, E-Plus Netzabdeckungskarten. 2016. &lt;<A href="http://opensignal.com/networks/deutschland/e-plus-Berichterstattung">
<FONT color="#0462C1">http://opensignal.com/networks/deutsch-land/e-plus-Berichterstattung</A>
&gt; <FONT color="#000000">(24. September 2016).<FONT color="#0462C1"> </P
><P 

> </P
><P 

><FONT color="#000000">OpenSignal 2016d </P
><P 

>OpenSignal, O2 Netzabdeckungskarten. 2016. &lt;<A href="http://opensignal.com/networks/deutschland/o2-Berichterstattung">
<FONT color="#0462C1">http://opensignal.com/networks/deutsch-land/o2-Berichterstattung</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>OPERA SOFTWARE ASA 2016 </P
><P 

>OPERA SOFTWARE ASA, Opera Dragonfly documentation. 2016. &lt;<A href="http://www.opera.com/dragonfly/documentation/network/">
<FONT color="#0462C1">http://www.opera.com/dragonfly/documentation/network/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Peon/Ruellan 2015 </P
><P 

>R. Peon/H. Ruellan, HPACK: Header Compression for HTTP/2. 2015. &lt;<A href="https://tools.ietf.org/pdf/rfc7541.pdf">
<FONT color="#0462C1">https://tools.ietf.org/pdf/rfc7541.pdf</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Red Hat, Inc. and others 2015  </P
><P 

>Red Hat, Inc. and others, Fedora. 2015. &lt;<A href="https://getfedora.org/">
<FONT color="#0462C1">https://getfedora.org/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Rigor, Inc. 2016 </P
><P 

>Rigor, Inc., The Case for Fast Web Performance. 2016. &lt;<A href="https://zoompf.com/business-case">
<FONT color="#0462C1">https://zoompf.com/business-case</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Ross 2016 </P
><P 

>D. Ross, HTTP/2 Server Push. 2016. &lt;<A href="https://srd.wordpress.org/plugins/http2-server-push/">
<FONT color="#0462C1">https://srd.wordpress.org/plugins/http2-server-push/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>RStudio 2016 </P
><P 

>RStudio, RStudio. 2016. &lt;<A href="https://www.rstudio.com/home/">
<FONT color="#0462C1">https://www.rstudio.com/home/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

>Sexton 2015  </P
><P 

>P. Sexton, Critical rendering path. 2015. &lt;<A href="https://varvy.com/pagespeed/critical-render-path.html">
<FONT color="#0462C1">https://varvy.com/pagespeed/critical-render-path.html</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Shaver 2015 </P
><P 

>J. Shaver. Decrypting TLS Browser Traffic With Wireshark &ndash; The Easy Way. 2016. &lt;<A href="https://jimshaver.net/2015/02/11/decrypting-tls-browser-traffic-with-wireshark-the-easy-way/">
<FONT color="#0462C1">https://jimshaver.net/2015/02/11/decrypting-tls-browser-traffic-with-wireshark-the-easy-way/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>  </P
><P 

>Souders 2010 </P
><P 

>S. Sounders, Browser Performance Wishlist. 2010. &lt;<A href="http://www.stevesouders.com/blog/2010/02/15/browser-performance-wishlist/">
<FONT color="#0462C1">http://www.stevesoud-ers.com/blog/2010/02/15/browser-performance-wishlist/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>StatCounter 2016 </P
><P 

>StatCounter, StatCounter Global Stats. 2016. &lt;<A href="http://gs.statcounter.com/#desktop-browser_version_partially_combined-ww-monthly-201507-201607-ba">
<FONT color="#0462C1">http://gs.statcounter.com/#desktop-browser_version_partially_combined-ww-monthly-201507-201607-ba</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Suse 2013  </P
><P 

>Suse, Administration Guide. 2013. &lt;<A href="https://www.suse.com/documentation/sles11/book_sle_admin/data/sec_apache2_configuration.html">
<FONT color="#0462C1">https://www.suse.com/documenta-tion/sles11/book_sle_admin/data/sec_apache2_configuration.html</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>SUSE LLC 2015 </P
><P 

>SUSE LLC, openSUSE. 2015. &lt;<A href="https://www.opensuse.org/">
<FONT color="#0462C1">https://www.opensuse.org/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>The jQuery Foundation 2016a </P
><P 

>The jQuery Foundation, Using jQuery Core. 2016. &lt;<A href="https://learn.jquery.com/using-jquery-core/document-ready/">
<FONT color="#0462C1">https://learn.jquery.com/using-jquery-core/document-ready/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>The jQuery Foundation 2016b  </P
><P 

>The jQuery Foundation, Ready. 2016. &lt;<A href="https://api.jquery.com/ready/">
<FONT color="#0462C1">https://api.jquery.com/ready/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>The R Foundation 2016 </P
><P 

>The R Foundation, The R Project for Statistical Computing. 2016. &lt;<A href="https://www.r-project.org/">
<FONT color="#0462C1">https://www.r-pro-ject.org/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

><FONT color="#0462C1"> </P
><P 

><FONT color="#000000">Thomson/Nottingham 2016  </P
><P 

>M. Thomson/M. Nottingham, Implementations. 2016. &lt;<A href="https://github.com/http2/http2-spec/wiki/Implementations">
<FONT color="#0462C1">https://github.com/http2/http2-spec/wiki/Implementations</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Tsujikawa 2016  </P
><P 

>T. Tsujikawa, Nghttp2: HTTP/2 C Library. 2016. &lt;<A href="https://nghttp2.org/">
<FONT color="#0462C1">https://nghttp2.org/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Viscomi et al. 2014 </P
><P 

>R. Viscomi/A. Davies/M. Duran, Using WebPagetest. Sebastopol, 2014. </P
><P 

> </P
><P 

>WebPagetest 2016a </P
><P 

>WebPagetest, WebPagetest. 2016. &lt;<A href="https://www.webpagetest.org/">
<FONT color="#0462C1">https://www.webpagetest.org/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>WebPagetest 2016b </P
><P 

>WebPagetest, WebPagetest Documentation. 2016. &lt;<A href="https://sites.google.com/a/webpagetest.org/docs/">
<FONT color="#0462C1">https://sites.google.com/a/webpagetest.org/docs/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Wickham 2013<FONT color="#0462C1"> </P
><P 

><FONT color="#000000">H. Wickham. Ggplot2. 2013. &lt;<A href="http://ggplot2.org/">
<FONT color="#0462C1">http://ggplot2.org/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Wikipedia 2016a  </P
><P 

>Wikipedia, Boxplot. 2016 &lt;<A href="https://de.wikipedia.org/wiki/Boxplot">
<FONT color="#0462C1">https://de.wikipedia.org/wiki/Boxplot</A>
&gt;<FONT color="#000000"> (24. September 2016).<FONT color="#0462C1"> </P
><P 

> </P
><P 

><FONT color="#000000">Wikipedia 2016b </P
><P 

>Wikipedia, Man-in-the-Middle-Angriff. 2016. &lt;<A href="https://de.wikipedia.org/wiki/Man-in-the-Middle-Angriff">
<FONT color="#0462C1">https://de.wikipedia.org/wiki/Man-in-the-Mid-dle-Angriff</A>
<FONT color="#000000">&gt; (24. September 2016).<FONT color="#0462C1"> </P
><P 

><FONT color="#000000"> </P
><P 

>Wikipedia 2016c </P
><P 

>Wikipedia, HTTP pipelining. 2016. &lt;<A href="https://en.wikipedia.org/wiki/HTTP_pipelining">
<FONT color="#0462C1">https://en.wikipedia.org/wiki/HTTP_pipelining</A>
<FONT color="#000000">&gt; (24. Sep-tember 2016). </P
><P 

> </P
><P 

>Wikipedia 2016d </P
><P 

>Wikipedia, TCP congestion control. 2016. &lt;<A href="https://en.wikipedia.org/wiki/TCP_congestion_control">
<FONT color="#0462C1">https://en.wikipedia.org/wiki/TCP_conges-tion_control</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

>Wikipedia 2016e </P
><P 

>Wikipedia, Data-URL. 2016. &lt;<A href="https://de.wikipedia.org/wiki/Data-URL">
<FONT color="#0462C1">https://de.wikipedia.org/wiki/Data-URL</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Wikipedia 2016f </P
><P 

>Wikipedia, Hypertext Transfer Protocol. 2016. &lt;<A href="https://de.wikipedia.org/wiki/Hypertext_Transfer_Protocol">
<FONT color="#0462C1">https://de.wikipedia.org/wiki/Hyper-text_Transfer_Protocol</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Wikipedia 2016g  </P
><P 

>Wikipedia, Application-Layer Protocol Negotiation. 2016. &lt;<A href="https://de.wikipedia.org/wiki/Application-Layer_Protocol_Negotiation">
<FONT color="#0462C1">https://de.wikipedia.org/wiki/Ap-plication-Layer_Protocol_Negotiation</A>
<FONT color="#000000">&gt; (24. September 2016).<FONT color="#0462C1"> </P
><P 

> </P
><P 

><FONT color="#000000">Wireshark Foundation 2016a </P
><P 

>Wireshark Foundation, Wireshark. 2016. &lt;<A href="https://www.wireshark.org/">
<FONT color="#0462C1">https://www.wireshark.org/</A>
<FONT color="#000000">&gt; (24. September 2016).<FONT color="#0462C1"> </P
><P 

><FONT color="#000000"> </P
><P 

>Wireshark Foundation 2016b </P
><P 

>Wireshark Foundation, Hypertext Transfer Protocol version 2 (HTTP2). 2016. &lt;<A href="https://wiki.wireshark.org/HTTP2">
<FONT color="#0462C1">https://wiki.wireshark.org/HTTP2</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>Wireshark Foundation 2016c </P
><P 

>Wireshark Foundation , Display Filter Reference: HyperText Transfer Protocol 2. 2016. &lt;<A href="https://www.wireshark.org/docs/dfref/h/http2.html">
<FONT color="#0462C1">https://www.wireshark.org/docs/dfref/h/http2.html</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

>W3C 2014a  </P
><P 

>W3C, HTML5. 2014. &lt;<A href="https://www.w3.org/TR/html5/">
<FONT color="#0462C1">https://www.w3.org/TR/html5/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>W3C 2014b </P
><P 

>W3C, Scripting-HTML5. 2014. &lt;<A href="https://www.w3.org/TR/html5/scripting-1.html">
<FONT color="#0462C1">https://www.w3.org/TR/html5/scripting-1.html</A>
<FONT color="#000000">&gt; (24. Septem-ber 2016). </P
><P 

><FONT color="#0462C1"> </P
><P 

><FONT color="#000000">W3C 2016a  </P
><P 

>W3C, W3C. 2016. &lt;<A href="https://www.w3.org/">
<FONT color="#0462C1">https://www.w3.org/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>W3C 2016b   </P
><P 

>W3C, Navigation Timing Level 2. 2016. &lt;<A href="https://www.w3.org/TR/navigation-timing-2/">
<FONT color="#0462C1">https://www.w3.org/TR/navigation-timing-2/</A>
<FONT color="#000000">&gt; (24. September 2016). </P
><P 

> </P
><P 

>W3C 2016c    </P
><P 

>W3C, Resource Timing Level 1. 2016. &lt;<A href="https://www.w3.org/TR/resource-timing/">
<FONT color="#0462C1">https://www.w3.org/TR/resource-timing/</A>
<FONT color="#000000">&gt; (24. Sep-tember 2016).<FONT color="#0462C1"> </P
><H1 

><FONT size="+1" color="#000000">8. Kurzfassung / Abstract </H1
><P 

><FONT size="+1">Kurzfassung </P
><P 

>Heutzutage sind perfomante Webanwendungen, die schnell geladen werden und genauso schnell mit den Nutzern interagieren k&ouml;nnen, immer gefragter. Dabei spielt die Webperfor-mance &ndash; Optimierung eine gro&szlig;e Rolle. Im Mai 2015 ist die neue Version des HTTP &ndash; Protokolls (HTTP/2) erschienen, mithilfe deren Verwendung die Daten&uuml;bertragung schneller und effizien-ter sein sollte. Hinsichtlich der technologischen M&ouml;glichkeiten des HTTP/2 &ndash; Protokolls kann der Austausch zwischen dem Client und dem Server deutlich beschleunigt werden. In der ak-tuellen Masterarbeit werden die Techniken zu Frontend &ndash; Optimierungstechniken evaluiert, die unter der Verwendung des neuen Protokolls gut geeignet sein k&ouml;nnen. Besonders wurde dabei auf die Funktion &bdquo;Server Push&ldquo; geachtet. Au&szlig;erdem wird dargestellt, welche notwendigen Ma&szlig;-nahmen die Webentwickler unternehmen m&uuml;ssen, um das neue Protokoll benutzen zu k&ouml;nnen. Unter anderem wird evaluiert, wie gut aktuelle Implementierungen des neuen Protokolls und der dazugeh&ouml;rigen Funktionen funktionieren und wie sich die Ladezeit zwischen dem aktuell meist verwendeten Protokoll HTTP/1.1- und dem HTTP/2 &ndash; Protokoll unterscheidet. </P
><P 

>Abstract </P
><P 

>Nowadays, dynamic web-applications are growing in popularity because of their quality of fast loading and their immediate interaction with the user. Web performance optimization plays an important role in this process. The newest version of the HTTP &ndash; Protocol, HTTP/2, was pub-lished in May 2015 which should increase the speed of data transmission and make it more efficient. With regard to the technological possibilities of the HTTP/2 &ndash; Protocol, the transfer between server and client can be accelerated. This master thesis will evaluate the technique of front end optimization which might work well with the new protocol. A particular focus of the thesis will be the function &ldquo;Server Push&rdquo;. Furthermore, necessary measures of web development will be outlined to show the optimal usage of the protocol. Amongst other things, it will be explained how current implementations of the protocol with their functions work and it what ways the page load time of the current HTTP/1.1 &ndash; Protocol and the new published HTTP/2 &ndash; Protocol differ from each other.  </P
><H1 

><FONT size="+1">9. Anhang </H1
><H2 

><FONT size="+1">9.1. Upgrade HTTP/2 </H2
><P 

><FONT size="+1">Erster Fall: Es wird eine verschl&uuml;sselte Verbindung angefragt </P
><P 

> </P
><P 

>&gt; curl -v https://im-im2.hdm-stuttgart.de/ </P
><P 

>*   Trying 141.62.110.42... </P
><P 

>* Connected to im-im2.hdm-stuttgart.de (141.62.110.42) port 443 (#0) </P
><P 

>* ALPN, offering h2 </P
><P 

>* ALPN, offering http/1.1 </P
><P 

>* Cipher selection: ALL:!EXPORT:!EXPORT40:!EXPORT56:!aNULL:!LOW:!RC4:@STRENGTH </P
><P 

>* successfully set certificate verify locations: </P
><P 

>*   CAfile: D:\CURL\ca-bundle.crt </P
><P 

>  CApath: none </P
><P 

>* TLSv1.2 (OUT), TLS header, Certificate Status (22): </P
><P 

>* TLSv1.2 (OUT), TLS handshake, Client hello (1): </P
><P 

>* TLSv1.2 (IN), TLS handshake, Server hello (2): </P
><P 

>* TLSv1.2 (IN), TLS handshake, Certificate (11): </P
><P 

>* TLSv1.2 (IN), TLS handshake, Server key exchange (12): </P
><P 

>* TLSv1.2 (IN), TLS handshake, Server finished (14): </P
><P 

>* TLSv1.2 (OUT), TLS handshake, Client key exchange (16): </P
><P 

>* TLSv1.2 (OUT), TLS change cipher, Client hello (1): </P
><P 

>* TLSv1.2 (OUT), TLS handshake, Finished (20): </P
><P 

>* TLSv1.2 (IN), TLS change cipher, Client hello (1): </P
><P 

>* TLSv1.2 (IN), TLS handshake, Finished (20): </P
><P 

>* SSL connection using TLSv1.2 / ECDHE-RSA-AES128-GCM-SHA256 </P
><P 

>* ALPN, server accepted to use h2 </P
><P 

>* Server certificate: </P
><P 

>*  subject: C=DE; ST=Baden-Wuerttemberg; L=Stuttgart; O=Hochschule der Medien Stutt-gart; OU=InteraktiveMedien; CN=im-im2.hdm-stuttgart.de </P
><P 

>*  start date: Jun  8 08:56:10 2016 GMT </P
><P 

>*  expire date: Jul  9 23:59:00 2019 GMT </P
><P 

>*  subjectAltName: host &quot;im-im2.hdm-stuttgart.de&quot; matched cert's &quot;im-im2.hdm-stuttgart.de&quot; </P
><P 

>*  issuer: C=DE; O=DFN-Verein; OU=DFN-PKI; CN=DFN-CA Global </P
><P 

>*  SSL certificate verify ok. </P
><P 

>* Using HTTP2, server supports multi-use </P
><P 

>* Connection state changed (HTTP/2 confirmed) </P
><P 

>* TCP_NODELAY set </P
><P 

>* Copying HTTP/2 data in stream buffer to connection buffer after upgrade: len=0 </P
><P 

>* Using Stream ID: 1 (easy handle 0x400560) </P
><P 

>&gt; GET / HTTP/1.1 </P
><P 

>&gt; Host: im-im2.hdm-stuttgart.de </P
><P 

>&gt; User-Agent: curl/7.48.0 </P
><P 

>&gt; Accept: */* </P
><P 

>&gt; </P
><P 

>* Connection state changed (MAX_CONCURRENT_STREAMS updated)! </P
><P 

>&lt; HTTP/2.0 200 </P
><P 

>&lt; date:Fri, 26 Aug 2016 12:48:24 GMT </P
><P 

>&lt; server:Apache </P
><P 

>&lt; last-modified:Tue, 02 Aug 2016 07:39:47 GMT </P
><P 

>&lt; etag:&quot;4b1b-53911d22dd6c0&quot; </P
><P 

>&lt; accept-ranges:bytes </P
><P 

>&lt; content-length:19227 </P
><P 

>&lt; vary:Accept-Encoding </P
><P 

>&lt; cache-control:max-age=3600 </P
><P 

>&lt; expires:Fri, 26 Aug 2016 13:48:24 GMT </P
><P 

>&lt; content-type:text/html </P
><P 

> </P
><P 

>Zweiter Fall: Es wird eine unverschl&uuml;sselte Verbindung angefragt </P
><P 

> </P
><P 

>&gt; curl -v http://im-im2.hdm-stuttgart.de/ </P
><P 

>*   Trying 141.62.110.42... </P
><P 

>* Connected to im-im2.hdm-stuttgart.de (141.62.110.42) port 80 (#0) </P
><P 

>&gt; GET / HTTP/1.1 </P
><P 

>&gt; Host: im-im2.hdm-stuttgart.de </P
><P 

>&gt; User-Agent: curl/7.48.0 </P
><P 

>&gt; Accept: */* </P
><P 

>&gt; </P
><P 

>&lt; HTTP/1.1 200 OK </P
><P 

>&lt; Date: Fri, 26 Aug 2016 12:47:31 GMT </P
><P 

>&lt; Server: Apache </P
><P 

>&lt; Upgrade: h2 </P
><P 

>&lt; Connection: Upgrade </P
><P 

>&lt; Last-Modified: Tue, 02 Aug 2016 07:39:47 GMT </P
><P 

>&lt; ETag: &quot;4b1b-53911d22dd6c0&quot; </P
><P 

>&lt; Accept-Ranges: bytes </P
><P 

>&lt; Content-Length: 19227 </P
><P 

>&lt; Vary: Accept-Encoding </P
><P 

>&lt; Cache-Control: max-age=3600 </P
><P 

>&lt; Expires: Fri, 26 Aug 2016 13:47:31 GMT </P
><P 

>&lt; Content-Type: text/html </P
><P 

> </P
><H2 

><FONT size="+1">9.2. Browserstatistik </H2
><P 

><FONT size="+1"> </P
><IMG width="605" height="391"
 src="images/Masterarbeit Iuliia Poberezhnaia_img_60.jpg" ><DL 

><DD 

><I>Abb. 60:</I><I> </I><I>Vergleich der am h&auml;ufigsten eingesetzten Webbrowsern. Die Daten wurden zwischen Juli 2015 und Juli 2016 gemessen (&lt;</I><A href="http://gs.statcounter.com/#desktop-browser_version_partially_combined-ww-monthly-201507-201607-ba">
<I>http://gs.statcounter.com/#desktop-browser_version_parti-ally_combined-ww-monthly-201507-201607-ba</I></A>
<I>&gt;). </I></DD
></DL
></DIV
></BODY>
</HTML>
